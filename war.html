<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tornado War ‚Äì Admin</title>
  <style>
    :root { --bg:#0f172a; --panel:#0b1220; --border:#1f2a44; --text:#e5e7eb; --muted:#9aa3b2; --accent:#22d3ee; }
    * { box-sizing: border-box }
    html, body { height:100% }
    body { margin:0; background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { position:sticky; top:0; z-index:3; background:#0d1628cc; backdrop-filter: blur(6px); border-bottom:1px solid var(--border); }
    .bar { display:flex; gap:8px; align-items:center; padding:10px 14px; flex-wrap:wrap }
    .bar h1 { font-size:18px; margin:0 8px 0 0; }
    .pill { padding:8px 12px; border:1px solid var(--border); border-radius:10px; background:var(--panel); color:var(--text); cursor:pointer; }
    .pill[disabled] { opacity:.6; cursor:not-allowed }
    .muted { color:var(--muted) }
    .wrap { display:grid; grid-template-columns: 400px 1fr 300px; gap:12px; padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:12px; }
    .title { font-size:14px; text-transform:uppercase; letter-spacing:.08em; color:var(--muted); margin:0 0 8px; }
    #gamesList { width: 100%; }
    #roster { display:flex; flex-direction:column; gap:3px; max-height: calc(100vh - 220px); overflow:auto; }
    .row { display:grid; grid-template-columns: 1fr auto; gap:3px; align-items:center; padding:2px 4px; border:1px solid var(--border); border-radius:6px; cursor:pointer; font-size:11px; }
    .row-actions { display:flex; flex-wrap:wrap; gap:2px; justify-content:flex-end; }
    .row.sel { outline:2px solid var(--accent) }
    .bal { font-variant-numeric: tabular-nums; }
    .chip { padding:1px 4px; border:1px solid var(--border); border-radius:4px; font-size:10px; color:var(--muted) }
    .plus { padding:1px 3px; border:1px solid var(--border); border-radius:4px; background:#12223a; cursor:pointer; font-size:9px }
    #board { width:100%; height: 85vh; background:#0a1220; border:1px solid var(--border); border-radius:16px; overflow:hidden; }
    #grid { width:100%; height:100%; display:grid; gap: 3px; padding: 4px; box-sizing: border-box; }
    .cell { border:1px solid #0d1930; border-radius: 8px; display:flex; align-items:center; justify-content:center; font-size:11px; user-select:none; position:relative; box-shadow: inset 0 0 0 1px #00000020; overflow-wrap:anywhere; }
    @media (max-height: 800px) { #board { height: 75vh; } }
    .castle { font-weight:bold; filter: drop-shadow(0 1px 0 #0008) }
    .section { margin: 10px 0 0 }
    input, textarea, select { width:100%; padding:10px; border:1px solid var(--border); border-radius:10px; background:#081125; color:var(--text) }
    textarea { min-height: 160px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    table { width:100%; border-collapse: collapse; }
    th, td { padding:6px 4px; border-bottom: 1px solid var(--border); text-align:left; font-size:14px }
    .minor { font-size:12px; color:var(--muted) }
    .ok { color:#86efac } .warn { color:#facc15 } .err { color:#f87171 }
    
    /* Team color picker */
    .team-color-picker { display: flex; gap: 8px; margin: 8px 0; }
    .color-option { width: 24px; height: 24px; border-radius: 50%; border: 2px solid var(--border); cursor: pointer; }
    .color-option.selected { border-color: var(--accent); border-width: 3px; }
    .team-section { margin: 8px 0; padding: 8px; border: 1px solid var(--border); border-radius: 8px; }
    .team-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
    .team-dot { width: 16px; height: 16px; border-radius: 50%; border: 1px solid var(--border); cursor: pointer; }
    .team-name-input { flex: 1; padding: 4px 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text); }

    /* Help modal */
    .modal { position:fixed; inset:0; background:#0009; display:none; place-items:center; z-index:50; }
    .modal.show { display:grid; }
    .card { width:min(900px,92vw); max-height:82vh; overflow:auto; background:var(--panel); border:1px solid var(--border); border-radius:16px; padding:18px; }
    .card h2 { margin:0 0 8px }
    .card p, .card li { color:#cbd5e1; line-height:1.5 }
    .closeX { float:right; font-size:14px; opacity:.8; cursor:pointer; padding:6px 8px; border:1px solid var(--border); border-radius:8px; }
  </style>
</head>
<body>

<header>
  <div class="bar">
    <h1 style="cursor: pointer;" onclick="window.location.href = '/'">TORNADO WAR <span id="modeIndicator" style="font-size: 0.7em; background: #6f5c91; color: white; padding: 2px 6px; border-radius: 4px; margin-left: 8px;">School Mode</span></h1>
    <button class="pill" id="btnTruces">Truces</button>
    <button class="pill" id="btnHelp">How to Play</button>
        <button class="pill" id="btnReset" style="background: #dc2626; color: white;">üîÑ New Game</button>
    <div style="flex:1"></div>
    <span id="who" class="muted">Not signed in</span>
    <button class="pill" id="signin">Sign in with Google</button>
    <button class="pill" id="signout" style="background: #dc2626; color: white; display: none;">Sign Out</button>
    <button class="pill" id="playOffline" style="background: #10b981; color: white;">Play Offline</button>
  </div>
</header>

<div class="wrap">
  <!-- LEFT: roster and create -->
  <div class="panel">
    <div class="section">
      <div class="title" id="rosterTitle">Roster</div>
      <select id="rosterList"></select>
      <div class="minor" id="victory"></div>
    </div>
    
    <!-- Moved up: Story Events and Sort roster -->
    <div class="section" id="storyEventsSection" style="display: none;">
      <div class="title">üìö Story Events</div>
      <div style="margin-bottom: 8px;">
        <label style="display: block; margin-bottom: 4px; font-size: 12px; color: var(--muted);">Select Scene:</label>
        <select id="storyEventSelect" style="
          width: 100%;
          padding: 6px 8px;
          border: 1px solid var(--border);
          border-radius: 6px;
          background: var(--panel);
          color: var(--text);
          font-size: 12px;
          margin-bottom: 8px;
        ">
          <option value="">Choose a scene...</option>
        </select>
        <button class="pill" id="triggerStoryEvent" style="background: #6f5c91; font-size: 12px; width: 100%;" disabled>Trigger Event</button>
      </div>
    </div>

    <div class="section">
      <div class="title">Sort roster</div>
      <div style="margin-bottom: 8px;">
        <button class="pill" onclick="sortWarRoster('first')" style="background: #6f5c91; font-size: 12px;">First Name</button>
        <button class="pill" onclick="sortWarRoster('last')" style="background: #6f5c91; font-size: 12px;">Last Name</button>
        <button class="pill" onclick="shuffleWarRoster()" style="background: #6f5c91; font-size: 12px;">Shuffle</button>
      </div>
    </div>

    <div class="section">
      <div class="title">Students</div>
      <div id="roster"></div>
    </div>

    <div class="section">
      <div class="title">Quick awards</div>
      <div style="margin-bottom: 8px;">
        <button class="pill" onclick="quickAward(1)" style="background: #10b981; font-size: 12px;">+1 All</button>
        <button class="pill" onclick="quickAward(10)" style="background: #3b82f6; font-size: 12px;">+10 All</button>
        <button class="pill" onclick="quickAward(20)" style="background: #8b5cf6; font-size: 12px;">+20 All</button>
        <button class="pill" onclick="quickAward(-1)" style="background: #f59e0b; font-size: 12px;">-1 All</button>
        <button class="pill" onclick="quickAward(-10)" style="background: #ef4444; font-size: 12px;">-10 All</button>
      </div>
    </div>

    <!-- Moved down: roster management & reset controls -->
    <div class="section">
      <div class="title">Roster Tools</div>
      <div style="margin-top: 8px; display: flex; gap: 8px;">
        <button class="pill" id="loadRosterBtn" style="background: #6f5c91; color: white; flex: 1;">Manage Rosters</button>
        <button class="pill" id="saveRosterBtn" style="background: #10b981; color: white; flex: 1;">Save Roster</button>
        <button class="pill" id="createQuickRosterBtn" style="background: #f59e0b; color: white; flex: 1;">Quick Roster</button>
        <button class="pill" id="createTeamsBtn" style="background: #8b5cf6; color: white; flex: 1;">Create Teams</button>
      </div>
      <div style="margin-top: 8px; display: flex; gap: 8px;">
        <button class="pill" id="resetEarnedGameBtn" title="Reset earned points for this game only" style="background: #334155; color: white; flex: 1;">Reset Earned (Game)</button>
        <button class="pill" id="resetEarnedRosterBtn" title="Reset earned points saved on this roster" style="background: #0ea5e9; color: white; flex: 1;">Reset Earned (Roster)</button>
      </div>
    </div>


    <div class="section" id="aiControls" style="display: none;">
      <div class="title">AI Simulation</div>
      <div style="margin-bottom: 8px;">
        <button class="pill" onclick="simulateAllAI()" style="background: #8b5cf6; font-size: 12px;">Simulate All AI</button>
        <button class="pill" onclick="takeAllAITurns()" style="background: #f59e0b; font-size: 12px;">ü§ñ All AI Turn</button>
        <button class="pill" onclick="showIndividualAIControls()" style="background: #3b82f6; font-size: 12px;">Individual AI</button>
      </div>
      <div id="individualAIControls" style="display: none; margin-top: 8px;">
        <div class="title" style="font-size: 12px;">Individual AI Characters</div>
        <div id="aiCharacterList"></div>
      </div>
    </div>

    <div class="section" id="educationalControls" style="display: none;">
      <div class="title">Educational Content</div>
      <div style="margin-bottom: 8px;">
        <button class="pill" onclick="showRandomHistoricalFact()" style="background: #f59e0b; font-size: 12px;">Random Fact</button>
        <button class="pill" onclick="showEducationalHelp()" style="background: #10b981; font-size: 12px;">Help</button>
      </div>
    </div>


  </div>

  <!-- RIGHT: map -->
  <div class="panel">
    <div class="title">Map</div>
    <div id="gameThemeTitle" style="
      background: linear-gradient(135deg, #8b5cf6, #3b82f6);
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 1rem;
      text-align: center;
      font-weight: 600;
      font-size: 16px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      cursor: pointer;
      transition: all 0.2s ease;
    ">
      üéÆ New Game
    </div>
    <div id="teamScoreboards" style="margin-bottom: 1rem;"></div>
    <div id="board">
      <div id="grid"></div>
    </div>
    <div class="minor" id="tip">Tip: click a roster name, then click a tile.</div>
  </div>
  
  <!-- RIGHT: Business Mode Sidebar -->
  <div class="panel" id="businessSidebar" style="display: none;">
    <div class="title">Business Tools</div>
    
    <!-- Tab Navigation -->
    <div style="display: flex; gap: 4px; margin-bottom: 12px;">
      <button class="business-tab active" data-tab="leaderboard" style="flex: 1; padding: 6px; border: 1px solid var(--border); border-radius: 6px; background: var(--panel); color: var(--text); cursor: pointer; font-size: 11px;">Leaderboard</button>
      <button class="business-tab" data-tab="metrics" style="flex: 1; padding: 6px; border: 1px solid var(--border); border-radius: 6px; background: var(--panel); color: var(--text); cursor: pointer; font-size: 11px;">Metrics</button>
      <button class="business-tab" data-tab="announcements" style="flex: 1; padding: 6px; border: 1px solid var(--border); border-radius: 6px; background: var(--panel); color: var(--text); cursor: pointer; font-size: 11px;">Announcements</button>
      <button class="business-tab" data-tab="rewards" style="flex: 1; padding: 6px; border: 1px solid var(--border); border-radius: 6px; background: var(--panel); color: var(--text); cursor: pointer; font-size: 11px;">Rewards</button>
    </div>
    
    <!-- Tab Content -->
    <div id="businessTabContent">
      <!-- Leaderboard Tab (default) -->
      <div id="tab-leaderboard" class="business-tab-panel">
        <div class="title">Team Rankings</div>
        <div id="businessLeaderboard"></div>
      </div>
      
      <!-- Metrics Tab -->
      <div id="tab-metrics" class="business-tab-panel" style="display: none;">
        <div class="title">Performance Metrics</div>
        <div style="margin-bottom: 8px;">
          <button id="addMetricBtn" style="width: 100%; padding: 6px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">+ Add Metric</button>
        </div>
        <div id="metricsList"></div>
        <div style="margin-top: 8px;">
          <button id="csvImportBtn" style="width: 100%; padding: 6px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">üìä CSV Import</button>
        </div>
      </div>
      
      <!-- Announcements Tab -->
      <div id="tab-announcements" class="business-tab-panel" style="display: none;">
        <div class="title">Company Updates</div>
        <div style="margin-bottom: 8px;">
          <button id="newAnnouncementBtn" style="width: 100%; padding: 6px; background: #8b5cf6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">+ New Announcement</button>
        </div>
        <div id="announcementsList"></div>
      </div>
      
      <!-- Rewards Tab -->
      <div id="tab-rewards" class="business-tab-panel" style="display: none;">
        <div class="title">Rewards & Incentives</div>
        <div style="margin-bottom: 8px;">
          <label style="display: block; font-size: 11px; color: var(--muted); margin-bottom: 4px;">Winning Team Gets:</label>
          <input type="text" id="rewardTeam" placeholder="e.g., Team dinner" style="width: 100%; padding: 6px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text); font-size: 11px;">
        </div>
        <div style="margin-bottom: 8px;">
          <label style="display: block; font-size: 11px; color: var(--muted); margin-bottom: 4px;">Top Player Gets:</label>
          <input type="text" id="rewardPlayer" placeholder="e.g., 1 PTO day" style="width: 100%; padding: 6px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text); font-size: 11px;">
        </div>
        <div style="margin-top: 8px;">
          <button id="saveRewardsBtn" style="width: 100%; padding: 6px; background: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Save Rewards</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- AI Action Display Modal -->
<div id="aiActionModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; align-items: center; justify-content: center;">
  <div style="background: white; border-radius: 12px; padding: 2rem; max-width: 600px; width: 90%; max-height: 80%; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
      <h2 style="margin: 0; color: #1e293b;">ü§ñ AI Turn Sequence</h2>
      <button onclick="closeAIActionModal()" style="background: #ef4444; color: white; border: none; border-radius: 6px; padding: 8px 12px; cursor: pointer;">‚úï Close</button>
    </div>
    <div id="aiActionLog" style="max-height: 400px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px; padding: 1rem; background: #f8fafc;">
      <!-- AI actions will be displayed here -->
    </div>
    <div style="margin-top: 1rem; text-align: center;">
      <button id="nextAIActionBtn" onclick="nextAIAction()" style="background: #8b5cf6; color: white; border: none; border-radius: 6px; padding: 12px 24px; cursor: pointer; font-size: 16px;">Next AI Action</button>
      <button onclick="closeAIActionModal()" style="background: #6b7280; color: white; border: none; border-radius: 6px; padding: 12px 24px; cursor: pointer; font-size: 16px; margin-left: 10px;">Close Modal</button>
    </div>
    <div style="margin-top: 1rem; text-align: center; font-size: 12px; color: #6b7280;">
      Press ESC to close ‚Ä¢ Click outside modal to close
    </div>
  </div>
</div>

<!-- Actions panel below the main content -->
<div class="panel" style="margin: 12px;">
  <div class="title">Actions & Game Info</div>
    <div id="context">Select a student, then click a tile.</div>

    <div class="section">
      <div class="title">Truces</div>
      <div id="truces"></div>
    </div>

    <div class="section">
      <div class="title">Recent activity</div>
      <div id="audit"></div>
  </div>
</div>

<!-- Help modal -->
<div id="helpModal" class="modal" aria-hidden="true">
  <div class="card">
    <button class="closeX" id="helpClose">Close</button>
    <h2>How to Play ‚Äì Tornado War</h2>
    
    <h3>üéØ Getting Started</h3>
    <ul>
      <li><b>Create or select a roster:</b> Use the "Manage Roster" button to create student lists</li>
      <li><b>Set victory percentage:</b> Choose what % of territories needed to win</li>
      <li><b>Click "Create Game":</b> Students start with 10 points each</li>
    </ul>
    
    <h3>üéÆ Basic Gameplay</h3>
    <ul>
      <li><b>Select a student:</b> Click their name in the roster to highlight their territories</li>
      <li><b>Buy territories:</b> Click empty tiles to purchase them</li>
      <li><b>Upgrade castles:</b> Click your territories to build defenses (Level 1-3)</li>
      <li><b>Attack enemies:</b> Select attacker ‚Üí click enemy tile ‚Üí choose weapons ‚Üí resolve battle</li>
    </ul>
    
    <h3>‚öîÔ∏è Combat System</h3>
    <ul>
      <li><b>Weapons cost points:</b> Higher levels = better attack power</li>
      <li><b>Castles provide defense:</b> Higher levels = harder to capture</li>
      <li><b>Successful attacks:</b> Destroy enemy castle and capture territory</li>
      <li><b>Failed attacks:</b> Lose weapons and points</li>
    </ul>
    
    <h3>ü§ù Alliances & Strategy</h3>
    <ul>
      <li><b>Form truces:</b> Students can have up to 2 alliances</li>
      <li><b>Allied players:</b> Cannot attack each other</li>
      <li><b>Coalition victory:</b> Teams need more territories to win together</li>
    </ul>
    
    <h3>üå™Ô∏è Special Actions</h3>
    <ul>
      <li><b>Award points:</b> Give students extra points for good answers</li>
      <li><b>Buy tornado:</b> Spend 50 points to randomly affect territories</li>
      <li><b>Batch actions:</b> Award points to multiple students at once</li>
    </ul>
    
    <h3>üèÜ Winning</h3>
    <ul>
      <li><b>Individual victory:</b> Control the target % of territories</li>
      <li><b>Team victory:</b> Allied players need proportionally more territories</li>
    </ul>
    
    <p class="minor"><b>üí° Pro Tip:</b> Everything saves automatically. Check the Activity panel to see recent moves!</p>
  </div>
</div>

<!-- Roster Selection Modal -->
<div id="rosterSelectionModal" class="modal" aria-hidden="true">
  <div class="card" style="width: min(600px, 90vw);">
    <button class="closeX" id="rosterSelectionClose">Close</button>
    <h2>Select Roster</h2>
    
    <div id="rosterSelectionContent" style="margin: 20px 0;">
      <!-- Existing rosters will be populated here -->
    </div>
    
    <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border); display: flex; gap: 10px;">
      <button id="createNewRosterBtn" class="pill" style="background: #6f5c91; color: white; flex: 1;">Create New Roster</button>
      <button id="manageRostersBtn" class="pill" style="background: #31727a; color: white; flex: 1;">Manage Rosters</button>
    </div>
  </div>
</div>

<!-- Fight Screen Modal -->
<div id="fightModal" class="modal" aria-hidden="true">
  <div class="card" style="width: min(1200px, 95vw); max-height: 90vh;">
    <button class="closeX" id="fightClose">Close</button>
    <h2>‚öîÔ∏è Battle Preparation</h2>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
      <!-- Attacker Panel -->
      <div class="panel">
        <h3 id="attackerName" style="color: #10b981;">Attacker</h3>
        <div class="section">
          <div class="title">Resources</div>
          <div>üí∞ Balance: <span id="attackerBalance">0</span></div>
        </div>
        <div class="section">
          <div class="title">Mercenaries</div>
          <div style="display: flex; gap: 10px; align-items: center;">
            <button class="pill" id="attackerMercMinus">-</button>
            <span id="attackerMercCount">0</span>
            <button class="pill" id="attackerMercPlus">+</button>
            <span class="minor" id="attackerMercNote">(15 points each)</span>
          </div>
        </div>
        <div class="section">
          <div class="title">Weapons</div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="pill" id="attackerSpear" style="background: #8b5cf6;">Spear</button>
            <button class="pill" id="attackerCrossbow" style="background: #3b82f6;">Crossbow</button>
            <button class="pill" id="attackerCatapult" style="background: #dc2626;">Catapult</button>
          </div>
          <div class="minor">Selected: <span id="attackerWeapons">None</span></div>
          <div id="attackerWeaponList" style="margin-top: 8px;"></div>
        </div>
        <div class="section" id="attackerAlliesSection">
          <div class="title">Magical Allies</div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="pill" id="attackerPhoenix" style="background: #f59e0b;">Phoenix (150 pts)</button>
            <button class="pill" id="attackerHorntail" style="background: #dc2626;">Hungarian Horntail (200 pts)</button>
            <button class="pill" id="attackerBasilisk" style="background: #059669;">Basilisk (250 pts)</button>
          </div>
          <div class="minor">Selected: <span id="attackerAllies">None</span></div>
          <div id="attackerAlliesList" style="margin-top: 8px;"></div>
        </div>
        <div class="section" id="attackerSpellsSection">
          <div class="title">Special Spells</div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="pill" id="attackerExpelliarmus" style="background: #7c3aed;">Expelliarmus (80 pts)</button>
            <button class="pill" id="attackerProtego" style="background: #1d4ed8;">Protego (120 pts)</button>
            <button class="pill" id="attackerPatronus" style="background: #059669;">Expecto Patronum (200 pts)</button>
          </div>
          <div class="minor">Selected: <span id="attackerSpells">None</span></div>
          <div id="attackerSpellsList" style="margin-top: 8px;"></div>
        </div>
      </div>

      <!-- Defender Panel -->
      <div class="panel">
        <h3 id="defenderName" style="color: #ef4444;">Defender</h3>
        <div class="section">
          <div class="title">Resources</div>
          <div>üí∞ Balance: <span id="defenderBalance">0</span></div>
        </div>
        <div class="section">
          <div class="title">Mercenaries</div>
          <div style="display: flex; gap: 10px; align-items: center;">
            <button class="pill" id="defenderMercMinus">-</button>
            <span id="defenderMercCount">0</span>
            <button class="pill" id="defenderMercPlus">+</button>
            <span class="minor" id="defenderMercNote">(15 points each, +10 power)</span>
          </div>
        </div>
        <div class="section">
          <div class="title">Weapons</div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="pill" id="defenderSpear" style="background: #8b5cf6;">Spear</button>
            <button class="pill" id="defenderCrossbow" style="background: #3b82f6;">Crossbow</button>
            <button class="pill" id="defenderCatapult" style="background: #dc2626;">Catapult</button>
          </div>
          <div class="minor">Selected: <span id="defenderWeapons">None</span></div>
          <div id="defenderWeaponList" style="margin-top: 8px;"></div>
        </div>
        <div class="section" id="defenderAlliesSection">
          <div class="title">Magical Allies</div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="pill" id="defenderPhoenix" style="background: #f59e0b;">Phoenix (150 pts)</button>
            <button class="pill" id="defenderHorntail" style="background: #dc2626;">Hungarian Horntail (200 pts)</button>
            <button class="pill" id="defenderBasilisk" style="background: #059669;">Basilisk (250 pts)</button>
          </div>
          <div class="minor">Selected: <span id="defenderAllies">None</span></div>
          <div id="defenderAlliesList" style="margin-top: 8px;"></div>
        </div>
        <div class="section" id="defenderSpellsSection">
          <div class="title">Special Spells</div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="pill" id="defenderExpelliarmus" style="background: #7c3aed;">Expelliarmus (80 pts)</button>
            <button class="pill" id="defenderProtego" style="background: #1d4ed8;">Protego (120 pts)</button>
            <button class="pill" id="defenderPatronus" style="background: #059669;">Expecto Patronum (200 pts)</button>
          </div>
          <div class="minor">Selected: <span id="defenderSpells">None</span></div>
          <div id="defenderSpellsList" style="margin-top: 8px;"></div>
        </div>
        <div class="section">
          <div class="title">Castle Defense</div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button class="pill" id="defenderCastle1" style="background: #10b981;">Wooden Keep</button>
            <button class="pill" id="defenderCastle2" style="background: #3b82f6;">Stone Fortress</button>
            <button class="pill" id="defenderCastle3" style="background: #8b5cf6;">Iron Citadel</button>
          </div>
          <div class="minor">Selected: <span id="defenderCastle">None</span> <button class="pill" id="removeDefenderCastle" style="background: #ef4444; color: white; font-size: 12px; padding: 4px 8px; margin-left: 8px;">Remove</button></div>
        </div>
      </div>
    </div>

    <div style="text-align: center; margin: 20px 0;">
      <div class="section">
        <div class="title">Battle Summary</div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 10px 0;">
          <div>
            <div>Attacker Power: <span id="attackerPower">0</span></div>
            <div>Attacker Cost: <span id="attackerCost">0</span> points</div>
          </div>
          <div>
            <div>Defender Power: <span id="defenderPower">0</span></div>
            <div>Defender Cost: <span id="defenderCost">0</span> points</div>
          </div>
        </div>
        <div style="font-size: 18px; font-weight: bold; margin: 15px 0; padding: 10px; border-radius: 8px; background: var(--panel);">
          <span id="victoryOdds">Victory Odds: 50%</span>
        </div>
        <div class="minor" style="margin-top: 10px;" id="powerLegend"></div>
      </div>
      <button class="pill" id="simulateWar" style="background: #dc2626; color: white; font-size: 18px; padding: 15px 30px;">‚öîÔ∏è SIMULATE WAR</button>
    </div>
  </div>
</div>
<script type="module">
  import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

  // === CONFIG ===
  const SUPABASE_URL  = "https://dmbbsrcwqpmdxqtzvtqj.supabase.co";
  const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRtYmJzcmN3cXBtZHhxdHp2dHFqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY3NDg1OTYsImV4cCI6MjA2MjMyNDU5Nn0.E7EYSLCFXMYw5f4Wv7EXXj7-5yAT__BoYXklDB4uE2w";

  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON);

  // === ECONOMY PROFILE (editable / scenario-overridable) ===
  const ECONOMY = {
    mercCost: 15,
    castleL1: 75,
    castleL2: 150,
    castleL3: 300,
    weapons: { spear: 40, crossbow: 80, catapult: 140 },
    victoryBonus: 100,
    centerPremium: 30
  };

  // Difficulty multipliers
  const DIFFICULTY_MULTIPLIERS = {
    easy: 0.5,
    medium: 1.0,
    hard: 1.5
  };
  
  // Active economy is stored separately to avoid referencing state before init
  let __activeEconomy = ECONOMY;
  function getActiveEconomy(){
    const baseEconomy = __activeEconomy || ECONOMY;
    const difficulty = state.gameDifficulty || 'medium';
    const multiplier = DIFFICULTY_MULTIPLIERS[difficulty] || 1.0;
    
    return {
      mercCost: Math.round(baseEconomy.mercCost * multiplier),
      castleL1: Math.round(baseEconomy.castleL1 * multiplier),
      castleL2: Math.round(baseEconomy.castleL2 * multiplier),
      castleL3: Math.round(baseEconomy.castleL3 * multiplier),
      weapons: {
        spear: Math.round(baseEconomy.weapons.spear * multiplier),
        crossbow: Math.round(baseEconomy.weapons.crossbow * multiplier),
        catapult: Math.round(baseEconomy.weapons.catapult * multiplier)
      },
      victoryBonus: Math.round(baseEconomy.victoryBonus * multiplier),
      centerPremium: Math.round(baseEconomy.centerPremium * multiplier)
    };
  }
  function applyEconomyToUI(){
    const eco = getActiveEconomy();
    const mercNoteA = document.getElementById('attackerMercNote');
    const mercNoteD = document.getElementById('defenderMercNote');
    if (mercNoteA) mercNoteA.textContent = `(${eco.mercCost} points each)`;
    if (mercNoteD) mercNoteD.textContent = `(${eco.mercCost} points each, +10 power)`;
  }

  // === STATE ===
  const state = {
    session: null,
    rosters: [],
    currentRoster: null,
    currentRosterId: null,
    board: { w: 0, h: 0, tiles: [] },
    roster: [],
    selectedGsId: null,
    truces: [],
    colors: new Map(),
    costs: { land: 20, castleL1: ECONOMY.castleL1, castleL2: ECONOMY.castleL2, castleL3: ECONOMY.castleL3 },
    aiStipendInterval: null,
    aiStipendPaused: false,
    weaponCosts: { ...ECONOMY.weapons },
    offlineMode: false, // Start in online mode, can switch to offline
    teams: [],
    teamMode: false,
    currentScenario: null,
    activeEvents: [], // Array of currently active event cards
    eventHistory: [], // History of events that have occurred
    territoryBonuses: new Map() // Map of territory bonuses
  };

  // === AUTH (force redirect + ensure_user) ===
  const who = document.getElementById("who");
  const signinBtn = document.getElementById("signin");
  const signoutBtn = document.getElementById("signout");
  const playOfflineBtn = document.getElementById("playOffline");

  async function updateAuth() {
    const { data: { session } } = await supabase.auth.getSession();
    state.session = session;
    console.log('War game auth update:', session ? 'Logged in as ' + session.user.email : 'Not logged in');
    
    if (state.offlineMode) {
      who.textContent = "Playing Offline";
      signinBtn.textContent = "Switch to Online";
      signinBtn.style.display = "inline-block";
      signoutBtn.style.display = "none";
      playOfflineBtn.style.display = "none";
    } else {
    who.textContent = session ? `Signed in as ${session.user.email}` : "Not signed in";
      signinBtn.textContent = "Sign in with Google";
      signinBtn.style.display = session ? "none" : "inline-block";
      signoutBtn.style.display = session ? "inline-block" : "none";
      playOfflineBtn.style.display = session ? "none" : "inline-block";
    }
    
    if (session && !state.offlineMode) {
      // Ensure teacher row exists so RLS allows inserts/selects
      try {
        const { error } = await supabase.rpc("ensure_user");
        if (error && !/function ensure_user/.test(error.message)) console.warn("ensure_user error:", error.message);
      } catch (e) { console.warn("ensure_user exception:", e); }
    }
  }

  signinBtn.addEventListener("click", async (e) => {
    e.preventDefault();
    if (state.offlineMode) {
      // Switch back to online mode
      if (confirm("Switch to online mode? You'll need to sign in to access your saved games. Local games will remain available.")) {
        state.offlineMode = false;
        await updateAuth();
        // Clear any existing game selection
        state.gameId = null;
        state.game = null;
        gamesList.value = "";
        await loadGames(false);
        // Remove offline warning
        const warning = document.getElementById('offlineWarning');
        if (warning) warning.remove();
      }
    } else {
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: "google",
      options: { redirectTo: window.location.href, skipBrowserRedirect: true }
    });
    if (error) { alert("Sign-in error: " + error.message); return; }
    if (data?.url) window.location.assign(data.url);
    }
  });

  signoutBtn.addEventListener("click", async (e) => {
    e.preventDefault();
    if (confirm("Are you sure you want to sign out? You'll lose access to your saved games until you sign in again.")) {
      const { error } = await supabase.auth.signOut();
      if (error) {
        alert("Sign out error: " + error.message);
        return;
      }
      // Clear any existing game selection
      state.gameId = null;
      state.game = null;
      gamesList.value = "";
      await loadGames(false);
    }
  });

  playOfflineBtn.addEventListener("click", async (e) => {
    e.preventDefault();
    if (confirm("Play offline mode? Your games will be saved locally but won't sync across devices. You can still sign in later to save games permanently.\n\nNote: Some advanced features like truces and tornado effects are simplified in offline mode.")) {
      state.offlineMode = true;
      await updateAuth();
      await loadLocalGames();
      showOfflineWarning();
      // Clear any existing game selection
      state.gameId = null;
      state.game = null;
      gamesList.value = "";
      await loadGames(false);
    }
  });

  // Load local games (for offline mode)
  async function loadLocalGames() {
    console.log('Loading local games...');
    // For now, just create a default roster if none exist
    if (state.rosters.length === 0) {
      createDefaultRoster();
    }
  }

  await updateAuth();
  supabase.auth.onAuthStateChange(() => updateAuth());

  // === ECONOMY PANEL WIRING ===
  function loadEconomyPanel(){
    const eco = state.economy || __activeEconomy || ECONOMY;
    const w = eco.weapons || ECONOMY.weapons;
    const get = id => document.getElementById(id);
    if (!get('ecoMerc')) return;
    get('ecoMerc').value = eco.mercCost;
    get('ecoW1').value = w.spear ?? Object.values(w)[0];
    get('ecoW2').value = w.crossbow ?? Object.values(w)[1];
    get('ecoW3').value = w.catapult ?? Object.values(w)[2];
    get('ecoC1').value = eco.castleL1;
    get('ecoC2').value = eco.castleL2;
    get('ecoC3').value = eco.castleL3;
    get('ecoVB').value = eco.victoryBonus;
  }

  function applyEconomyFromPanel(){
    const get = id => document.getElementById(id);
    if (!get('ecoMerc')) return;
    const newEco = {
      mercCost: parseInt(get('ecoMerc').value)||ECONOMY.mercCost,
      castleL1: parseInt(get('ecoC1').value)||ECONOMY.castleL1,
      castleL2: parseInt(get('ecoC2').value)||ECONOMY.castleL2,
      castleL3: parseInt(get('ecoC3').value)||ECONOMY.castleL3,
      weapons: {
        spear: parseInt(get('ecoW1').value)||Object.values(ECONOMY.weapons)[0],
        crossbow: parseInt(get('ecoW2').value)||Object.values(ECONOMY.weapons)[1],
        catapult: parseInt(get('ecoW3').value)||Object.values(ECONOMY.weapons)[2]
      },
      victoryBonus: parseInt(get('ecoVB').value)||ECONOMY.victoryBonus,
      centerPremium: ECONOMY.centerPremium
    };
    state.economy = newEco;
    __activeEconomy = newEco;
    applyEconomyToUI();
    renderRoster();
    autoSaveWarPoints();
  }

  window.addEventListener('load', ()=>{
    loadEconomyPanel();
    const a = document.getElementById('ecoApply');
    const r = document.getElementById('ecoReset');
    if (a) a.onclick = applyEconomyFromPanel;
    if (r) r.onclick = ()=>{ state.economy = { ...ECONOMY }; __activeEconomy = state.economy; loadEconomyPanel(); applyEconomyToUI(); autoSaveWarPoints(); };
  });




  function showOfflineWarning() {
    const warning = document.createElement('div');
    warning.id = 'offlineWarning';
    warning.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #f59e0b;
      color: white;
      padding: 8px;
      text-align: center;
      font-weight: bold;
      z-index: 1000;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    `;
    warning.innerHTML = `
      ‚ö†Ô∏è Playing Offline - Games saved locally only. 
      <button onclick="this.parentElement.remove()" style="background: white; color: #f59e0b; border: none; padding: 4px 8px; border-radius: 4px; margin-left: 8px; cursor: pointer;">Dismiss</button>
    `;
    document.body.insertBefore(warning, document.body.firstChild);
  }

  // === UI HELPERS ===
  const el = (sel) => document.querySelector(sel);
  const rosterList = el("#rosterList");
  const rosterEl = el("#roster");
  const gridEl = el("#grid");
  console.log('Grid element found:', gridEl);
  const contextEl = el("#context");
  const trucesEl = el("#truces");
  const auditEl = el("#audit");
  const victoryEl = el("#victory");

  const helpModal = el("#helpModal");
  el("#btnHelp").onclick = () => helpModal.classList.add("show");
  el("#helpClose").onclick = () => helpModal.classList.remove("show");
  helpModal.addEventListener("click", (e)=>{ if(e.target===helpModal) helpModal.classList.remove("show"); });

  // Roster selection modal
  const rosterSelectionModal = el("#rosterSelectionModal");
  el("#rosterSelectionClose").onclick = () => rosterSelectionModal.classList.remove("show");
  rosterSelectionModal.addEventListener("click", (e)=>{ if(e.target===rosterSelectionModal) rosterSelectionModal.classList.remove("show"); });
  
  el("#createNewRosterBtn").onclick = () => {
    rosterSelectionModal.classList.remove("show");
    window.location.href = '/roster';
  };
  
  el("#manageRostersBtn").onclick = () => {
    rosterSelectionModal.classList.remove("show");
    window.location.href = '/roster';
  };

  function colorFor(gsId, i, total) {
    if (state.colors.has(gsId)) return state.colors.get(gsId);
    
    // Use team-based colors instead of individual colors
    const student = state.roster.find(s => s.gsId === gsId);
    if (student && student.teamColor) {
      state.colors.set(gsId, student.teamColor);
      return student.teamColor;
    }
    
    // Fallback to individual colors if no team color
    const h = Math.round((i / Math.max(total,1)) * 360);
    const c = `hsl(${h} 65% 48%)`;
    state.colors.set(gsId, c);
    return c;
  }
  function formatMoney(n){ return Math.round(n); }

  // === LOAD ROSTERS ===
  async function loadRosters(selectNewest=false) {
    try {
      // Load from localStorage first
      const saved = localStorage.getItem('tornadoRosters');
      state.rosters = saved ? JSON.parse(saved) : [];
      
      // Load from Supabase if logged in
      if (state.session && !state.offlineMode) {
        try {
          const { data, error } = await supabase
            .from('rosters')
            .select('*')
            .eq('teacher_id', state.session.user.id)
            .order('last_modified', { ascending: false });
          
          if (error) {
            console.error('Error loading rosters from Supabase:', error);
          } else if (data && data.length > 0) {
            // Merge Supabase rosters with local ones
            const supabaseRosters = data.map(row => ({
              id: row.id,
              name: row.name,
              ...row.data,
              lastModified: row.last_modified
            }));
            
            // Replace local rosters with Supabase ones (they're more up-to-date)
            state.rosters = supabaseRosters;
            
            // Update localStorage with the latest data
            localStorage.setItem('tornadoRosters', JSON.stringify(state.rosters));
            
            console.log('Loaded rosters from Supabase:', supabaseRosters.length);
          }
        } catch (error) {
          console.error('Error loading from Supabase:', error);
          if (error && (error.code === 'PGRST205' || /Could not find the table 'public.rosters'/.test(error.message||''))) {
            console.warn("Supabase 'rosters' table missing. Falling back to localStorage. Run create-rosters-table SQL to enable cloud saves.");
          }
        }
      }
      
      // Check for quick roster (guest mode)
      const quickRoster = localStorage.getItem('quickRoster');
      if (quickRoster) {
        const quickData = JSON.parse(quickRoster);
        const quickRosterData = {
          id: 'quick-roster',
          name: quickData.name || 'Quick Roster',
          roster: quickData.students.map(name => ({ name, points: 0 })),
          isQuickRoster: true,
          created: new Date().toISOString()
        };
        
        // Add quick roster to the list if it doesn't exist
        const existingQuickRoster = state.rosters.find(r => r.id === 'quick-roster');
        if (!existingQuickRoster) {
          state.rosters.unshift(quickRosterData); // Add to beginning
        } else {
          // Update existing quick roster
          const index = state.rosters.findIndex(r => r.id === 'quick-roster');
          state.rosters[index] = quickRosterData;
        }
      }
    } catch (e) {
      console.error('Error loading rosters:', e);
      state.rosters = [];
    }
    
    rosterList.innerHTML = `<option value="">Select Roster‚Ä¶</option>` + (state.rosters.map(r =>
      `<option value="${r.id}">${r.name} (${r.roster ? r.roster.length : 0} students)${r.isQuickRoster ? ' üéÆ' : ''}</option>`
    ).join(""));
    
    if (selectNewest && state.rosters.length) {
      rosterList.value = state.rosters[0].id;
      selectRoster(state.rosters[0].id);
    }
  }
  // === ROSTER SELECTION ===
  function selectRoster(rosterId) {
    if (!rosterId) return;
    
    const roster = state.rosters.find(r => r.id === rosterId);
    if (!roster) return;
    
    state.currentRoster = roster;
    state.currentRosterId = rosterId;
    
    // Convert roster to war game format, preserving existing scores
    state.roster = roster.roster.map((student, i) => {
      // Check if student already has war game data
      const existingStudent = state.roster.find(s => s.name === student.name);
      
      const studentData = {
        gsId: student.id || `student_${i}`,
        name: student.name,
        tilesOwned: existingStudent?.tilesOwned || 0,
        // Split starting vs earned points
        startingPoints: existingStudent?.startingPoints ?? existingStudent?.startPoints ?? 10,
        earnedPoints: existingStudent?.earnedPoints ?? 0,
        balance: (existingStudent?.startingPoints ?? existingStudent?.startPoints ?? 10) + (existingStudent?.earnedPoints ?? 0),
        teamId: existingStudent?.teamId || null,
        teamName: existingStudent?.teamName || null,
        teamColor: existingStudent?.teamColor || null,
        // Preserve character data from saved roster
        characterName: student.characterName || null,
        characterRole: student.characterRole || null,
        characterFaction: student.characterFaction || null,
        startingCastles: student.startingCastles || 0,
        weapons: student.weapons || [],
        mercenaries: student.mercenaries || 0,
        purchasedItems: student.purchasedItems || {
          weapons: [],
          mercenaries: 0,
          allies: [],
          spells: []
        }
      };
      
      // Assign color to student
      colorFor(studentData.gsId, i, roster.roster.length);
      
      return studentData;
    });
    
    // Apply team information if available
    if (roster.teams && roster.teams.length > 0) {
      state.roster.forEach(student => {
        const team = roster.teams.find(t => 
          t.students && t.students.includes(student.name)
        );
        if (team) {
          student.teamId = team.id;
          student.teamName = team.name;
          student.teamColor = team.color;
        }
      });
      state.teamMode = roster.teamMode || false;
    }
    
    // Initialize truce invitations if not present
    if (!state.truceInvitations) {
      state.truceInvitations = [];
    }
    
    // Handle scenario data if present
    if (roster.scenario) {
      console.log('Loading scenario:', roster.scenario.scenarioName);
      initializeScenario(roster.scenario);
      
      // Re-apply team colors after team assignment
      state.roster.forEach(student => {
        if (student.teamColor) {
          state.colors.set(student.gsId, student.teamColor);
          console.log(`Applied team color ${student.teamColor} to ${student.name}`);
        }
      });
    } else {
      // Clear any existing scenario if roster has no saved scenario
      state.scenario = null;
    }
    
    // Restore AI state and resume ticker if Class vs AI is enabled
    if (roster.aiConfig?.classVsAI) {
      console.log('Restoring AI state for Class vs AI mode');
      if (roster.aiState) {
        // Resume from saved state
        state.currentRoster.aiState = roster.aiState;
      }
      // Start ticker if not already running
      if (!state.aiStipendInterval) {
        startAiStipendTicker();
      }
    } else {
      // Stop ticker if Class vs AI is disabled
      stopAiStipendTicker();
    }

    // Restore territory bonuses
    if (roster.territoryBonuses) {
      state.territoryBonuses = new Map(roster.territoryBonuses);
    } else {
      state.territoryBonuses = new Map();
    }
    
    // Load saved victory goals
    if (roster.victoryGoals) {
      state.victoryGoals = roster.victoryGoals;
    }
    
    // Create or load game board
    initializeGameBoard();
    
    // Update UI
    renderRoster();
    updateVictoryTarget();
    updateTeamScoreboards();
  }
  // Assign teams based on character factions
  function assignTeamsFromCharacters() {
    if (!state.scenario || !state.roster) return;
    
    console.log('Assigning teams based on character factions...');
    
    // First, create AI players from aiAssignments (separate from roster)
    if (state.scenario.aiAssignments) {
      console.log('Creating AI players from aiAssignments:', state.scenario.aiAssignments);
      const aiAssignmentsArray = Object.values(state.scenario.aiAssignments);
      console.log(`Found ${aiAssignmentsArray.length} AI assignments to process`);
      
      // Initialize AI players array if it doesn't exist
      if (!state.aiPlayers) {
        state.aiPlayers = [];
      }
      
      // Clear existing AI players for fresh start
      state.aiPlayers = [];
      
      aiAssignmentsArray.forEach((aiAssignment, index) => {
        console.log(`Processing AI assignment ${index + 1}:`, aiAssignment);
        if (aiAssignment.isAI && !state.aiPlayers.find(s => s.characterName === aiAssignment.roleName)) {
          // Create AI player (separate from roster)
          const aiPlayer = {
            gsId: `ai_${aiAssignment.roleName.replace(/\s+/g, '_').toLowerCase()}_${index}`,
            name: `${aiAssignment.roleName} (AI)`,
            characterName: aiAssignment.roleName,
            characterFaction: aiAssignment.factionName,
            isAI: true,
            startingPoints: 50, // Give AI some starting resources
            earnedPoints: 0,
            balance: 50,
            weapons: [],
            mercenaries: 0,
            castles: 0,
            tilesOwned: 0,
            teamId: null,
            teamName: null,
            teamColor: null
          };
          state.aiPlayers.push(aiPlayer);
          console.log(`Created AI player: ${aiPlayer.name} for faction ${aiAssignment.factionName}`);
        } else {
          console.log(`Skipping AI assignment ${aiAssignment.roleName} - already exists or not AI`);
        }
      });
      console.log('AI players created:', state.aiPlayers.map(s => `${s.name} - ${s.characterName} - ${s.characterFaction}`));
      console.log('Student roster unchanged:', state.roster.map(s => `${s.name} - ${s.characterName} - ${s.characterFaction}`));
      
      // Force render roster to show AI players
      console.log('Calling renderRoster after AI creation...');
      renderRoster();
    } else {
      console.log('No aiAssignments found in scenario');
    }
    
    state.roster.forEach(student => {
      if (student.characterName && student.characterFaction) {
        // Get faction data from scenario
        const scenario = SCENARIOS[state.scenario.scenarioId];
        if (!scenario || !scenario.factions) return;
        
        // Find the faction that matches the student's character faction
        const faction = Object.values(scenario.factions).find(f => f.name === student.characterFaction);
        if (faction) {
          // Use faction key as team ID and faction color as team color
          const factionKey = Object.keys(scenario.factions).find(key => scenario.factions[key] === faction);
          student.teamId = factionKey;
          student.teamName = faction.name;
          student.teamColor = faction.color;
          
          console.log(`Assigned ${student.name} to faction ${faction.name} (${faction.color})`);
        } else {
          // Fallback for general roles - assign based on scenario type
          if (state.scenario.scenarioName.includes('Harry Potter')) {
            if (student.characterName === 'Hogwarts Student' || student.characterName === 'Order Member' || student.characterName === 'Muggle-born') {
              student.teamId = 'good_guys';
              student.teamName = 'Dumbledore\'s Army';
              student.teamColor = '#dc143c'; // Gryffindor red for Dumbledore's Army
            } else if (student.characterName === 'Death Eater' || student.characterName === 'Snatcher' || student.characterName === 'Inferi') {
              student.teamId = 'bad_guys';
              student.teamName = 'Voldemort\'s Army';
              student.teamColor = '#2e8b57'; // Slytherin green for Voldemort's Army
            }
          } else if (state.scenario.scenarioName.includes('Star Wars')) {
            if (student.characterName === 'Rebel Soldier' || student.characterName === 'Rebel Pilot') {
              student.teamId = 'rebels';
              student.teamName = 'Rebel Alliance';
              student.teamColor = '#4169e1'; // Blue for rebels
            } else if (student.characterName === 'Stormtrooper' || student.characterName === 'Imperial Officer') {
              student.teamId = 'empire';
              student.teamName = 'Galactic Empire';
              student.teamColor = '#8b0000'; // Dark red for empire
            } else if (student.characterName === 'Smuggler' || student.characterName === 'Bounty Hunter') {
              student.teamId = 'neutral';
              student.teamName = 'Neutral/Independent';
              student.teamColor = '#808080'; // Gray for neutral
            }
          }
          // Add more scenario-specific general role handling as needed
        }
        
        // Update the color system to use team color
        if (student.teamColor) {
          state.colors.set(student.gsId, student.teamColor);
        }
        
        console.log(`Final assignment: ${student.name} -> Team: ${student.teamName} (${student.teamColor})`);
      }
    });
    
    // Assign teams to AI players (same logic as students)
    if (state.aiPlayers) {
      state.aiPlayers.forEach(aiPlayer => {
        if (aiPlayer.characterName && aiPlayer.characterFaction) {
          // Get faction data from scenario
          const scenario = SCENARIOS[state.scenario.scenarioId];
          if (!scenario || !scenario.factions) return;
          
          // Find the faction that matches the AI player's character faction
          const faction = Object.values(scenario.factions).find(f => f.name === aiPlayer.characterFaction);
          if (faction) {
            // Use faction key as team ID and faction color as team color
            const factionKey = Object.keys(scenario.factions).find(key => scenario.factions[key] === faction);
            aiPlayer.teamId = factionKey;
            aiPlayer.teamName = faction.name;
            aiPlayer.teamColor = faction.color;
            
            console.log(`Assigned AI ${aiPlayer.name} to faction ${faction.name} (${faction.color})`);
          } else {
            // Fallback for general roles - assign based on scenario type
            if (state.scenario.scenarioName.includes('Harry Potter')) {
              if (aiPlayer.characterName === 'Hogwarts Student' || aiPlayer.characterName === 'Order Member' || aiPlayer.characterName === 'Muggle-born') {
                aiPlayer.teamId = 'good_guys';
                aiPlayer.teamName = 'Dumbledore\'s Army';
                aiPlayer.teamColor = '#dc143c'; // Gryffindor red for Dumbledore's Army
              } else if (aiPlayer.characterName === 'Death Eater' || aiPlayer.characterName === 'Snatcher' || aiPlayer.characterName === 'Inferi') {
                aiPlayer.teamId = 'bad_guys';
                aiPlayer.teamName = 'Voldemort\'s Army';
                aiPlayer.teamColor = '#2e8b57'; // Slytherin green for Voldemort's Army
              }
            } else if (state.scenario.scenarioName.includes('Star Wars')) {
              if (aiPlayer.characterName === 'Rebel Soldier' || aiPlayer.characterName === 'Rebel Pilot') {
                aiPlayer.teamId = 'rebels';
                aiPlayer.teamName = 'Rebel Alliance';
                aiPlayer.teamColor = '#4169e1'; // Blue for rebels
              } else if (aiPlayer.characterName === 'Stormtrooper' || aiPlayer.characterName === 'Imperial Officer') {
                aiPlayer.teamId = 'empire';
                aiPlayer.teamName = 'Galactic Empire';
                aiPlayer.teamColor = '#8b0000'; // Dark red for empire
              } else if (aiPlayer.characterName === 'Smuggler' || aiPlayer.characterName === 'Bounty Hunter') {
                aiPlayer.teamId = 'neutral';
                aiPlayer.teamName = 'Neutral/Independent';
                aiPlayer.teamColor = '#808080'; // Gray for neutral
              }
            }
            // Add more scenario-specific general role handling as needed
          }
          
          // Update the color system to use team color
          if (aiPlayer.teamColor) {
            state.colors.set(aiPlayer.gsId, aiPlayer.teamColor);
          }
          
          console.log(`Final AI assignment: ${aiPlayer.name} -> Team: ${aiPlayer.teamName} (${aiPlayer.teamColor})`);
        }
      });
    }
    
    console.log('Team assignments completed');
    renderRoster();
    updateVictoryTarget();
    updateTeamScoreboards();
  }

  // Class vs AI: auto-assign students to characters and create equal number of AI players
  function assignClassVsAITeams(scenarioData) {
    try {
      console.log('assignClassVsAITeams called with:', scenarioData);
      console.log('scenarioData.scenarioId:', scenarioData.scenarioId);
      const scenario = SCENARIOS[scenarioData.scenarioId];
      if (!scenario || !scenario.factions) {
        console.error('No scenario or factions found:', scenarioData.scenarioId);
        return;
      }
      
      console.log('Found scenario:', scenario.name);
      console.log('Scenario factions:', Object.keys(scenario.factions));

      const factionNames = Object.keys(scenario.factions);
      console.log('Available factions:', factionNames);
      if (factionNames.length < 2) {
        console.warn('Class vs AI: Need at least 2 factions for AI vs Students');
        return;
      }

      // Get all characters from all factions
      const allCharacters = [];
      const controversialCharacters = [
        'Adolf Hitler', 'Benito Mussolini', 'Hirohito', 'Isoroku Yamamoto',
        'Lord Voldemort', 'Bellatrix Lestrange', 'Lucius Malfoy', 'Severus Snape',
        'Darth Vader', 'Emperor Palpatine', 'Darth Maul', 'Kylo Ren',
        'Sauron', 'Saruman', 'Witch-king', 'Gollum',
        'Thanos', 'Loki', 'Red Skull', 'Ultron',
        'Bowser', 'Wario', 'Waluigi', 'King K. Rool',
        'Team Rocket', 'Giovanni', 'Archie', 'Maxie',
        'Megatron', 'Starscream', 'Soundwave', 'Shockwave'
      ];
      
      Object.values(scenario.factions).forEach((faction) => {
        if (Array.isArray(faction.characters)) {
          faction.characters.forEach((char) => {
            allCharacters.push({
              name: char.name,
              role: char.role,
              factionName: faction.name,
              factionColor: faction.color,
              isControversial: controversialCharacters.includes(char.name)
            });
          });
        }
        if (Array.isArray(faction.generalRoles)) {
          faction.generalRoles.forEach((role) => {
            allCharacters.push({
              name: role.name,
              role: role.name,
              factionName: faction.name,
              factionColor: faction.color,
              isControversial: controversialCharacters.includes(role.name)
            });
          });
        }
      });

      if (allCharacters.length === 0) {
        console.warn('Class vs AI: No characters found');
        return;
      }

      const roleAssignments = {};
      const aiAssignments = {};
      const studentCount = state.roster.length;
      
      console.log(`Creating Class vs AI matchup: ${studentCount} students vs ${studentCount} AI players`);

      // Shuffle students array to ensure true randomization
      const shuffledStudents = [...state.roster];
      for (let i = shuffledStudents.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffledStudents[i], shuffledStudents[j]] = [shuffledStudents[j], shuffledStudents[i]];
      }

      // For AI vs Students: Students get GOOD faction characters, AI gets BAD faction characters
      // Identify good vs bad factions based on scenario
      const goodFactions = [];
      const badFactions = [];
      
      // Determine good vs bad factions based on scenario type
      const currentScenarioId = scenarioData.scenarioId;
      console.log('Current scenario ID for faction assignment:', currentScenarioId);
      
      if (currentScenarioId === 'worldWar2') {
        goodFactions.push('Allied Powers');
        badFactions.push('Axis Powers');
      } else if (currentScenarioId === 'harryPotter') {
        goodFactions.push('Dumbledore\'s Army');
        badFactions.push('Death Eaters & Voldemort');
      } else if (currentScenarioId === 'starWars') {
        goodFactions.push('Rebel Alliance');
        badFactions.push('Galactic Empire');
      } else {
        // Default: first faction is good, second faction is bad
        const factionNames = Object.keys(scenario.factions);
        if (factionNames.length >= 2) {
          goodFactions.push(factionNames[0]);
          badFactions.push(factionNames[1]);
        } else {
          // Fallback to controversial character filtering
          goodFactions.push(...factionNames);
        }
      }
      
      console.log(`Good factions for students: ${goodFactions.join(', ')}`);
      console.log(`Bad factions for AI: ${badFactions.join(', ')}`);
      
      // Get characters for students (good factions only)
      const studentCharacters = allCharacters.filter(char => 
        goodFactions.includes(char.factionName) && !char.isControversial
      );
      
      // Get characters for AI (bad factions + controversial characters)
      const aiCharacters = allCharacters.filter(char => 
        badFactions.includes(char.factionName) || char.isControversial
      );
      
      console.log(`Characters for students: ${studentCharacters.length}`);
      console.log(`Characters for AI: ${aiCharacters.length}`);
      
      if (studentCharacters.length === 0) {
        console.warn('No good faction characters found for students! Using first faction...');
        const firstFaction = Object.keys(scenario.factions)[0];
        studentCharacters.push(...allCharacters.filter(char => char.factionName === firstFaction));
      }
      
      if (aiCharacters.length === 0) {
        console.warn('No bad faction characters found for AI! Using second faction...');
        const factionNames = Object.keys(scenario.factions);
        if (factionNames.length >= 2) {
          aiCharacters.push(...allCharacters.filter(char => char.factionName === factionNames[1]));
        } else {
          aiCharacters.push(...allCharacters.filter(char => char.isControversial));
        }
      }

      // Shuffle student characters
      const shuffledStudentCharacters = [...studentCharacters];
      for (let i = shuffledStudentCharacters.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffledStudentCharacters[i], shuffledStudentCharacters[j]] = [shuffledStudentCharacters[j], shuffledStudentCharacters[i]];
      }

      // Assign each student to a good faction character (round-robin if we run out)
      shuffledStudents.forEach((student, idx) => {
        const pick = shuffledStudentCharacters[idx % shuffledStudentCharacters.length];
        roleAssignments[student.gsId] = pick.name;
        // Mirror onto student for downstream team assignment
        student.characterName = pick.name;
        student.characterFaction = pick.factionName;
        console.log(`‚úÖ Assigned student ${student.name} to GOOD character ${pick.name} (${pick.factionName})`);
      });

      // Create exactly the same number of AI players as students
      // Use bad faction characters for AI
      const studentCharacterNames = Object.values(roleAssignments);
      
      console.log(`Students got ${studentCharacterNames.length} characters:`, studentCharacterNames);
      console.log(`Available AI characters: ${aiCharacters.length}`);
      
      // Shuffle AI characters
      const shuffledAICharacters = [...aiCharacters];
      for (let i = shuffledAICharacters.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffledAICharacters[i], shuffledAICharacters[j]] = [shuffledAICharacters[j], shuffledAICharacters[i]];
      }
      
      for (let i = 0; i < studentCount; i++) {
        let characterToUse;
        if (i < shuffledAICharacters.length) {
          characterToUse = shuffledAICharacters[i];
        } else {
          // If we run out of unique characters, cycle through the pool
          characterToUse = shuffledAICharacters[i % shuffledAICharacters.length];
        }
        
        const aiName = `${characterToUse.name} (AI)`;
        aiAssignments[aiName] = {
          studentId: null,
          studentName: null,
          roleName: characterToUse.name,
          factionName: characterToUse.factionName,
          isAI: true
        };
        const characterType = characterToUse.isControversial ? 'CONTROVERSIAL' : 'SAFE';
        console.log(`Created AI assignment ${i + 1}/${studentCount}: ${aiName} (${characterToUse.factionName}) - ${characterType}`);
      }

      // Persist onto scenario/state
      scenarioData.manualRoleAssignments = roleAssignments;
      scenarioData.aiAssignments = aiAssignments;
      if (!state.scenario) state.scenario = {};
      state.scenario.manualRoleAssignments = roleAssignments;
      state.scenario.aiAssignments = aiAssignments;

      console.log('Class vs AI assignments:', {
        students: Object.keys(roleAssignments).length,
        ai: Object.keys(aiAssignments).length,
        studentFactions: [...new Set(Object.values(roleAssignments).map(name => 
          shuffledStudentCharacters.find(c => c.name === name)?.factionName
        ))],
        aiFactions: [...new Set(Object.values(aiAssignments).map(ai => ai.factionName))]
      });

      // Ensure teams reflect factions
      assignTeamsFromCharacters();
    } catch (err) {
      console.error('assignClassVsAITeams error:', err);
    }
  }

  // AI Stipend Ticker System
  // Note: aiStipendInterval and aiStipendPaused are managed globally for simplicity
  // In a production app, these would be better managed in a state object

  function startAiStipendTicker() {
    if (state.aiStipendInterval) return; // Already running
    
    console.log('Starting AI stipend ticker');
    state.aiStipendInterval = setInterval(() => {
      if (state.aiStipendPaused) return; // Paused during battles
      
      tickAiStipend();
    }, 15000); // Every 15 seconds
  }

  function stopAiStipendTicker() {
    if (state.aiStipendInterval) {
      clearInterval(state.aiStipendInterval);
      state.aiStipendInterval = null;
      console.log('Stopped AI stipend ticker');
    }
  }

  function pauseAiStipendTicker() {
    state.aiStipendPaused = true;
    console.log('Paused AI stipend ticker');
  }

  function resumeAiStipendTicker() {
    state.aiStipendPaused = false;
    console.log('Resumed AI stipend ticker');
  }

  function tickAiStipend() {
    if (!state.currentRoster?.aiConfig?.classVsAI || !state.scenario?.aiAssignments) return;
    
    try {
    
    const difficulty = state.currentRoster.aiConfig.difficulty || 'medium';
    const multipliers = { easy: 0.5, medium: 1.0, hard: 1.5 };
    const multiplier = multipliers[difficulty] || 1.0;
    
    // Calculate class total earned points
    const classEarnedPoints = state.roster.reduce((sum, student) => sum + (student.earnedPoints || 0), 0);
    const aiStipend = Math.floor(classEarnedPoints * multiplier);
    
    if (aiStipend <= 0) return; // No stipend if class has no earned points
    
    // Initialize AI state if needed
    if (!state.currentRoster.aiState) {
      state.currentRoster.aiState = {
        lastTick: Date.now(),
        rollingDelta: 0,
        totalStipend: 0
      };
    }
    
    const aiState = state.currentRoster.aiState;
    const now = Date.now();
    const timeDelta = now - (aiState.lastTick || now);
    aiState.lastTick = now;
    aiState.rollingDelta = classEarnedPoints;
    aiState.totalStipend += aiStipend;
    
    // Distribute stipend to AI-controlled roles
    const aiRoles = Object.values(state.scenario.aiAssignments).filter(role => role.isAI);
    if (aiRoles.length === 0) return;
    
    const stipendPerRole = Math.floor(aiStipend / aiRoles.length);
    const remainder = aiStipend % aiRoles.length;
    
    aiRoles.forEach((role, index) => {
      let roleStipend = stipendPerRole;
      if (index < remainder) roleStipend += 1; // Distribute remainder
      
      // Find or create AI student for this role
      let aiStudent = state.roster.find(s => s.characterName === role.roleName && s.isAI);
      if (!aiStudent) {
        // Create AI student
        aiStudent = {
          gsId: `ai_${role.roleName.replace(/\s+/g, '_').toLowerCase()}`,
          name: `${role.roleName} (AI)`,
          characterName: role.roleName,
          characterFaction: role.factionName,
          isAI: true,
          startingPoints: 0,
          earnedPoints: 0,
          balance: 0,
          weapons: [],
          mercenaries: 0,
          castles: 0,
          tilesOwned: 0,
          teamId: null,
          teamName: null,
          teamColor: null
        };
        state.roster.push(aiStudent);
      }
      
      // Award stipend
      aiStudent.earnedPoints = (aiStudent.earnedPoints || 0) + roleStipend;
      aiStudent.balance = (aiStudent.startingPoints || 0) + (aiStudent.earnedPoints || 0);
    });
    
    console.log(`AI stipend tick: ${aiStipend} points distributed (${difficulty} difficulty, ${classEarnedPoints} class earned)`);
    
    // Update UI
    renderRoster();
    updateTeamScoreboards();
    
    // Persist state
    saveRosterToStorage();
    } catch (err) {
      console.error('AI stipend ticker error:', err);
    }
  }
  
  // Save roster to storage (called by AI ticker and other functions)
  async function saveRosterToStorage() {
    if (!state.currentRoster || !state.currentRosterId) return;
    
    // Update the roster data with current scores
    const updatedRoster = {
      ...state.currentRoster,
      roster: state.roster.map(student => ({
        id: student.gsId,
        name: student.name,
        startingPoints: student.startingPoints || 0,
        earnedPoints: student.earnedPoints || 0,
        points: (student.startingPoints || 0) + (student.earnedPoints || 0),
        tilesOwned: student.tilesOwned,
        teamId: student.teamId,
        teamName: student.teamName,
        teamColor: student.teamColor,
        characterName: student.characterName,
        characterRole: student.characterRole,
        characterFaction: student.characterFaction,
        isAI: student.isAI || false,
        purchasedItems: student.purchasedItems || {
          weapons: [],
          mercenaries: 0,
          allies: [],
          spells: []
        }
      })),
      scenario: state.scenario,
        aiConfig: state.currentRoster.aiConfig,
        aiState: state.currentRoster.aiState,
        territoryBonuses: Array.from(state.territoryBonuses.entries()),
        lastModified: new Date().toISOString()
    };
    
    // Update in the rosters array
    const rosterIndex = state.rosters.findIndex(r => r.id === state.currentRosterId);
    if (rosterIndex >= 0) {
      state.rosters[rosterIndex] = updatedRoster;
      state.currentRoster = updatedRoster;
      
      // Save to localStorage
      localStorage.setItem('tornadoRosters', JSON.stringify(state.rosters));
      
      // Save to Supabase if logged in (silently, no alerts)
      if (state.session && !state.offlineMode) {
        try {
          const { error } = await supabase.from('rosters').upsert({
            id: state.currentRosterId,
            teacher_id: state.session.user.id,
            name: state.currentRoster.name,
            data: updatedRoster,
            last_modified: new Date().toISOString()
          });
          if (error) {
            console.error('Supabase error in saveRosterToStorage:', error);
            // Graceful fallback if table missing
            if (error.code === 'PGRST205' || /Could not find the table 'public.rosters'/.test(error.message||'')) {
              console.warn("Supabase 'rosters' table missing. Saved locally only.");
            }
          } else {
            console.log('Roster saved to Supabase via saveRosterToStorage');
          }
        } catch (error) {
          console.error('Error saving to Supabase in saveRosterToStorage:', error);
          // Continue with local save even if Supabase fails
        }
      }
    }
  }
  // === EVENT CARDS SYSTEM ===
  function showEventCardModal() {
    if (!state.currentScenario) return;
    
    const scenarioId = state.currentScenario.scenarioId;
    const scenarioType = state.currentScenario.scenarioType;
    
    // Get available events for this scenario
    const availableEvents = EVENT_CARDS[scenarioType]?.[scenarioId] || [];
    if (availableEvents.length === 0) return;
    
    const modal = document.createElement('div');
    modal.id = 'eventCardModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background: rgba(0,0,0,0.8); z-index: 10000; display: flex; 
      align-items: center; justify-content: center;
    `;
    
    modal.innerHTML = `
      <div style="background: white; padding: 20px; border-radius: 10px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
        <h2 style="margin: 0 0 20px 0; color: #1e40af;">üé≤ Event Cards</h2>
        <div style="margin-bottom: 20px;">
          <label style="display: block; margin-bottom: 10px; font-weight: bold;">Choose an event:</label>
          <select id="eventSelect" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
            <option value="">Select an event...</option>
            ${availableEvents.map(event => `<option value="${event.id}">${event.name}</option>`).join('')}
          </select>
        </div>
        <div id="eventPreview" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; display: none;">
          <h3 id="eventName" style="margin: 0 0 10px 0; color: #dc2626;"></h3>
          <p id="eventDescription" style="margin: 0 0 15px 0;"></p>
          <div id="eventEffects" style="font-size: 14px;"></div>
        </div>
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
          <button id="randomEventBtn" style="padding: 8px 16px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">Random Event</button>
          <button id="applyEventBtn" style="padding: 8px 16px; background: #1e40af; color: white; border: none; border-radius: 4px; cursor: pointer;" disabled>Apply Event</button>
          <button id="closeEventModal" style="padding: 8px 16px; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    const eventSelect = modal.querySelector('#eventSelect');
    const eventPreview = modal.querySelector('#eventPreview');
    const eventName = modal.querySelector('#eventName');
    const eventDescription = modal.querySelector('#eventDescription');
    const eventEffects = modal.querySelector('#eventEffects');
    const randomEventBtn = modal.querySelector('#randomEventBtn');
    const applyEventBtn = modal.querySelector('#applyEventBtn');
    const closeEventModal = modal.querySelector('#closeEventModal');
    
    let selectedEvent = null;
    
    eventSelect.onchange = () => {
      const eventId = eventSelect.value;
      if (eventId) {
        selectedEvent = availableEvents.find(e => e.id === eventId);
        showEventPreview(selectedEvent);
        applyEventBtn.disabled = false;
      } else {
        eventPreview.style.display = 'none';
        applyEventBtn.disabled = true;
      }
    };
    
    randomEventBtn.onclick = () => {
      const randomEvent = availableEvents[Math.floor(Math.random() * availableEvents.length)];
      selectedEvent = randomEvent;
      eventSelect.value = randomEvent.id;
      showEventPreview(randomEvent);
      applyEventBtn.disabled = false;
    };
    
    applyEventBtn.onclick = () => {
      if (selectedEvent) {
        applyEvent(selectedEvent);
        closeEventModal.click();
      }
    };
    
    closeEventModal.onclick = () => {
      document.body.removeChild(modal);
    };
    
    function showEventPreview(event) {
      eventName.textContent = event.name;
      eventDescription.textContent = event.description;
      
      let effectsHtml = '<strong>Effects:</strong><br>';
      Object.entries(event.effects).forEach(([faction, effects]) => {
        effectsHtml += `<div style="margin: 5px 0;"><strong>${faction}:</strong> `;
        const effectList = [];
        if (effects.coins) effectList.push(`${effects.coins > 0 ? '+' : ''}${effects.coins} coins`);
        if (effects.morale) effectList.push(`${effects.morale > 0 ? '+' : ''}${effects.morale} morale`);
        if (effects.weapons) effectList.push(`${effects.weapons > 0 ? '+' : ''}${effects.weapons} weapons`);
        if (effects.mercenaries) effectList.push(`${effects.mercenaries > 0 ? '+' : ''}${effects.mercenaries} mercenaries`);
        if (effects.defense) effectList.push(`${effects.defense > 0 ? '+' : ''}${effects.defense} defense`);
        if (effects.training) effectList.push(`${effects.training > 0 ? '+' : ''}${effects.training} training`);
        effectsHtml += effectList.join(', ') + '</div>';
      });
      effectsHtml += `<div style="margin-top: 10px;"><strong>Duration:</strong> ${event.duration} turns</div>`;
      
      eventEffects.innerHTML = effectsHtml;
      eventPreview.style.display = 'block';
    }
  }
  
  function applyEvent(event) {
    // Add event to active events
    const eventWithId = {
      ...event,
      id: event.id + '_' + Date.now(),
      startTurn: getCurrentTurn(),
      endTurn: getCurrentTurn() + event.duration
    };
    
    state.activeEvents.push(eventWithId);
    state.eventHistory.push({
      ...event,
      appliedAt: new Date().toISOString(),
      turn: getCurrentTurn()
    });
    
    // Apply immediate effects
    applyEventEffects(event);
    
    // Show notification
    showEventNotification(event);
    
    // Save state
    saveRosterToStorage();
    
    // Update UI
    renderRoster();
    updateTeamScoreboards();
  }
  
  function applyEventEffects(event) {
    Object.entries(event.effects).forEach(([faction, effects]) => {
      const factionStudents = state.roster.filter(student => 
        student.characterFaction === faction || 
        (faction === 'patriots' && student.characterFaction === 'Patriots') ||
        (faction === 'british' && student.characterFaction === 'British') ||
        (faction === 'allies' && student.characterFaction === 'Allied Powers') ||
        (faction === 'central' && student.characterFaction === 'Central Powers') ||
        (faction === 'axis' && student.characterFaction === 'Axis Powers') ||
        (faction === 'justice' && student.characterFaction === 'Defenders of Justice') ||
        (faction === 'prejudice' && student.characterFaction === 'Forces of Prejudice') ||
        (faction === 'dreamers' && student.characterFaction === 'Dreamers & Romantics') ||
        (faction === 'reality' && student.characterFaction === 'Forces of Reality') ||
        (faction === 'truth' && student.characterFaction === 'Defenders of Truth') ||
        (faction === 'hysteria' && student.characterFaction === 'Forces of Hysteria')
      );
      
      factionStudents.forEach(student => {
        if (effects.coins) {
          student.balance = Math.max(0, student.balance + effects.coins);
          student.earnedPoints = Math.max(0, (student.earnedPoints || 0) + effects.coins);
        }
        if (effects.weapons) {
          if (!student.purchasedItems) student.purchasedItems = { weapons: [], mercenaries: 0, allies: [], spells: [] };
          for (let i = 0; i < Math.abs(effects.weapons); i++) {
            if (effects.weapons > 0) {
              student.purchasedItems.weapons.push('event_weapon');
            } else {
              student.purchasedItems.weapons.pop();
            }
          }
        }
        if (effects.mercenaries) {
          if (!student.purchasedItems) student.purchasedItems = { weapons: [], mercenaries: 0, allies: [], spells: [] };
          student.purchasedItems.mercenaries = Math.max(0, (student.purchasedItems.mercenaries || 0) + effects.mercenaries);
        }
      });
    });
  }
  
  function getCurrentTurn() {
    // Simple turn counter - could be enhanced with actual game turn tracking
    return Math.floor(Date.now() / 30000); // Approximate turn based on time
  }
  
  function showEventNotification(event) {
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed; top: 20px; right: 20px; background: #1e40af; color: white; 
      padding: 15px 20px; border-radius: 8px; z-index: 10001; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.3); max-width: 300px;
    `;
    notification.innerHTML = `
      <div style="font-weight: bold; margin-bottom: 5px;">üé≤ ${event.name}</div>
      <div style="font-size: 14px;">${event.description}</div>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
      if (document.body.contains(notification)) {
        document.body.removeChild(notification);
      }
    }, 5000);
  }
  
  function processActiveEvents() {
    const currentTurn = getCurrentTurn();
    const expiredEvents = [];
    
    state.activeEvents.forEach(event => {
      if (currentTurn >= event.endTurn) {
        expiredEvents.push(event);
      }
    });
    
    // Remove expired events
    state.activeEvents = state.activeEvents.filter(event => !expiredEvents.includes(event));
    
    // Show expiration notifications
    expiredEvents.forEach(event => {
      showEventNotification({
        name: `${event.name} (Expired)`,
        description: 'This event has ended.'
      });
    });
  }

  // === TERRITORY BONUSES SYSTEM ===
  function initializeTerritoryBonuses() {
    if (!state.currentScenario) return;
    
    const scenario = SCENARIOS[state.currentScenario.scenarioId];
    if (!scenario || !scenario.neutralTerritories) return;
    
    // Clear existing bonuses
    state.territoryBonuses.clear();
    
    // Create bonus territories in the middle of the board
    const centerX = Math.floor(state.board.w / 2);
    const centerY = Math.floor(state.board.h / 2);
    
    scenario.neutralTerritories.forEach((territory, index) => {
      const bonusId = `bonus_${territory.name.toLowerCase().replace(/\s+/g, '_')}`;
      const x = centerX + (index % 3) - 1;
      const y = centerY + Math.floor(index / 3) - 1;
      
      // Ensure coordinates are within bounds
      const finalX = Math.max(0, Math.min(state.board.w - 1, x));
      const finalY = Math.max(0, Math.min(state.board.h - 1, y));
      
      state.territoryBonuses.set(bonusId, {
        id: bonusId,
        name: territory.name,
        description: territory.description,
        cost: territory.cost,
        x: finalX,
        y: finalY,
        bonusType: getRandomBonusType(),
        bonusValue: getRandomBonusValue(),
        controlledBy: null,
        lastClaimed: null
      });
    });
  }
  
  function getRandomBonusType() {
    const types = ['weapons', 'mercenaries', 'castles', 'coins'];
    return types[Math.floor(Math.random() * types.length)];
  }
  
  function getRandomBonusValue() {
    return Math.floor(Math.random() * 3) + 1; // 1-3 bonus value
  }
  
  function claimTerritoryBonus(territoryId, studentId) {
    const bonus = state.territoryBonuses.get(territoryId);
    if (!bonus || bonus.controlledBy) return false;
    
    const student = state.roster.find(s => s.gsId === studentId);
    if (!student) return false;
    
    // Check if student has enough points to claim
    if (student.balance < bonus.cost) return false;
    
    // Deduct cost
    student.balance -= bonus.cost;
    student.earnedPoints = Math.max(0, (student.earnedPoints || 0) - bonus.cost);
    
    // Apply bonus
    applyTerritoryBonus(bonus, student);
    
    // Mark as controlled
    bonus.controlledBy = studentId;
    bonus.lastClaimed = new Date().toISOString();
    
    // Show notification
    showTerritoryBonusNotification(bonus, student);
    
    // Save state
    saveRosterToStorage();
    
    // Update UI
    renderRoster();
    updateTeamScoreboards();
    
    return true;
  }
  
  function applyTerritoryBonus(bonus, student) {
    if (!student.purchasedItems) {
      student.purchasedItems = { weapons: [], mercenaries: 0, allies: [], spells: [] };
    }
    
    switch (bonus.bonusType) {
      case 'weapons':
        for (let i = 0; i < bonus.bonusValue; i++) {
          student.purchasedItems.weapons.push(`bonus_weapon_${bonus.id}`);
        }
        break;
      case 'mercenaries':
        student.purchasedItems.mercenaries += bonus.bonusValue;
        break;
      case 'castles':
        student.castles = (student.castles || 0) + bonus.bonusValue;
        break;
      case 'coins':
        student.balance += bonus.bonusValue * 10; // 10 coins per bonus value
        student.earnedPoints = (student.earnedPoints || 0) + (bonus.bonusValue * 10);
        break;
    }
  }
  
  function showTerritoryBonusNotification(bonus, student) {
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed; top: 20px; left: 20px; background: #10b981; color: white; 
      padding: 15px 20px; border-radius: 8px; z-index: 10001; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.3); max-width: 300px;
    `;
    notification.innerHTML = `
      <div style="font-weight: bold; margin-bottom: 5px;">üè∞ ${bonus.name} Claimed!</div>
      <div style="font-size: 14px;">${student.name} gained ${bonus.bonusValue} ${bonus.bonusType}!</div>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
      if (document.body.contains(notification)) {
        document.body.removeChild(notification);
      }
    }, 4000);
  }
  
  function renderTerritoryBonuses() {
    // Remove existing bonus indicators
    document.querySelectorAll('.territory-bonus').forEach(el => el.remove());
    
    state.territoryBonuses.forEach(bonus => {
      if (bonus.controlledBy) return; // Skip controlled territories
      
      const indicator = document.createElement('div');
      indicator.className = 'territory-bonus';
      indicator.style.cssText = `
        position: absolute;
        left: ${bonus.x * 40 + 20}px;
        top: ${bonus.y * 40 + 20}px;
        width: 20px;
        height: 20px;
        background: #fbbf24;
        border: 2px solid #f59e0b;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        cursor: pointer;
        z-index: 1000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      `;
      
      // Set appropriate icon based on bonus type
      const icons = {
        weapons: '‚öîÔ∏è',
        mercenaries: 'üë•',
        castles: 'üè∞',
        coins: 'üí∞'
      };
      indicator.textContent = icons[bonus.bonusType] || 'üéÅ';
      indicator.title = `${bonus.name}\nCost: ${bonus.cost} points\nBonus: ${bonus.bonusValue} ${bonus.bonusType}`;
      
      indicator.onclick = (e) => {
        e.stopPropagation();
        if (state.selectedGsId) {
          claimTerritoryBonus(bonus.id, state.selectedGsId);
        } else {
          alert('Please select a student first!');
        }
      };
      
      document.getElementById('board').appendChild(indicator);
    });
  }
  
  // Initialize scenario data
  function assignRandomCharacters(scenarioData) {
    console.log('Assigning random characters to students');
    
    // Get all available characters from all factions, prioritizing main characters
    const allCharacters = [];
    const mainCharacters = [];
    const otherCharacters = [];
    
    Object.values(scenarioData.factions).forEach(faction => {
      if (faction.characters) {
        faction.characters.forEach(char => {
          const characterData = {
            ...char,
            factionName: faction.name,
            factionColor: faction.color
          };
          
          // Prioritize main characters for Harry Potter scenario
          if (scenarioData.scenarioName.includes('Harry Potter')) {
            const mainCharacterNames = ['Harry Potter', 'Ron Weasley', 'Hermione Granger', 'Albus Dumbledore', 'Lord Voldemort', 'Bellatrix Lestrange', 'Lucius Malfoy', 'Severus Snape'];
            if (mainCharacterNames.includes(char.name)) {
              mainCharacters.push(characterData);
            } else {
              otherCharacters.push(characterData);
            }
          } else {
            // For other scenarios, prioritize characters with higher starting resources
            if (char.startingCoins >= 100 || char.startingCastles >= 1) {
              mainCharacters.push(characterData);
            } else {
              otherCharacters.push(characterData);
            }
          }
        });
      }
      if (faction.generalRoles) {
        faction.generalRoles.forEach(role => {
          otherCharacters.push({
            name: role.name,
            role: role.name,
            startingCoins: role.startingCoins,
            startingWeapons: role.startingWeapons,
            startingMercenaries: role.startingMercenaries,
            startingCastles: role.startingCastles,
            personality: role.personality,
            quotes: role.quotes,
            history: `${role.name} in ${faction.name}`,
            factionName: faction.name,
            factionColor: faction.color
          });
        });
      }
    });
    
    // Combine: main characters first, then others
    allCharacters.push(...mainCharacters, ...otherCharacters);
    
    // Shuffle only the non-main characters to keep main characters prioritized
    for (let i = mainCharacters.length; i < allCharacters.length - 1; i++) {
      const j = mainCharacters.length + Math.floor(Math.random() * (allCharacters.length - mainCharacters.length));
      [allCharacters[i], allCharacters[j]] = [allCharacters[j], allCharacters[i]];
    }
    
    // Assign characters to students - ensure balanced teams
    const roleAssignments = {};
    
    // Group characters by faction for balanced assignment
    const charactersByFaction = {};
    allCharacters.forEach(char => {
      if (!charactersByFaction[char.factionName]) {
        charactersByFaction[char.factionName] = [];
      }
      charactersByFaction[char.factionName].push(char);
    });
    
    const factionNames = Object.keys(charactersByFaction);
    const factionCounts = {};
    factionNames.forEach(faction => {
      factionCounts[faction] = 0;
    });
    
    // Assign characters to students with perfectly balanced faction distribution
    const totalStudents = state.roster.length;
    const numFactions = factionNames.length;
    
    // Calculate how many students each faction should get
    const studentsPerFaction = Math.floor(totalStudents / numFactions);
    const extraStudents = totalStudents % numFactions;
    
    // Create a balanced assignment array
    const factionAssignments = [];
    factionNames.forEach((factionName, factionIndex) => {
      const studentsForThisFaction = studentsPerFaction + (factionIndex < extraStudents ? 1 : 0);
      for (let i = 0; i < studentsForThisFaction; i++) {
        factionAssignments.push(factionName);
      }
    });
    
    // Shuffle the assignments to randomize which students get which factions
    for (let i = factionAssignments.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [factionAssignments[i], factionAssignments[j]] = [factionAssignments[j], factionAssignments[i]];
    }
    
    // Shuffle students array to ensure true randomization
    const shuffledStudents = [...state.roster];
    for (let i = shuffledStudents.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffledStudents[i], shuffledStudents[j]] = [shuffledStudents[j], shuffledStudents[i]];
    }

    shuffledStudents.forEach((student, index) => {
      // Get the pre-calculated faction assignment
      const targetFaction = factionAssignments[index];
      const factionCharacters = charactersByFaction[targetFaction];
      const characterIndex = factionCounts[targetFaction] % factionCharacters.length;
      const character = factionCharacters[characterIndex];
      
      factionCounts[targetFaction]++;
      
      student.characterName = character.name;
      student.characterRole = character.role;
      student.characterFaction = character.factionName;
      
      // Apply character starting resources
      student.startingPoints = character.startingCoins || student.startingPoints || 10;
      student.earnedPoints = student.earnedPoints || 0;
      student.balance = (student.startingPoints || 0) + (student.earnedPoints || 0);
      student.weapons = character.startingWeapons || [];
      student.mercenaries = character.startingMercenaries || 0;
      student.startingCastles = character.startingCastles || 0;
      
      // Assign team based on character faction - use dynamic assignment
      const faction = Object.values(scenarioData.factions).find(f => f.name === character.factionName);
      if (faction) {
        // Use faction key as team ID and faction color as team color
        const factionKey = Object.keys(scenarioData.factions).find(key => scenarioData.factions[key] === faction);
        student.teamId = factionKey;
        student.teamName = faction.name;
        student.teamColor = faction.color;
      } else {
        // Fallback for general roles - assign based on scenario type
        if (scenarioData.scenarioName.includes('Harry Potter')) {
          if (character.name === 'Hogwarts Student' || character.name === 'Order Member' || character.name === 'Muggle-born') {
            student.teamId = 'good_guys';
            student.teamName = 'Dumbledore\'s Army';
            student.teamColor = '#dc143c'; // Gryffindor red for Dumbledore's Army
          } else if (character.name === 'Death Eater' || character.name === 'Snatcher' || character.name === 'Inferi') {
            student.teamId = 'bad_guys';
            student.teamName = 'Voldemort\'s Army';
            student.teamColor = '#2e8b57'; // Slytherin green for Voldemort's Army
          }
        } else if (scenarioData.scenarioName.includes('Star Wars')) {
          if (character.name === 'Rebel Soldier' || character.name === 'Rebel Pilot') {
            student.teamId = 'rebels';
            student.teamName = 'Rebel Alliance';
            student.teamColor = '#4169e1'; // Blue for rebels
          } else if (character.name === 'Stormtrooper' || character.name === 'Imperial Officer') {
            student.teamId = 'empire';
            student.teamName = 'Galactic Empire';
            student.teamColor = '#8b0000'; // Dark red for empire
          } else if (character.name === 'Smuggler' || character.name === 'Bounty Hunter') {
            student.teamId = 'neutral';
            student.teamName = 'Neutral/Independent';
            student.teamColor = '#808080'; // Gray for neutral
          }
        }
      }
      
      roleAssignments[student.gsId] = character.name;
      console.log(`Assigned ${character.name} to ${student.name} (${student.teamName}) with ${character.startingCoins} coins, ${character.startingWeapons?.length || 0} weapons, ${character.startingMercenaries || 0} mercenaries, ${character.startingCastles || 0} castles`);
    });
    
    // Log team balance
    const teamBalance = {};
    state.roster.forEach(student => {
      if (student.teamName) {
        teamBalance[student.teamName] = (teamBalance[student.teamName] || 0) + 1;
      }
    });
    console.log('Team balance:', teamBalance);
    
    // Place starting castles for characters who have them
    if (state.board && state.board.tiles) {
      placeStartingCastles();
    }
    
    // Store assignments in scenario data
    scenarioData.manualRoleAssignments = roleAssignments;
    state.scenario.manualRoleAssignments = roleAssignments;
    
    console.log('Character assignments completed:', roleAssignments);
  }
  function initializeScenario(scenarioData) {
    console.log('Initializing scenario:', scenarioData);
    
    // Store scenario data in state
    state.scenario = scenarioData;
    // Economy overrides per scenario; load from roster if saved
    state.economy = (state.currentRoster && state.currentRoster.economy) ? state.currentRoster.economy : { ...ECONOMY };
    
    // Update game theme title
    updateGameThemeTitle();
    const id = scenarioData.scenarioId || scenarioData.id;
    if (id === 'harryPotter') {
      // Slight discount for spells theme; keep core prices
      state.economy.weapons = { spear: 40, crossbow: 80, catapult: 140 };
      state.economy.mercCost = 15;
    } else if (id === 'starWars') {
      // Tech pricier weapons
      state.economy.weapons = { spear: 50, crossbow: 90, catapult: 160 };
    }
    // Sync active economy reference used before state exists
    __activeEconomy = state.economy;
    applyEconomyToUI();
    
    // Auto-assign characters
    if (scenarioData.enableAI) {
      console.log('AI enabled, checking for class vs AI assignment...');
      // Class vs AI: only assign if nothing is already assigned (respect manual modal results)
      if (!scenarioData.manualRoleAssignments) {
        console.log('No manual assignments found, calling assignClassVsAITeams...');
        try {
          assignClassVsAITeams(scenarioData);
          console.log('assignClassVsAITeams completed successfully');
        } catch (error) {
          console.error('assignClassVsAITeams failed:', error);
          alert('Failed to set up AI vs Students game. Please try again.');
          return; // Don't proceed if AI setup fails
        }
      } else {
        console.log('Manual assignments already exist, skipping auto-assignment');
      }
    } else {
      console.log('AI not enabled, checking for random assignment...');
      // Random assignment if requested and no manual assignments
      if (scenarioData.randomAssignment && !scenarioData.manualRoleAssignments) {
        console.log('Random assignment requested, calling assignRandomCharacters...');
        assignRandomCharacters(scenarioData);
      }
    }
    
    // Always assign teams based on character factions
    assignTeamsFromCharacters();
    
    // Initialize AI if enabled
    if (scenarioData.enableAI && typeof initializeAIForScenario === 'function') {
      setTimeout(() => {
        initializeAIForScenario();
      }, 100);
    }
    
    // Start AI stipend ticker if Class vs AI is enabled
    if (state.currentRoster?.aiConfig?.classVsAI) {
      startAiStipendTicker();
    }

    // Initialize territory bonuses
    initializeTerritoryBonuses();
    
    // Initialize educational content if available
    if (typeof initializeEducationalContent === 'function') {
      setTimeout(() => {
        initializeEducationalContent();
      }, 100);
    }
    
    // Show AI controls if AI is enabled
    const aiControls = document.getElementById('aiControls');
    if (aiControls && scenarioData.enableAI) {
      aiControls.style.display = 'block';
    }
    
    // Show educational controls
    const educationalControls = document.getElementById('educationalControls');
    if (educationalControls) {
      educationalControls.style.display = 'block';
    }
    
    // Initialize Story Events for this scenario
    initializeStoryEvents(scenarioData.scenarioId || scenarioData.id);
    
    // Final render of roster to ensure AI players are displayed
    console.log('initializeScenario: Final renderRoster call');
    console.log('initializeScenario: state.aiPlayers =', state.aiPlayers);
    console.log('initializeScenario: state.aiPlayers length =', state.aiPlayers?.length || 0);
    renderRoster();
  }
  
  function initializeGameBoard() {
    console.log('initializeGameBoard called', { currentRoster: state.currentRoster, roster: state.roster });
    
    if (!state.currentRoster) {
      console.log('No current roster, returning');
      return;
    }
    
    // Try to load saved game state first
    if (state.currentRoster.gameState && state.currentRoster.gameState.board) {
      console.log('Loading saved game state');
      state.board = state.currentRoster.gameState.board;
      state.truces = state.currentRoster.gameState.truces || [];
      
      // Remap old student IDs to current ones
      if (state.board.tiles) {
        state.board.tiles.forEach(tile => {
          if (tile.owner_game_student_id) {
            // Try to find by gsId first, then by id, then by name
            const savedStudent = state.currentRoster.roster.find(s => 
              s.gsId === tile.owner_game_student_id || 
              s.id === tile.owner_game_student_id
            );
            if (savedStudent) {
              const currentStudent = state.roster.find(r => 
                r.gsId === savedStudent.gsId || 
                r.name === savedStudent.name
              );
              if (currentStudent) {
                tile.owner_game_student_id = currentStudent.gsId;
                console.log(`Remapped tile (${tile.x}, ${tile.y}) from ${savedStudent.name} to ${currentStudent.name}`);
              }
            }
          }
        });
      }
      
      console.log('Loaded saved board:', { board: state.board, tilesCount: state.board.tiles.length });
    } else {
      // Create fresh board if no saved state
      console.log('No saved game state, creating fresh board');
    const studentCount = state.roster.length;
    const w = Math.max(8, Math.ceil(Math.sqrt(studentCount * 2)));
    const h = Math.max(8, Math.ceil(Math.sqrt(studentCount * 2)));
    
    console.log('Calculated board size:', { studentCount, w, h });
    
      // Create fresh tiles
      const tiles = [];
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          tiles.push({
            id: `tile_${x}_${y}`,
            x: x,
            y: y,
            owner_game_student_id: null,
            castle_level: 0
          });
        }
      }
      state.board = { w, h, tiles };
      state.truces = [];
      
      // Assign starting tiles to students (2 tiles each on outer edges)
      assignStartingTiles();
      
      // Place starting castles for characters who have them
      placeStartingCastles();
      
      console.log('Created fresh board:', { board: state.board, tilesCount: state.board.tiles.length });
    }
    
    // Sync tile counts with actual board state
    syncTileCounts();
    
    // Update grid display
    updateGridDisplay();
  }
  
  function resetGameToDefaults() {
    if (!state.currentRoster || !state.roster) {
      alert('No roster loaded to reset.');
      return;
    }

    console.log('Resetting game to defaults for roster:', state.currentRoster.name);

    // Reset all students to default state
    state.roster.forEach(student => {
      student.tilesOwned = 0;
      student.balance = 10; // Default starting balance - enough for a mercenary
      student.weapons = [];
      student.mercenaries = 0;
      student.wizard = false;
      student.tornados = 0;
    });

    // Clear all truces
    state.truces = [];
    state.truceInvitations = [];

    // Reset board to fresh state
    const studentCount = state.roster.length;
    const w = Math.max(8, Math.ceil(Math.sqrt(studentCount * 2)));
    const h = Math.max(8, Math.ceil(Math.sqrt(studentCount * 2)));

    // Create fresh tiles
    const tiles = [];
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        tiles.push({
          id: `tile_${x}_${y}`,
          x: x,
          y: y,
          owner_game_student_id: null,
          castle_level: 0
        });
      }
    }
    state.board = { w, h, tiles };

    // Assign starting tiles to students
    assignStartingTiles();
    
    // Place starting castles for characters who have them
    placeStartingCastles();

    // Clear saved game state from roster
    if (state.currentRoster.gameState) {
      delete state.currentRoster.gameState;
    }

    // Update UI
    updateGridDisplay();
    renderRoster();
    updateVictoryTarget();
    updateTeamScoreboards();

    // Save the reset state
    autoSaveWarPoints();

    alert('Game reset successfully! All students start fresh with 10 coins and new starting territories.');
  }

  // Helper function to determine if a team is "good guys" based on scenario
  function isGoodGuyTeam(teamId, scenario) {
    if (!scenario || !scenario.scenarioId) return false;
    
    const scenarioData = SCENARIOS[scenario.scenarioId];
    if (!scenarioData || !scenarioData.factions) return false;
    
    const faction = scenarioData.factions[teamId];
    if (!faction) return false;
    
    // Only define good guy factions for scenarios with clear good vs bad dynamics
    const goodGuyFactions = {
      'americanRevolution': ['patriots'],
      'civilWar': ['union'],
      'starWars': ['rebels'],
      'harryPotter': ['good_guys'],
      'lordOfTheRings': ['fellowship'],
      'avengers': ['avengers'],
      'superMario': ['marioHeroes'],
      'worldWar1': ['alliedPowers'],
      'worldWar2': ['allies'],
      'disneyVsPixar': ['disney']
    };
    
    const goodGuys = goodGuyFactions[scenario.scenarioId] || [];
    return goodGuys.includes(teamId);
  }

  function assignStartingTiles() {
    if (!state.roster || state.roster.length === 0) return;
    
    console.log('Assigning starting tiles to', state.roster.length, 'students');
    
    const { w, h } = state.board;
    
    // Check if this is an AI vs Students game
    const isAIVsStudents = state.aiPlayers && state.aiPlayers.length > 0;
    
    let teamGroups = {};
    
    if (isAIVsStudents) {
      // AI vs Students: Separate AI teams from student teams
      const aiTeams = {};
      const studentTeams = {};
      
      // Process students from roster
      state.roster.forEach(student => {
        const teamId = student.teamId || 'individual';
        if (student.isAI) {
          if (!aiTeams[teamId]) {
            aiTeams[teamId] = [];
          }
          aiTeams[teamId].push(student);
        } else {
          if (!studentTeams[teamId]) {
            studentTeams[teamId] = [];
          }
          studentTeams[teamId].push(student);
        }
      });
      
      // Process AI players from separate array
      if (state.aiPlayers) {
        state.aiPlayers.forEach(aiPlayer => {
          const teamId = aiPlayer.teamId || 'individual';
          if (!aiTeams[teamId]) {
            aiTeams[teamId] = [];
          }
          aiTeams[teamId].push(aiPlayer);
        });
      }
      
      // Combine teams with AI teams first, then student teams
      teamGroups = { ...aiTeams, ...studentTeams };
    } else {
      // Regular game: Just group all students by team
      state.roster.forEach(student => {
        const teamId = student.teamId || 'individual';
        if (!teamGroups[teamId]) {
          teamGroups[teamId] = [];
        }
        teamGroups[teamId].push(student);
      });
    }
    
    console.log('Is AI vs Students:', isAIVsStudents);
    console.log('Team groups:', teamGroups);
    
    // Create strategic starting positions based on team count
    const team1Positions = []; // Team 1 positions
    const team2Positions = []; // Team 2 positions  
    const team3Positions = []; // Team 3 positions
    const team4Positions = []; // Team 4 positions
    
    const teamCount = Object.keys(teamGroups).length;
    
    if (teamCount === 4) {
      // 4-team scenario: Corner formation - each team gets their own corner
      // Team 1: Top-left corner
      for (let y = 0; y < Math.floor(h / 2); y++) {
        for (let x = 0; x < Math.floor(w / 2); x++) {
          team1Positions.push({ x, y });
        }
      }
      
      // Team 2: Top-right corner
      for (let y = 0; y < Math.floor(h / 2); y++) {
        for (let x = Math.floor(w / 2); x < w; x++) {
          team2Positions.push({ x, y });
        }
      }
      
      // Team 3: Bottom-left corner
      for (let y = Math.floor(h / 2); y < h; y++) {
        for (let x = 0; x < Math.floor(w / 2); x++) {
          team3Positions.push({ x, y });
        }
      }
      
      // Team 4: Bottom-right corner
      for (let y = Math.floor(h / 2); y < h; y++) {
        for (let x = Math.floor(w / 2); x < w; x++) {
          team4Positions.push({ x, y });
        }
      }
    } else if (teamCount === 3) {
      // 3-team scenario: Triangle formation
      // Team 1: Top center (upper half, center area)
      for (let y = 0; y < Math.floor(h / 2); y++) {
        for (let x = Math.floor(w / 4); x < Math.floor(3 * w / 4); x++) {
          team1Positions.push({ x, y });
        }
      }
      
      // Team 2: Bottom-left corner
      for (let y = Math.floor(h / 2); y < h; y++) {
        for (let x = 0; x < Math.floor(w / 2); x++) {
          team2Positions.push({ x, y });
        }
      }
      
      // Team 3: Bottom-right corner
      for (let y = Math.floor(h / 2); y < h; y++) {
        for (let x = Math.floor(w / 2); x < w; x++) {
          team3Positions.push({ x, y });
        }
      }
    } else if (teamCount === 1) {
      // Individual players: Spread around the edges of the board
      const edgePositions = [];
      
      // Top edge
      for (let x = 0; x < w; x++) {
        edgePositions.push({ x, y: 0 });
      }
      
      // Bottom edge  
      for (let x = 0; x < w; x++) {
        edgePositions.push({ x, y: h - 1 });
      }
      
      // Left edge (excluding corners already covered)
      for (let y = 1; y < h - 1; y++) {
        edgePositions.push({ x: 0, y });
      }
      
      // Right edge (excluding corners already covered)
      for (let y = 1; y < h - 1; y++) {
        edgePositions.push({ x: w - 1, y });
      }
      
      // Shuffle edge positions for random distribution
      for (let i = edgePositions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [edgePositions[i], edgePositions[j]] = [edgePositions[j], edgePositions[i]];
      }
      
      // Assign edge positions to team1Positions for individual players
      team1Positions.push(...edgePositions);
    } else {
      // 2-team scenario: MAXIMUM separation - far left vs far right
      // Team 1 gets far left (first 1/3 of map)
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < Math.floor(w / 3); x++) {
          team1Positions.push({ x, y });
        }
      }
      
      // Team 2 gets far right (last 1/3 of map)
      for (let y = 0; y < h; y++) {
        for (let x = Math.floor(2 * w / 3); x < w; x++) {
          team2Positions.push({ x, y });
        }
      }
      
      // Middle 1/3 remains neutral territory
    }
    
    // Sort positions by distance from center for better strategic placement
    const centerX = (w - 1) / 2;
    const centerY = (h - 1) / 2;
    
    team1Positions.sort((a, b) => {
      const distA = Math.sqrt(Math.pow(a.x - centerX, 2) + Math.pow(a.y - centerY, 2));
      const distB = Math.sqrt(Math.pow(b.x - centerX, 2) + Math.pow(b.y - centerY, 2));
      return distB - distA; // Furthest from center first
    });
    
    team2Positions.sort((a, b) => {
      const distA = Math.sqrt(Math.pow(a.x - centerX, 2) + Math.pow(a.y - centerY, 2));
      const distB = Math.sqrt(Math.pow(b.x - centerX, 2) + Math.pow(b.y - centerY, 2));
      return distB - distA; // Furthest from center first
    });
    
    team3Positions.sort((a, b) => {
      const distA = Math.sqrt(Math.pow(a.x - centerX, 2) + Math.pow(a.y - centerY, 2));
      const distB = Math.sqrt(Math.pow(b.x - centerX, 2) + Math.pow(b.y - centerY, 2));
      return distB - distA; // Furthest from center first
    });
    
    team4Positions.sort((a, b) => {
      const distA = Math.sqrt(Math.pow(a.x - centerX, 2) + Math.pow(a.y - centerY, 2));
      const distB = Math.sqrt(Math.pow(b.x - centerX, 2) + Math.pow(b.y - centerY, 2));
      return distB - distA; // Furthest from center first
    });
    
    // Assign starting positions to teams
    const teamIds = Object.keys(teamGroups);

    // If a scenario defines factions, map faction IDs to board regions deterministically
    // so, for 2-faction scenarios: faction[0] = left, faction[1] = right; for 3/4 factions: TL, TR, BL, BR
    // Allow scenarios to specify explicit faction ordering via scenario.factionOrder
    const scenarioFactionKeys = state.scenario && state.scenario.factions ? (
      Array.isArray(state.scenario.factionOrder) && state.scenario.factionOrder.length > 0
        ? state.scenario.factionOrder.filter(fid => state.scenario.factions[fid])
        : Object.keys(state.scenario.factions)
    ) : [];
    const positionsByTeamId = {};
    if (scenarioFactionKeys.length > 0) {
      if (teamCount === 2) {
        if (scenarioFactionKeys[0]) positionsByTeamId[scenarioFactionKeys[0]] = team1Positions; // left
        if (scenarioFactionKeys[1]) positionsByTeamId[scenarioFactionKeys[1]] = team2Positions; // right
      } else if (teamCount === 3) {
        if (scenarioFactionKeys[0]) positionsByTeamId[scenarioFactionKeys[0]] = team1Positions; // top center
        if (scenarioFactionKeys[1]) positionsByTeamId[scenarioFactionKeys[1]] = team2Positions; // bottom-left
        if (scenarioFactionKeys[2]) positionsByTeamId[scenarioFactionKeys[2]] = team3Positions; // bottom-right
      } else if (teamCount === 4) {
        if (scenarioFactionKeys[0]) positionsByTeamId[scenarioFactionKeys[0]] = team1Positions; // TL
        if (scenarioFactionKeys[1]) positionsByTeamId[scenarioFactionKeys[1]] = team2Positions; // TR
        if (scenarioFactionKeys[2]) positionsByTeamId[scenarioFactionKeys[2]] = team3Positions; // BL
        if (scenarioFactionKeys[3]) positionsByTeamId[scenarioFactionKeys[3]] = team4Positions; // BR
      }
    }

    // Prepare a mapping of board regions -> actual team ids (filled during assignment loop)
    // We populate this based on where teams are actually placed, not on assumed order
    state.regionFactionMap = { 0: null, 2: null };
    
    Object.entries(teamGroups).forEach(([teamId, students], index) => {
      console.log(`Assigning positions for team ${teamId} with ${students.length} students`);
      
      // Choose positions based on scenario mapping first; otherwise fall back to formation rules
      let teamPositions = positionsByTeamId[teamId] || [];
      
      // Determine if this is an AI team or student team (only for AI vs Students games)
      let isAITeam = false;
      let isStudentTeam = false;
      
      if (isAIVsStudents) {
        // For AI vs Students games, check if this team has AI players
        isAITeam = students.some(s => s.isAI || (state.aiPlayers && state.aiPlayers.some(ai => ai.gsId === s.gsId)));
        isStudentTeam = !isAITeam;
      }
      
      // Determine which team is "good guys" based on scenario
      const currentTeamId = teamIds[index];
      const isGoodGuys = isGoodGuyTeam(currentTeamId, state.scenario);
      
      // Check if this scenario has a clear good vs bad dynamic
      const hasGoodBadDynamic = state.scenario && ['americanRevolution', 'civilWar', 'starWars', 'harryPotter', 'lordOfTheRings', 'avengers', 'superMario', 'worldWar1', 'worldWar2', 'disneyVsPixar'].includes(state.scenario.scenarioId);
      
      // AI vs Students positioning: AI teams on left, Student teams on right (unless scenario mapping already set)
      if (teamPositions.length === 0 && isAITeam) {
        // AI teams get left side positions (regardless of faction)
        if (teamCount === 4) {
          // AI gets left side (top-left or bottom-left)
          if (index === 0) teamPositions = team1Positions; // Top-left
          else if (index === 2) teamPositions = team3Positions; // Bottom-left
        } else if (teamCount === 3) {
          teamPositions = team1Positions; // Top center (left side)
        } else {
          teamPositions = team1Positions; // Left side
        }
        console.log(`AI team ${teamId} assigned to LEFT side positions`);
      } else if (teamPositions.length === 0 && isStudentTeam) {
        // Student teams get right side positions (regardless of faction)
        if (teamCount === 4) {
          // Students get right side (top-right or bottom-right)
          if (index === 1) teamPositions = team2Positions; // Top-right
          else if (index === 3) teamPositions = team4Positions; // Bottom-right
        } else if (teamCount === 3) {
          // Students get bottom corners (right side)
          if (index === 1) teamPositions = team2Positions; // Bottom-left
          else if (index === 2) teamPositions = team3Positions; // Bottom-right
        } else {
          teamPositions = team2Positions; // Right side
        }
        console.log(`Student team ${teamId} assigned to RIGHT side positions`);
      } else {
        // Fallback for individual players - use standard positioning
        if (teamPositions.length === 0 && teamCount === 4) {
          if (index === 0) teamPositions = team1Positions; // Top-left
          else if (index === 1) teamPositions = team2Positions; // Top-right
          else if (index === 2) teamPositions = team3Positions; // Bottom-left
          else if (index === 3) teamPositions = team4Positions; // Bottom-right
        } else if (teamPositions.length === 0 && teamCount === 3) {
          if (index === 0) teamPositions = team1Positions; // Top center
          else if (index === 1) teamPositions = team2Positions; // Bottom-left
          else if (index === 2) teamPositions = team3Positions; // Bottom-right
        } else if (teamPositions.length === 0 && teamCount === 1) {
          // Individual players: all use team1Positions (edge positions)
          teamPositions = team1Positions;
        } else if (teamPositions.length === 0) {
          if (index === 0) teamPositions = team1Positions; // Left side
          else if (index === 1) teamPositions = team2Positions; // Right side
        }
      }

      // Record which team actually occupies left/right for correct territory labeling later
      if (teamPositions === team1Positions) {
        state.regionFactionMap[0] = teamId;
      } else if (teamPositions === team2Positions) {
        state.regionFactionMap[2] = teamId;
      }
      
      let positionIndex = 0;
      students.forEach(student => {
        // Each student gets 1 tile if 10+ students, otherwise 2 tiles
        const tilesPerStudent = state.roster.length >= 10 ? 1 : 2;
        const assignedTiles = [];
        
        for (let i = 0; i < tilesPerStudent && positionIndex < teamPositions.length; i++) {
          const pos = teamPositions[positionIndex];
          
          // Find the tile at this position
          const tile = state.board.tiles.find(t => t.x === pos.x && t.y === pos.y);
          if (tile && !tile.owner_game_student_id) {
            tile.owner_game_student_id = student.gsId;
            student.tilesOwned = (student.tilesOwned || 0) + 1;
            assignedTiles.push(tile);
            console.log(`Assigned tile (${tile.x}, ${tile.y}) to ${student.name} (${student.teamName || 'individual'})`);
          }
          
          positionIndex++;
        }
        
        // If we couldn't get 2 tiles from team positions, get more from same team area
        while (assignedTiles.length < tilesPerStudent && positionIndex < teamPositions.length) {
          const pos = teamPositions[positionIndex];
          const tile = state.board.tiles.find(t => t.x === pos.x && t.y === pos.y);
          if (tile && !tile.owner_game_student_id) {
        tile.owner_game_student_id = student.gsId;
        student.tilesOwned = (student.tilesOwned || 0) + 1;
            assignedTiles.push(tile);
            console.log(`Assigned additional tile (${tile.x}, ${tile.y}) to ${student.name} (${student.teamName || 'individual'})`);
          }
          positionIndex++;
        }
        
        // Fallback: if still don't have 2 tiles, assign any available tiles
        if (assignedTiles.length < tilesPerStudent) {
          const availableTiles = state.board.tiles.filter(tile => !tile.owner_game_student_id);
          while (assignedTiles.length < tilesPerStudent && availableTiles.length > 0) {
            const tile = availableTiles.shift(); // Take first available tile
            tile.owner_game_student_id = student.gsId;
            student.tilesOwned = (student.tilesOwned || 0) + 1;
            assignedTiles.push(tile);
            console.log(`Fallback: Assigned tile (${tile.x}, ${tile.y}) to ${student.name} (${student.teamName || 'individual'})`);
          }
        }
        
        // Ensure we have exactly the right number of tiles per student
        if (assignedTiles.length !== tilesPerStudent) {
          console.warn(`Student ${student.name} has ${assignedTiles.length} tiles instead of ${tilesPerStudent}`);
        }
      });
    });
    
    const tilesPerStudent = state.roster.length >= 10 ? 1 : 2;
    console.log(`Strategic starting tiles assigned - ${tilesPerStudent} tile(s) per student, teams placed in corners/edges`);
    
    // If we have a scenario, try to assign characters to appropriate territories
    if (state.scenario) {
      assignCharactersToAppropriateTerritories();
    }
  }
  
  function placeStartingCastles() {
    if (!state.board || !state.board.tiles) return;
    
    console.log('Placing starting castles with fair distribution...');
    
    // Group students by team to ensure fair castle distribution
    const teamGroups = {};
    state.roster.forEach(student => {
      const teamId = student.teamId || 'individual';
      if (!teamGroups[teamId]) {
        teamGroups[teamId] = [];
      }
      teamGroups[teamId].push(student);
    });
    
    // Calculate total castles per team
    const teamCastleCounts = {};
    Object.entries(teamGroups).forEach(([teamId, students]) => {
      teamCastleCounts[teamId] = students.reduce((total, student) => total + (student.startingCastles || 0), 0);
    });
    
    console.log('Team castle counts:', teamCastleCounts);
    
    // Ensure fair distribution - if one team has significantly more castles, redistribute
    const teamIds = Object.keys(teamCastleCounts);
    if (teamIds.length >= 2) {
      const maxCastles = Math.max(...Object.values(teamCastleCounts));
      const minCastles = Math.min(...Object.values(teamCastleCounts));
      
      // If there's a significant imbalance (more than 2 castle difference), redistribute
      if (maxCastles - minCastles > 2) {
        console.log('Redistributing castles for fair gameplay...');
        
        // Calculate fair distribution
        const totalCastles = Object.values(teamCastleCounts).reduce((sum, count) => sum + count, 0);
        const fairCastlesPerTeam = Math.floor(totalCastles / teamIds.length);
        const extraCastles = totalCastles % teamIds.length;
        
        // Redistribute castles fairly
        teamIds.forEach((teamId, index) => {
          const targetCastles = fairCastlesPerTeam + (index < extraCastles ? 1 : 0);
          const currentCastles = teamCastleCounts[teamId];
          const difference = targetCastles - currentCastles;
          
          if (difference !== 0) {
            const teamStudents = teamGroups[teamId];
            // Add or remove castles from team members
            let castlesToAdjust = Math.abs(difference);
            let studentIndex = 0;
            
            while (castlesToAdjust > 0 && studentIndex < teamStudents.length) {
              const student = teamStudents[studentIndex];
              if (difference > 0 && student.startingCastles < 3) {
                // Add castle
                student.startingCastles = (student.startingCastles || 0) + 1;
                castlesToAdjust--;
              } else if (difference < 0 && student.startingCastles > 0) {
                // Remove castle
                student.startingCastles = Math.max(0, (student.startingCastles || 0) - 1);
                castlesToAdjust--;
              }
              studentIndex++;
            }
          }
        });
      }
    }
    
    // Place castles on students' territories
    state.roster.forEach(student => {
      if (student.startingCastles > 0) {
        // Find student's first territory (lowest coordinates)
        const studentTiles = state.board.tiles.filter(tile => tile.owner_game_student_id === student.gsId);
        if (studentTiles.length > 0) {
          // Sort by coordinates to get the "first" tile
          studentTiles.sort((a, b) => {
            if (a.y !== b.y) return a.y - b.y;
            return a.x - b.x;
          });
          
          const firstTile = studentTiles[0];
          firstTile.castle_level = student.startingCastles;
          console.log(`Placed ${student.startingCastles} castle(s) on ${student.name}'s first territory (${firstTile.x}, ${firstTile.y})`);
        }
      }
    });
  }
  function assignCharactersToAppropriateTerritories() {
    if (!state.scenario || !state.scenario.factions) return;
    
    console.log('Assigning characters to appropriate territories based on their roles');
    
    // Get all faction territories
    const allTerritories = [];
    Object.entries(state.scenario.factions).forEach(([factionId, faction]) => {
      if (faction.territories) {
        faction.territories.forEach(territory => {
          allTerritories.push({
            ...territory,
            factionId,
            factionName: faction.name,
            factionColor: faction.color
          });
        });
      }
    });
    
    // Add neutral territories
    if (state.scenario.neutralTerritories) {
      state.scenario.neutralTerritories.forEach(territory => {
        allTerritories.push({
          ...territory,
          factionId: 'neutral',
          factionName: 'Neutral',
          factionColor: '#6b7280'
        });
      });
    }
    
    // Create a mapping of character roles to appropriate territories
    const characterTerritoryPreferences = {
      // Harry Potter characters
      'Harry Potter': ['Hogwarts', 'Gryffindor Common Room', 'Great Hall'],
      'Hermione Granger': ['Hogwarts', 'Library', 'Great Hall'],
      'Ron Weasley': ['Hogwarts', 'Gryffindor Common Room', 'Great Hall'],
      'Voldemort': ['Dark Forest', 'Graveyard', 'Malfoy Manor'],
      'Bellatrix Lestrange': ['Malfoy Manor', 'Dark Forest', 'Graveyard'],
      'Severus Snape': ['Hogwarts', 'Potions Classroom', 'Dungeons'],
      
      // Star Wars characters
      'Luke Skywalker': ['Tatooine', 'Yavin 4', 'Rebel Base'],
      'Princess Leia': ['Alderaan', 'Rebel Base', 'Death Star'],
      'Darth Vader': ['Death Star', 'Mustafar', 'Imperial Base'],
      'Emperor Palpatine': ['Death Star', 'Imperial Palace', 'Imperial Base'],
      
      // American Civil War characters
      'Abraham Lincoln': ['Washington D.C.', 'White House', 'Capitol'],
      'Ulysses S. Grant': ['Battlefield', 'Military Base', 'Fort'],
      'Robert E. Lee': ['Virginia', 'Confederate Base', 'Battlefield'],
      'Jefferson Davis': ['Richmond', 'Confederate Capital', 'Government Building'],
      
      // Add more character-territory mappings as needed
      
      // Romeo & Juliet (Shakespeare)
      'Romeo Montague': ['Montague Manor', "Prince's Palace", 'Market District'],
      'Juliet Capulet': ['Capulet Gardens', 'Capulet Balcony', 'Capulet Library'],
      'Lord Capulet': ['Capulet Manor', 'Capulet Hall', 'Capulet Library'],
      'Lady Capulet': ['Capulet Manor', 'Capulet Hall', 'Capulet Gardens'],
      'Mercutio': ['Market District', 'Church Square', 'Prince\'s Palace'],
      'Tybalt Capulet': ['Capulet Guards', 'Capulet Workshops', 'Capulet Gardens'],
      'Benvolio Montague': ['Montague Allies', 'City Gates', 'Market District'],
      'Friar Laurence': ["Friar Laurence's Cell", 'Church Square', 'City Gates']
    };
    
    // Assign characters to appropriate territories
    state.roster.forEach(student => {
      if (student.characterName) {
        const preferences = characterTerritoryPreferences[student.characterName] || [];
        
        // Find tiles owned by this student
        const studentTiles = state.board.tiles.filter(tile => tile.owner_game_student_id === student.gsId);
        
        // If none of the student's tiles match a preferred territory, try to swap within team region
        let hasPreferred = false;
        for (const tile of studentTiles) {
          const territoryData = getTerritoryForTile(tile, state.scenario);
          if (territoryData && preferences.includes(territoryData.name)) {
            hasPreferred = true;
            break;
          }
        }

        if (!hasPreferred && preferences.length > 0) {
          // Determine which board region (left/right) belongs to this student's faction
          let allowedRegionX = null; // 0 = left, 1 = center (neutral only), 2 = right
          if (state.regionFactionMap && state.regionFactionMap[0] === student.teamId) {
            allowedRegionX = 0;
          } else if (state.regionFactionMap && state.regionFactionMap[2] === student.teamId) {
            allowedRegionX = 2;
          }

          const regionSize = Math.max(2, Math.floor(Math.min(state.board.w, state.board.h) / 3));

          // Look for an unowned tile on the student's side (or neutral center if the preferred territory is neutral)
          const candidate = state.board.tiles.find(t => {
            if (t.owner_game_student_id) return false;
            const td = getTerritoryForTile(t, state.scenario);
            if (!td || !preferences.includes(td.name)) return false;
            const regionX = Math.floor(t.x / regionSize);
            if (td.factionId === 'neutral') {
              // Neutral preferred tiles must be in the center band
              return regionX === 1;
            }
            // Non-neutral preferred tiles must be on the student's faction side
            if (allowedRegionX === null) return false;
            return regionX === allowedRegionX;
          });
          if (candidate) {
            // Reassign one of the student's tiles to the preferred spot
            const giveBack = studentTiles[0];
            if (giveBack) giveBack.owner_game_student_id = null;
            candidate.owner_game_student_id = student.gsId;
            console.log(`Reassigned ${student.characterName} to preferred territory ${getTerritoryForTile(candidate, state.scenario)?.name}`);
          }
        }
      }
    });
  }
  
  function getTerritoryForTile(tile, scenario) {
    if (!scenario || !scenario.factions) return null;
    
    // Create a logical map layout based on factions and territories
    const mapWidth = state.board.w;
    const mapHeight = state.board.h;
    const centerX = Math.floor(mapWidth / 2);
    const centerY = Math.floor(mapHeight / 2);
    
    // Get faction territories organized by faction
    const factionTerritories = {};
    Object.entries(scenario.factions).forEach(([factionId, faction]) => {
      factionTerritories[factionId] = faction.territories || [];
    });
    
    // Add neutral territories
    const neutralTerritories = scenario.neutralTerritories || [];
    
    // Create a more logical territory distribution
    // Group territories by creating regions on the map
    
    // Calculate which region this tile belongs to
    const regionSize = Math.max(2, Math.floor(Math.min(mapWidth, mapHeight) / 3));
    const regionX = Math.floor(tile.x / regionSize);
    const regionY = Math.floor(tile.y / regionSize);
    
    // Create a deterministic seed based on region position
    const regionSeed = regionY * 3 + regionX;
    
    // Determine faction based on region
    const factionKeys = Object.keys(factionTerritories);
    let factionId = null;
    let territoryIndex = 0;
    
    if (regionX === 0) {
      // Left region - prefer the faction mapped to left by starting-tile assignment
      const mappedLeft = state.regionFactionMap && state.regionFactionMap[0];
      factionId = mappedLeft || factionKeys[0];
      territoryIndex = regionSeed % (factionTerritories[factionId]?.length || 1);
    } else if (regionX === 2) {
      // Right region - prefer the faction mapped to right by starting-tile assignment
      const mappedRight = state.regionFactionMap && state.regionFactionMap[2];
      factionId = mappedRight || factionKeys[1] || factionKeys[0];
      territoryIndex = regionSeed % (factionTerritories[factionId]?.length || 1);
    } else {
      // Center region - neutral territories or mixed
      const neutralIndex = regionSeed % neutralTerritories.length;
      return neutralTerritories[neutralIndex] || null;
    }
    
    // Return territory from the determined faction
    if (factionId && factionTerritories[factionId] && factionTerritories[factionId][territoryIndex]) {
      return {
        ...factionTerritories[factionId][territoryIndex],
        factionName: scenario.factions[factionId].name,
        factionColor: scenario.factions[factionId].color
      };
    }
    
    return null;
  }
  
  function updateGridDisplay() {
    console.log('updateGridDisplay called', { gridEl, tiles: state.board.tiles, board: state.board });
    
    if (!gridEl || !state.board.tiles) {
      console.log('updateGridDisplay: gridEl or tiles not found', { gridEl, tiles: state.board.tiles });
      return;
    }
    
    console.log('updateGridDisplay: updating grid with', state.board.tiles.length, 'tiles');
    
    gridEl.style.gridTemplateColumns = `repeat(${state.board.w}, 1fr)`;
    gridEl.style.gridTemplateRows = `repeat(${state.board.h}, 1fr)`;
    
    // Get attackable tiles for the selected student
    const attackableTiles = state.selectedGsId ? getAttackableTiles(state.selectedGsId) : [];
    const attackableTileIds = new Set(attackableTiles.map(t => t.id));
    
    gridEl.innerHTML = state.board.tiles.map(tile => {
      let owner = state.roster.find(r => r.gsId === tile.owner_game_student_id);
      let isAI = false;
      if (!owner && state.aiPlayers) {
        owner = state.aiPlayers.find(r => r.gsId === tile.owner_game_student_id);
        isAI = true;
      }
      const ownerName = owner ? (isAI ? `${owner.characterName} (AI)` : shortenName(owner.name)) : '';
      const castleLevel = tile.castle_level || 0;
      const castleText = castleLevel > 0 ? `üè∞${castleLevel}` : '';
      
      // Calculate tile cost based on distance from center
      const tileCost = !owner ? calculateTilePrice(tile.x, tile.y, state.board.w, state.board.h) : 0;
      
      // Determine territory name and cost
      let territoryName = '';
      let territoryCost = 0;
      if (state.scenario) {
        const territoryData = getTerritoryForTile(tile, state.scenario);
        if (territoryData) {
          territoryName = territoryData.name;
          territoryCost = territoryData.cost || tileCost;
        }
      }
      
      const displayName = territoryName || ownerName || '';
      const displayCost = !owner ? (territoryCost || tileCost) : 0;
      const costText = !owner ? `üí∞${displayCost}` : '';
      
      // Build display lines per owner type
      const characterDisplay = owner ? (isAI ? `${owner.characterName} (AI)` : (owner.characterName || '')) : '';
      const studentDisplay = owner && !isAI ? shortenName(owner.name) : '';
      
      // Compute visual styles for the tile
      const isOwnedBySelected = !!(owner && owner.gsId === state.selectedGsId);
      const isAttackable = attackableTileIds.has(tile.id) && !isOwnedBySelected;
      const characterName = owner ? (owner.characterName || '') : '';
      const teamColor = owner ? (owner.teamColor || state.colors.get(owner.gsId) || '#374151') : null;
      const backgroundColor = owner ? teamColor : '#0b1220';
      const borderStyle = isOwnedBySelected
        ? '2px solid #f59e0b'
        : (isAttackable ? '2px dashed #f59e0b' : `1px solid ${teamColor || '#1f2937'}`);

      console.log('Tile owner debug:', { 
        ownerName: owner?.name, 
        characterName: owner?.characterName, 
        isAI, 
        characterDisplay, 
        studentDisplay 
      });
      
      return `<div class="cell" data-tile-id="${tile.id}" data-x="${tile.x}" data-y="${tile.y}" 
                style="background: ${backgroundColor}; 
                       color: ${owner ? '#fff' : '#b3b8c6'}; 
                       cursor: pointer;
                       border: ${borderStyle};
                       display: flex;
                       flex-direction: column;
                       align-items: center;
                       justify-content: center;
                       min-height: 58px;
                       padding: 4px;
                       font-size: 11px;
                       text-align: center;
                       transition: transform .15s ease, box-shadow .15s ease;"
                onclick="handleTileClick('${tile.id}')"
                title="${owner ? `Owned by ${ownerName}${state.scenario && characterName ? ` (${characterName})` : ''}${owner.teamName ? ` - Team: ${owner.teamName}` : ''}` : `Click to buy ${state.scenario ? (territoryName || 'territory') : 'tile'} for ${displayCost} points`}${isAttackable && !isOwnedBySelected ? ' (Attackable!)' : ''}">
                ${owner ? `
                  ${characterDisplay ? `<div style="font-weight: 700; font-size: 11px; line-height: 1.1; letter-spacing:.2px;">${characterDisplay}</div>` : ''}
                  ${studentDisplay ? `<div style="font-size: 8px; line-height: 1.1; margin-top: 1px; opacity:.9;">${studentDisplay}</div>` : ''}
                  ${territoryName ? `<div style="font-size: 8px; color: #d6d9e1; line-height: 1.1; margin-top: 2px; opacity:.85;">${territoryName}</div>` : ''}
                ` : `
                  ${state.scenario ? `<div style=\"font-weight: 600; font-size: 10px; line-height: 1.1; letter-spacing:.2px;\">${displayName}</div>` : ''}
                  <div style="font-size: 9px; line-height: 1.1; margin-top: 2px; color:#98a2b3;">${costText}</div>
                `}
                <div style="font-size: 8px; margin-top: 1px;">${castleText || ''}</div>
              </div>`;
    }).join('');
    
    console.log('Grid updated with', state.board.tiles.length, 'tiles');
    
    // Render territory bonuses
    renderTerritoryBonuses();
  }
  
  function updateVictoryTarget() {
    if (!state.currentRoster) return;
    
    const totalTiles = state.board.w * state.board.h;
    const targetPercentage = state.teamMode ? 
      Math.max(0.25, 1 / state.roster.filter(r => r.teamId).length) : 0.25;
    
    victoryEl.textContent = `Target: ${(targetPercentage * 100).toFixed(0)}% of tiles (${Math.ceil(totalTiles * targetPercentage)} tiles)`;
  }
  
  function updateTeamScoreboards() {
    if (!state.roster || !state.board || !state.board.tiles) return;
    
    const scoreboardsEl = document.getElementById('teamScoreboards');
    if (!scoreboardsEl) return;
    
    // Group students by team
    const teamGroups = {};
    state.roster.forEach(student => {
      const teamId = student.teamId || 'individual';
      if (!teamGroups[teamId]) {
        teamGroups[teamId] = {
          students: [],
          teamName: student.teamName || 'Individual Players',
          teamColor: student.teamColor || '#6b7280'
        };
      }
      teamGroups[teamId].students.push(student);
    });
    
    // Calculate team statistics
    const totalTiles = state.board.w * state.board.h;
    const teamStats = {};
    
    Object.entries(teamGroups).forEach(([teamId, team]) => {
      const teamTiles = state.board.tiles.filter(tile => {
        const owner = state.roster.find(s => s.gsId === tile.owner_game_student_id);
        return owner && owner.teamId === teamId;
      });
      
      const territoryPercentage = (teamTiles.length / totalTiles) * 100;
      const castles = teamTiles.reduce((total, tile) => total + (tile.castle_level || 0), 0);
      
      teamStats[teamId] = {
        ...team,
        tilesOwned: teamTiles.length,
        territoryPercentage: territoryPercentage,
        castles: castles,
        students: team.students
      };
    });
    
    // Create compact horizontal scoreboard HTML
    let scoreboardHTML = '<div style="display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">';
    
    Object.entries(teamStats).forEach(([teamId, stats]) => {
      const isWinning = stats.territoryPercentage >= 50;
      
      scoreboardHTML += `
        <div style="
          background: ${stats.teamColor}20;
          border: 2px solid ${stats.teamColor};
          border-radius: 6px;
          padding: 0.5rem;
          min-width: 200px;
          flex: 1;
          ${isWinning ? 'box-shadow: 0 0 8px ' + stats.teamColor + '40;' : ''}
        ">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
            <h6 style="margin: 0; color: ${stats.teamColor}; font-weight: bold; font-size: 0.9rem;">${stats.teamName}</h6>
            <span style="font-size: 0.8rem; color: #6b7280;">${stats.territoryPercentage.toFixed(1)}%</span>
          </div>
          <div style="display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 0.25rem;">
            <span>Territories: <strong>${stats.tilesOwned}/${totalTiles}</strong></span>
            <span>Castles: <strong>${stats.castles}</strong></span>
            <span>Students: <strong>${stats.students.length}</strong></span>
          </div>
          <div style="
            background: #e5e7eb;
            border-radius: 3px;
            height: 6px;
            overflow: hidden;
          ">
            <div style="
              background: ${stats.teamColor};
              height: 100%;
              width: ${Math.min(100, stats.territoryPercentage)}%;
              transition: width 0.3s ease;
            "></div>
          </div>
        </div>
      `;
    });
    
    scoreboardHTML += '</div>';
    scoreboardsEl.innerHTML = scoreboardHTML;
  }
  
  
  function checkVictoryCondition() {
    if (!state.roster || !state.board || !state.board.tiles) return;
    
    const totalTiles = state.board.w * state.board.h;
    const targetPercentage = state.teamMode ? 
      Math.max(0.25, 1 / state.roster.filter(r => r.teamId).length) : 0.25;
    const targetTiles = Math.ceil(totalTiles * targetPercentage);
    
    // Count tiles owned by each player/team
    const tileCounts = {};
    
    if (state.teamMode) {
      // Team mode - count tiles by team
      state.roster.forEach(student => {
        if (student.teamId) {
          const teamId = student.teamId;
          if (!tileCounts[teamId]) tileCounts[teamId] = 0;
          
          state.board.tiles.forEach(tile => {
            if (tile.owner_game_student_id === student.gsId) {
              tileCounts[teamId]++;
            }
          });
        }
      });
      
      // Check if any team has reached victory using custom victory goals
      for (const [teamId, count] of Object.entries(tileCounts)) {
        const teamPercentage = (count / totalTiles) * 100;
        const victoryGoal = state.victoryGoals?.[teamId] || 50; // Default 50% goal
        
        if (teamPercentage >= victoryGoal) {
          const teamName = state.roster.find(s => s.teamId === teamId)?.teamName || `Team ${teamId}`;
          showVictoryScreen(teamName, count, totalTiles, 'team');
          return;
        }
      }
    } else {
      // Individual mode - count tiles by student
      state.roster.forEach(student => {
        tileCounts[student.gsId] = 0;
        state.board.tiles.forEach(tile => {
          if (tile.owner_game_student_id === student.gsId) {
            tileCounts[student.gsId]++;
          }
        });
      });
      
      // Check if any student has reached victory
      for (const [studentId, count] of Object.entries(tileCounts)) {
        if (count >= targetTiles) {
          const student = state.roster.find(s => s.gsId === studentId);
          if (student) {
            showVictoryScreen(student.name, count, totalTiles, 'individual');
            return;
          }
        }
      }
    }
  }
  
  function showVictoryScreen(winnerName, tilesOwned, totalTiles, mode) {
    // Create victory screen overlay
    const victoryOverlay = document.createElement('div');
    victoryOverlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      animation: fadeIn 0.5s ease-in;
    `;
    
    victoryOverlay.innerHTML = `
      <div style="
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 3rem;
        border-radius: 20px;
        text-align: center;
        color: white;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        max-width: 600px;
        width: 90%;
        animation: slideIn 0.5s ease-out;
      ">
        <div style="font-size: 4rem; margin-bottom: 1rem;">üèÜ</div>
        <h1 style="font-size: 3rem; margin-bottom: 1rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
          VICTORY!
        </h1>
        <h2 style="font-size: 2rem; margin-bottom: 2rem; color: #ffd700;">
          ${winnerName} Wins!
        </h2>
        <div style="background: rgba(255,255,255,0.1); padding: 1.5rem; border-radius: 10px; margin: 2rem 0;">
          <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">
            üó∫Ô∏è Controlled ${tilesOwned} out of ${totalTiles} territories
          </p>
          <p style="font-size: 1.2rem;">
            üìä ${((tilesOwned / totalTiles) * 100).toFixed(1)}% of the map
          </p>
        </div>
        <div style="margin-top: 2rem;">
          <button id="continueGameBtn" style="
            background: #10b981;
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 0.5rem;
            transition: all 0.2s ease;
          ">Continue Current Game</button>
          <button id="newGameBtn" style="
            background: #f59e0b;
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 0.5rem;
            transition: all 0.2s ease;
          ">Start New Game</button>
        </div>
      </div>
      <style>
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes slideIn {
          from { transform: scale(0.8) translateY(-50px); opacity: 0; }
          to { transform: scale(1) translateY(0); opacity: 1; }
        }
        #continueGameBtn:hover, #newGameBtn:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
      </style>
    `;
    
    document.body.appendChild(victoryOverlay);
    
    // Add confetti effect
    createConfettiEffect();
    
    // Play victory sound
    if (typeof playWin === 'function') {
      playWin();
    }
    
    // Add button event listeners
    document.getElementById('continueGameBtn').onclick = () => {
      victoryOverlay.remove();
      // Award victory points to winner
      awardVictoryPoints(winnerName, mode);
    };
    
    document.getElementById('newGameBtn').onclick = () => {
      victoryOverlay.remove();
      // Award victory points to winner
      awardVictoryPoints(winnerName, mode);
      // Reset game for new game
      resetGameForNewRound();
    };
  }
  
  function createConfettiEffect() {
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
    const confettiCount = 100;
    
    for (let i = 0; i < confettiCount; i++) {
      setTimeout(() => {
        const confetti = document.createElement('div');
        confetti.style.cssText = `
          position: fixed;
          width: 10px;
          height: 10px;
          background: ${colors[Math.floor(Math.random() * colors.length)]};
          top: -10px;
          left: ${Math.random() * 100}%;
          z-index: 10001;
          animation: confettiFall 3s linear forwards;
        `;
        
        document.body.appendChild(confetti);
        
        setTimeout(() => confetti.remove(), 3000);
      }, i * 10);
    }
    
    // Add confetti animation CSS
    if (!document.getElementById('confetti-styles')) {
      const style = document.createElement('style');
      style.id = 'confetti-styles';
      style.textContent = `
        @keyframes confettiFall {
          0% {
            transform: translateY(0) rotate(0deg);
            opacity: 1;
          }
          100% {
            transform: translateY(100vh) rotate(720deg);
            opacity: 0;
          }
        }
      `;
      document.head.appendChild(style);
    }
  }
  
  function awardVictoryPoints(winnerName, mode) {
    if (!state.currentRoster) return;
    
    const victoryBonus = getActiveEconomy().victoryBonus; // Balanced bonus for winning
    
    if (mode === 'team') {
      // Award points to all team members
      const winningTeam = state.roster.find(s => s.teamName === winnerName);
      if (winningTeam) {
        state.roster.forEach(student => {
          if (student.teamId === winningTeam.teamId) {
            student.balance += victoryBonus;
            // Update roster
            const rosterIndex = state.currentRoster.roster.findIndex(r => r.name === student.name);
            if (rosterIndex >= 0) {
              state.currentRoster.roster[rosterIndex].points = student.balance;
              state.currentRoster.roster[rosterIndex].victories = (state.currentRoster.roster[rosterIndex].victories || 0) + 1;
            }
          }
        });
      }
    } else {
      // Award points to individual winner
      const winner = state.roster.find(s => s.name === winnerName);
      if (winner) {
        winner.balance += victoryBonus;
        // Update roster
        const rosterIndex = state.currentRoster.roster.findIndex(r => r.name === winnerName);
        if (rosterIndex >= 0) {
          state.currentRoster.roster[rosterIndex].points = winner.balance;
          state.currentRoster.roster[rosterIndex].victories = (state.currentRoster.roster[rosterIndex].victories || 0) + 1;
        }
      }
    }
    
    // Save updated roster
    if (state.currentRoster) {
      const rosters = JSON.parse(localStorage.getItem('tornadoRosters') || '[]');
      const rosterIndex = rosters.findIndex(r => r.id === state.currentRoster.id);
      if (rosterIndex >= 0) {
        rosters[rosterIndex] = state.currentRoster;
        localStorage.setItem('tornadoRosters', JSON.stringify(rosters));
      }
    }
    
    // Show victory bonus notification
    alert(`üéâ Victory Bonus!\n\n${winnerName} receives ${victoryBonus} bonus points for winning!\n\nVictory has been recorded in the roster.`);
  }
  function resetGameForNewRound() {
    // Reset all tiles to unowned
    if (state.board && state.board.tiles) {
      state.board.tiles.forEach(tile => {
        tile.owner_game_student_id = null;
        tile.castle_level = 0;
      });
    }
    
    // Reset tile counts
    state.roster.forEach(student => {
      student.tilesOwned = 0;
    });
    
    // Update display
    updateGridDisplay();
    syncTileCounts();
    updateVictoryTarget();
    
    alert('üéÆ New game started! All territories are now available for conquest.');
  }
  
  function syncTileCounts() {
    if (!state.roster || !state.board || !state.board.tiles) return;
    
    console.log('Syncing tile counts with actual board state');
    
    // Reset all tile counts to 0
    state.roster.forEach(student => {
      student.tilesOwned = 0;
    });
    
    // Count actual tiles owned by each student
    state.board.tiles.forEach(tile => {
      if (tile.owner_game_student_id) {
        const student = state.roster.find(s => s.gsId === tile.owner_game_student_id);
        if (student) {
          student.tilesOwned = (student.tilesOwned || 0) + 1;
        }
      }
    });
    
    console.log('Tile counts synced:', state.roster.map(s => `${s.name}: ${s.tilesOwned} tiles`));
    
    // Update the roster display
    renderRoster();
  }
  
  // Load roster button functionality
  el("#loadRosterBtn").onclick = () => {
    window.location.href = '/roster';
  };
  
  // Save roster button functionality
  el("#saveRosterBtn").onclick = () => {
    saveCurrentRoster();
  };
  
  // Quick roster button functionality
  el("#createQuickRosterBtn").onclick = () => {
    createDefaultRoster();
  };

  // Create teams button functionality
  el("#createTeamsBtn").onclick = () => {
    createRandomTeams();
  };
  
  async function saveCurrentRoster() {
    if (!state.currentRoster || !state.currentRosterId) {
      alert('No roster selected to save.');
      return;
    }
    
    // Sync tile counts before saving
    syncTileCounts();
    
    // Update the roster data with current scores and game state
    const updatedRoster = {
      ...state.currentRoster,
      roster: state.roster.map(student => ({
        id: student.gsId,
        name: student.name,
        // Persist split points
        startingPoints: student.startingPoints || 0,
        earnedPoints: student.earnedPoints || 0,
        points: (student.startingPoints || 0) + (student.earnedPoints || 0),
        tilesOwned: student.tilesOwned,
        teamId: student.teamId,
        teamName: student.teamName,
        teamColor: student.teamColor
      })),
      gameState: {
        board: state.board,
        tiles: state.board.tiles,
        truces: state.truces || []
      },
      scenario: state.scenario, // Save scenario data including character assignments
      victoryGoals: state.victoryGoals, // Save victory goals
      aiConfig: state.currentRoster.aiConfig, // Save AI configuration
      aiState: state.currentRoster.aiState, // Save AI state (stipend ticker data)
      lastModified: new Date().toISOString()
    };
    
    // Update in the rosters array
    const rosterIndex = state.rosters.findIndex(r => r.id === state.currentRosterId);
    if (rosterIndex >= 0) {
      state.rosters[rosterIndex] = updatedRoster;
      
      // Save to localStorage
      localStorage.setItem('tornadoRosters', JSON.stringify(state.rosters));
      
      // Save to Supabase if logged in
      if (state.session && !state.offlineMode) {
        try {
          const { error } = await supabase.from('rosters').upsert({
            id: state.currentRosterId,
            teacher_id: state.session.user.id,
            name: state.currentRoster.name,
            data: updatedRoster,
            last_modified: new Date().toISOString()
          });
          
          if (error) {
            console.error('Error saving to Supabase:', error);
            alert(`Saved locally, but failed to save to cloud: ${error.message}`);
          } else {
            alert(`Roster "${state.currentRoster.name}" saved successfully to cloud!`);
          }
        } catch (error) {
          console.error('Error saving to Supabase:', error);
          alert(`Saved locally, but failed to save to cloud: ${error.message}`);
        }
      } else {
        alert(`Roster "${state.currentRoster.name}" saved locally!`);
      }
    }
  }
  
  // Load roster by ID (for use from roster page)
  function loadRoster(rosterId) {
    selectRoster(rosterId);
  }

  // Roster list change event
  rosterList.onchange = () => selectRoster(rosterList.value);






  



  function updateStudentPoints(gsId, newValue) {
    const student = state.roster.find(r => r.gsId === gsId);
    if (student) {
      const newPoints = parseInt(newValue) || 0;
      student.balance = newPoints;
      renderRoster(); // Refresh display
    }
  }
  
  async function awardPoints(students, amount, actionText) {
    if (!students || students.length === 0) return;
    
    students.forEach(studentData => {
      const student = state.roster.find(s => s.gsId === studentData.gsId);
      if (student) {
        // Awarded/earned points should increment earnedPoints only
        student.earnedPoints = (student.earnedPoints || 0) + amount;
        student.balance = (student.startingPoints || 0) + (student.earnedPoints || 0);
        console.log(`${actionText}: ${student.name} now has ${student.balance} points (earned=${student.earnedPoints}, starting=${student.startingPoints})`);
        // Persist career points locally and best-effort Supabase
        try {
          const lsStudents = JSON.parse(localStorage.getItem('tornadoStudents') || '[]');
          const idx = lsStudents.findIndex(s => s.username === student.name);
          if (idx >= 0) {
            lsStudents[idx].careerPoints = (lsStudents[idx].careerPoints || 0) + amount;
            localStorage.setItem('tornadoStudents', JSON.stringify(lsStudents));
          }
          // Best-effort Supabase career_points increment if we can match by auth id
          if (state.session && student.authId) {
            try {
              supabase.rpc('increment_career_points', { p_student_id: student.authId, p_delta: amount })
                .then(({ error }) => { if (error) console.warn('increment_career_points error', error.message); })
                .catch(e => console.warn('increment_career_points exception', e));
            } catch (e) { console.warn('increment_career_points exception (outer):', e); }
          }
        } catch (e) { /* ignore */ }
      }
    });
    
    // Update the display and auto-save
    renderRoster();
    autoSaveWarPoints();
  }

  // Helper function to check if two tiles are adjacent (including diagonal)
  function areTilesAdjacent(tile1, tile2) {
    const dx = Math.abs(tile1.x - tile2.x);
    const dy = Math.abs(tile1.y - tile2.y);
    return (dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0);
  }
  
  // Helper function to check if a student can attack/claim a tile based on adjacency
  function canStudentAttackTile(studentGsId, targetTile) {
    // If student has no territories, they can claim any unowned tile (initial placement)
    const studentTiles = state.board.tiles.filter(t => t.owner_game_student_id === studentGsId);
    if (studentTiles.length === 0) {
      return true; // Initial placement - can claim any unowned tile
    }
    
    // Check if target tile is owned by a teammate (same faction) - teammates cannot attack each other
    if (targetTile.owner_game_student_id && state.scenario) {
      const attacker = state.roster.find(r => r.gsId === studentGsId);
      const defender = state.roster.find(r => r.gsId === targetTile.owner_game_student_id);
      
      if (attacker && defender && state.scenario.manualRoleAssignments) {
        const attackerCharacter = state.scenario.manualRoleAssignments[attacker.gsId];
        const defenderCharacter = state.scenario.manualRoleAssignments[defender.gsId];
        
        // Find which faction each character belongs to
        let attackerFaction = null;
        let defenderFaction = null;
        
        Object.entries(state.scenario.factions).forEach(([factionId, faction]) => {
          if (faction.characters) {
            faction.characters.forEach(char => {
              if (char.name === attackerCharacter) attackerFaction = factionId;
              if (char.name === defenderCharacter) defenderFaction = factionId;
            });
          }
          if (faction.generalRoles) {
            faction.generalRoles.forEach(role => {
              if (role.name === attackerCharacter) attackerFaction = factionId;
              if (role.name === defenderCharacter) defenderFaction = factionId;
            });
          }
        });
        
        // If both characters are from the same faction, they cannot attack each other
        if (attackerFaction && defenderFaction && attackerFaction === defenderFaction) {
          return false;
        }
      }
    }
    
    // Check if target tile is adjacent to any of student's territories
    for (const studentTile of studentTiles) {
      if (areTilesAdjacent(studentTile, targetTile)) {
        return true;
      }
    }
    
    // Check if target tile is adjacent to any teammate's territories (for scenario games)
    if (state.scenario) {
      const student = state.roster.find(r => r.gsId === studentGsId);
      if (student && student.teamId) {
        const teammates = state.roster.filter(r => r.teamId === student.teamId && r.gsId !== studentGsId);
        
        for (const teammate of teammates) {
          const teammateTiles = state.board.tiles.filter(t => t.owner_game_student_id === teammate.gsId);
          
          for (const teammateTile of teammateTiles) {
            if (areTilesAdjacent(teammateTile, targetTile)) {
              return true;
            }
          }
        }
      }
    }
    
    // Check if target tile is adjacent to any truce partner's territories (for non-team games)
    const studentTruces = state.truces.filter(truce => 
      truce.student1 === studentGsId || truce.student2 === studentGsId
    );
    
    for (const truce of studentTruces) {
      const trucePartnerGsId = truce.student1 === studentGsId ? truce.student2 : truce.student1;
      const trucePartnerTiles = state.board.tiles.filter(t => t.owner_game_student_id === trucePartnerGsId);
      
      for (const truceTile of trucePartnerTiles) {
        if (areTilesAdjacent(truceTile, targetTile)) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  // Helper function to get all attackable tiles for a student
  function getAttackableTiles(studentGsId) {
    const attackableTiles = [];
    
    for (const tile of state.board.tiles) {
      if (canStudentAttackTile(studentGsId, tile)) {
        attackableTiles.push(tile);
      }
    }
    
    return attackableTiles;
  }

  // Make handleTileClick globally accessible
  window.handleTileClick = function(tileId) {
    console.log('handleTileClick called with tileId:', tileId, 'selectedGsId:', state.selectedGsId);
    
    if (!state.selectedGsId) {
      alert("Please select a student first by clicking on their name in the roster.");
      return;
    }

    const tile = state.board.tiles.find(t => t.id === tileId);
    if (!tile) {
      console.log('Tile not found:', tileId);
      return;
    }

    const selectedStudent = state.roster.find(r => r.gsId === state.selectedGsId);
    if (!selectedStudent) {
      console.log('Selected student not found:', state.selectedGsId);
      return;
    }

    console.log('Handling tile click:', { tile, selectedStudent });

    if (!tile.owner_game_student_id) {
      // Empty tile - buy it (check adjacency)
      if (!canStudentAttackTile(selectedStudent.gsId, tile)) {
        alert(`Cannot claim this territory! You can only claim territories that are adjacent to your own territories or your truce partners' territories.`);
        return;
      }
      
      const cost = calculateTilePrice(tile.x, tile.y, state.board.w, state.board.h);
      if (selectedStudent.balance >= cost) {
        tile.owner_game_student_id = selectedStudent.gsId;
        selectedStudent.balance -= cost;
        selectedStudent.tilesOwned += 1;
        updateGridDisplay();
        syncTileCounts();
        autoSaveWarPoints();
        alert(`${selectedStudent.name} bought the tile for ${cost} points!`);
      } else {
        alert(`Insufficient funds! Need ${cost} points.`);
      }
    } else if (tile.owner_game_student_id === selectedStudent.gsId) {
      // Own tile - show castle options
      if (tile.castle_level > 0) {
        // Has castle - show upgrade/sell options
        const upgradeCost = tile.castle_level === 1 ? state.costs.castleL2 : 
                           tile.castle_level === 2 ? state.costs.castleL3 : 0;
        const sellValue = tile.castle_level === 1 ? state.costs.castleL1 : 
                         tile.castle_level === 2 ? state.costs.castleL2 : 
                         tile.castle_level === 3 ? state.costs.castleL3 : 0;
        
        const options = [];
        if (upgradeCost > 0) {
          options.push(`Upgrade to level ${tile.castle_level + 1} (${upgradeCost} points)`);
        } else {
          options.push("Castle is at maximum level");
        }
        options.push(`Sell castle (get back ${sellValue} points)`);
        
        const choice = prompt(`Castle Level ${tile.castle_level} Options:\n\n${options.map((opt, i) => `${i + 1}. ${opt}`).join('\n')}\n\nEnter choice (1-${options.length}):`);
        
        if (choice === '1' && upgradeCost > 0) {
          // Upgrade
          if (selectedStudent.balance >= upgradeCost) {
            tile.castle_level += 1;
            selectedStudent.balance -= upgradeCost;
            updateGridDisplay();
            renderRoster();
            alert(`${selectedStudent.name} upgraded castle to level ${tile.castle_level} for ${upgradeCost} points!`);
          } else {
            alert(`Insufficient funds! Need ${upgradeCost} points.`);
          }
        } else if (choice === '2' || (choice === '1' && upgradeCost === 0)) {
          // Sell castle
          tile.castle_level = 0;
          selectedStudent.balance += sellValue;
          updateGridDisplay();
          renderRoster();
          alert(`${selectedStudent.name} sold castle and got back ${sellValue} points!`);
        }
      } else {
        // No castle - build one
        const buildCost = state.costs.castleL1;
        if (selectedStudent.balance >= buildCost) {
          tile.castle_level = 1;
          selectedStudent.balance -= buildCost;
          updateGridDisplay();
          renderRoster();
          alert(`${selectedStudent.name} built a castle for ${buildCost} points!`);
        } else {
          alert(`Insufficient funds! Need ${buildCost} points.`);
        }
      }
    } else {
      // Enemy tile - attack (check adjacency)
      if (!canStudentAttackTile(selectedStudent.gsId, tile)) {
        const defender = state.roster.find(r => r.gsId === tile.owner_game_student_id);
        if (defender && state.scenario) {
          // First check: Are they on the same team? (simpler check)
          if (selectedStudent.teamId && defender.teamId && selectedStudent.teamId === defender.teamId) {
            alert(`Cannot attack teammate! ${defender.name} is on your team (${selectedStudent.teamName}). You can only attack enemies from other teams.`);
            return;
          }
          
          // Second check: Are they from the same faction? (for manual role assignments)
          if (state.scenario.manualRoleAssignments) {
          const attackerCharacter = state.scenario.manualRoleAssignments[selectedStudent.gsId];
          const defenderCharacter = state.scenario.manualRoleAssignments[defender.gsId];
          
          // Check if they're teammates
          let attackerFaction = null;
          let defenderFaction = null;
          
          Object.entries(state.scenario.factions).forEach(([factionId, faction]) => {
            if (faction.characters) {
              faction.characters.forEach(char => {
                if (char.name === attackerCharacter) attackerFaction = factionId;
                if (char.name === defenderCharacter) defenderFaction = factionId;
              });
            }
            if (faction.generalRoles) {
              faction.generalRoles.forEach(role => {
                if (role.name === attackerCharacter) attackerFaction = factionId;
                if (role.name === defenderCharacter) defenderFaction = factionId;
              });
            }
          });
          
          if (attackerFaction && defenderFaction && attackerFaction === defenderFaction) {
            alert(`Cannot attack teammate! ${defender.name} (${defenderCharacter}) is on your side. You can only attack enemies from other factions.`);
            return;
            }
          }
        }
        
        alert(`Cannot attack this territory! You can only attack territories that are adjacent to your own territories or your truce partners' territories.`);
        return;
      }
      
      const defender = state.roster.find(r => r.gsId === tile.owner_game_student_id);
      if (defender) {
        // Check if students are teammates (automatic truce in scenario games)
        const areTeammates = state.scenario && selectedStudent.teamId && defender.teamId && selectedStudent.teamId === defender.teamId;
        
        // Check if students are in a manual truce (for non-team games)
        const areInTruce = state.truces.some(truce => 
          (truce.student1 === selectedStudent.gsId && truce.student2 === defender.gsId) ||
          (truce.student1 === defender.gsId && truce.student2 === selectedStudent.gsId)
        );
        
        if (areTeammates) {
          alert(`Cannot attack ${defender.name}! They are on your team (${selectedStudent.teamName}). You can only attack enemies from other teams.`);
          return;
        }
        
        if (areInTruce) {
          alert(`Cannot attack ${defender.name}! You are in a truce with them.`);
          return;
        }
        
        // Check if defender has only 1 tile left (protection rule)
        if (defender.tilesOwned <= 1) {
          alert(`Cannot attack ${defender.name}! They only have 1 tile left and are protected from elimination.`);
          return;
        }
        showFightScreen(selectedStudent.gsId, defender.gsId, tile);
      }
    }
  };

  // Update game theme title based on current scenario
  function updateGameThemeTitle() {
    const themeTitle = document.getElementById('gameThemeTitle');
    if (!themeTitle) return;
    
    if (state.scenario && state.scenario.scenarioName) {
      const scenarioName = state.scenario.scenarioName;
      const scenarioData = SCENARIOS[state.scenario.scenarioId];
      
      // Get theme-specific emoji and styling
      let emoji = 'üéÆ';
      let gradient = 'linear-gradient(135deg, #8b5cf6, #3b82f6)';
      
      if (scenarioName.includes('Harry Potter')) {
        emoji = '‚ö°';
        gradient = 'linear-gradient(135deg, #dc143c, #8b0000)';
      } else if (scenarioName.includes('Star Wars')) {
        emoji = '‚≠ê';
        gradient = 'linear-gradient(135deg, #4169e1, #000080)';
      } else if (scenarioName.includes('Pokemon')) {
        emoji = '‚ö°';
        gradient = 'linear-gradient(135deg, #ffd700, #ff6b6b)';
      } else if (scenarioName.includes('Disney')) {
        emoji = 'üè∞';
        gradient = 'linear-gradient(135deg, #ff69b4, #ff1493)';
      } else if (scenarioName.includes('Pixar')) {
        emoji = 'üé¨';
        gradient = 'linear-gradient(135deg, #00bfff, #1e90ff)';
      } else if (scenarioName.includes('Marvel')) {
        emoji = 'ü¶∏';
        gradient = 'linear-gradient(135deg, #dc143c, #ff4500)';
      } else if (scenarioName.includes('DC')) {
        emoji = 'ü¶á';
        gradient = 'linear-gradient(135deg, #000080, #4169e1)';
      } else if (scenarioName.includes('Revolution')) {
        emoji = 'üá∫üá∏';
        gradient = 'linear-gradient(135deg, #dc143c, #000080)';
      } else if (scenarioName.includes('Civil War')) {
        emoji = '‚öîÔ∏è';
        gradient = 'linear-gradient(135deg, #dc143c, #8b0000)';
      } else if (scenarioName.includes('World War')) {
        emoji = 'üåç';
        gradient = 'linear-gradient(135deg, #8b0000, #2f4f4f)';
      } else if (scenarioName.includes('Greek') || scenarioName.includes('Mythology')) {
        emoji = 'üèõÔ∏è';
        gradient = 'linear-gradient(135deg, #daa520, #b8860b)';
      } else if (scenarioName.includes('Hunger Games')) {
        emoji = 'üèπ';
        gradient = 'linear-gradient(135deg, #ff4500, #8b0000)';
      }
      
      themeTitle.innerHTML = `${emoji} ${scenarioName}`;
      themeTitle.style.background = gradient;
    } else {
      themeTitle.innerHTML = 'üéÆ New Game';
      themeTitle.style.background = 'linear-gradient(135deg, #8b5cf6, #3b82f6)';
    }
  }
  function renderRoster() {
    rosterEl.innerHTML = "";
    
    // Show AI controls if there are AI players (check both roster and aiPlayers)
    const hasAIPlayers = state.roster.some(r => r.isAI) || (state.aiPlayers && state.aiPlayers.length > 0);
    const aiControls = document.getElementById('aiControls');
    if (aiControls) {
      aiControls.style.display = hasAIPlayers ? 'block' : 'none';
    }
    
    // Update game theme title
    updateGameThemeTitle();
    
    for (const r of state.roster) {
      const row = document.createElement("div");
      row.className = "row" + (state.selectedGsId===r.gsId ? " sel" : "");
      row.style.borderColor = state.colors.get(r.gsId);
      const teamInfo = r.teamName ? `<div style="font-size:10px; color:var(--muted);">${r.teamName}</div>` : '';
      const teamColor = r.teamColor || state.colors.get(r.gsId);
      
      // Add team indicator
      const teamIndicator = r.teamName ? `<div style="width: 8px; height: 8px; border-radius: 50%; background: ${teamColor}; display: inline-block; margin-right: 4px;" title="Team: ${r.teamName}"></div>` : '';
      
      // Get character name if scenario is active
      let characterName = '';
      if (state.scenario) {
        console.log('Scenario active in renderRoster:', state.scenario.scenarioName);
        const scenario = state.scenario;
        
        // First check if student has characterName property
        if (r.characterName) {
          characterName = r.characterName;
          console.log('Found character from student property for', r.name, ':', characterName);
        } else {
          console.log('No characterName found for student', r.name, 'characterName property:', r.characterName);
        }
        
        if (!characterName && scenario.manualRoleAssignments && scenario.manualRoleAssignments[r.gsId]) {
          characterName = scenario.manualRoleAssignments[r.gsId];
          console.log('Found manual role assignment for', r.name, ':', characterName);
        } else if (scenario.aiAssignments) {
          // Check if this student is assigned to an AI role
          const aiRole = Object.values(scenario.aiAssignments).find(ai => ai.studentId === r.gsId);
          if (aiRole) {
            characterName = aiRole.roleName || 'AI Character';
            console.log('Found AI role assignment for', r.name, ':', characterName);
          }
        }
        
        // Fallback: assign random character if none found
        if (!characterName) {
          const allCharacters = [];
          Object.values(scenario.factions).forEach(faction => {
            if (faction.characters) {
              faction.characters.forEach(char => allCharacters.push(char.name));
            }
          });
          
          if (allCharacters.length > 0) {
            const randomCharacter = allCharacters[Math.floor(Math.random() * allCharacters.length)];
            characterName = randomCharacter;
            
            // Add to manualRoleAssignments for future reference
            if (!scenario.manualRoleAssignments) {
              scenario.manualRoleAssignments = {};
            }
            scenario.manualRoleAssignments[r.gsId] = characterName;
            
            console.log('Assigned random character:', characterName, 'to', r.name);
          }
        }
        
        console.log('Character name for', r.name, ':', characterName);
      } else {
        console.log('No scenario active in renderRoster');
      }
      
      const characterDisplay = characterName ? `<div style="font-size:11px; color:#8b5cf6; font-weight:600;">${characterName}</div>` : '';
      
      row.innerHTML = `
        <div style="display:flex; gap:4px; align-items:center;">
          <div style="width:8px;height:8px;border-radius:50%;background:${teamColor}; cursor:pointer;" 
               onclick="changeTeamColor('${r.gsId}')" title="Click to change team color"></div>
          <div>
          <div style="display: flex; align-items: center; gap: 3px; font-size: 12px;">${teamIndicator}${r.name}${characterName ? ` (${characterName})` : ''}</div>
            ${teamInfo}
        </div>
        </div>
        <div class="bal" title="Balance" style="display: flex; align-items: center; gap: 3px;">
          <span>üí∞</span>
          <input type="number" value="${formatMoney(r.balance)}" 
                 style="width: 50px; padding: 1px 3px; border: 1px solid var(--border); border-radius: 3px; background: var(--panel); color: var(--text); font-size: 11px;"
                 onchange="updateStudentPoints('${r.gsId}', this.value)"
                 title="Click to edit points">
        </div>
        <div class="chip" title="Tiles owned" style="font-size:10px; padding:1px 4px;">üß© ${r.tilesOwned}</div>
        <div style="display: flex; gap: 2px; flex-wrap: wrap;">
          <button class="plus" data-gs="${r.gsId}" data-action="add" data-amount="1" style="background:#10b981; color:white; font-size:9px; padding:1px 3px;">+1</button>
          <button class="plus" data-gs="${r.gsId}" data-action="add" data-amount="5" style="background:#3b82f6; color:white; font-size:9px; padding:1px 3px;">+5</button>
          <button class="plus" data-gs="${r.gsId}" data-action="add" data-amount="10" style="background:#8b5cf6; color:white; font-size:9px; padding:1px 3px;">+10</button>
          ${r.isAI ? `<button class="plus" onclick="takeAITurn('${r.gsId}')" style="background:#f59e0b; color:white; font-size:9px; padding:1px 3px;">ü§ñ AI</button>` : ''}
          <button class="plus" data-gs="${r.gsId}" data-action="subtract" data-amount="1" style="background:#ef4444; color:white; font-size:9px; padding:1px 3px;">-1</button>
          <button class="market-btn" data-gs="${r.gsId}" style="background:#f59e0b; color:white; font-size:8px; padding:1px 3px;" title="Student Market">üõí</button>
          <button onclick="showEventCardModal()" class="event-btn" style="background:#8b5cf6; color:white; font-size:8px; padding:1px 3px;" title="Event Cards">üé≤</button>
        </div>
      `;
      row.onclick = (e) => {
        if (e.target.classList.contains("plus") || e.target.classList.contains("market-btn")) return;
        state.selectedGsId = r.gsId;
        renderRoster();
        updateGridDisplay(); // Update grid to show attackable territories
        contextEl.textContent = `Selected: ${r.name}. Click a tile to buy/upgrade/attack.`;
      };
      row.querySelectorAll(".plus").forEach(button => {
        button.onclick = async (e) => {
        e.stopPropagation();
          const action = button.dataset.action;
          const amount = parseInt(button.dataset.amount);
          const finalAmount = action === "subtract" ? -amount : amount;
          const actionText = action === "subtract" ? `Quick -${amount}` : `Quick +${amount}`;
          await awardPoints([{ gsId: r.gsId }], finalAmount, actionText);
        };
      });
      
      // Market button event handler
      row.querySelectorAll(".market-btn").forEach(button => {
        button.onclick = (e) => {
          e.stopPropagation();
          showStudentMarket(r.gsId);
        };
      });
      rosterEl.appendChild(row);
    }
    
    // Add AI players section if they exist
    console.log('renderRoster: Checking for AI players:', state.aiPlayers?.length || 0);
    console.log('renderRoster: state.aiPlayers =', state.aiPlayers);
    console.log('renderRoster: typeof state.aiPlayers =', typeof state.aiPlayers);
    if (state.aiPlayers && state.aiPlayers.length > 0) {
      // Add separator
      const separator = document.createElement('div');
      separator.style.cssText = `
        width: 100%;
        height: 2px;
        background: linear-gradient(90deg, transparent, #8b5cf6, transparent);
        margin: 10px 0;
        border-radius: 1px;
      `;
      rosterEl.appendChild(separator);
      
      // Add AI section header
      const aiHeader = document.createElement('div');
      aiHeader.style.cssText = `
        font-size: 14px;
        font-weight: 600;
        color: #8b5cf6;
        margin-bottom: 8px;
        text-align: center;
        background: rgba(139, 92, 246, 0.1);
        padding: 8px;
        border-radius: 6px;
        border: 1px solid rgba(139, 92, 246, 0.2);
      `;
      aiHeader.textContent = 'ü§ñ AI Players';
      rosterEl.appendChild(aiHeader);
      
      // Add AI players
      for (const aiPlayer of state.aiPlayers) {
        const row = document.createElement('div');
        row.className = "roster-row";
        row.style.cssText = `
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 8px;
          border: 1px solid var(--border);
          border-radius: 6px;
          background: rgba(139, 92, 246, 0.05);
          margin-bottom: 4px;
        `;
        
        const teamColor = aiPlayer.teamColor || '#8b5cf6';
        const teamIndicator = aiPlayer.teamName ? `<span style="font-size:10px; color:${teamColor}; font-weight:600;">[${aiPlayer.teamName}]</span> ` : '';
        
        row.innerHTML = `
          <div style="display:flex; gap:6px; align-items:center;">
            <div style="width:10px;height:10px;border-radius:50%;background:${teamColor};"></div>
            <div>
              <div style="display: flex; align-items: center; gap: 4px;">${teamIndicator}${aiPlayer.characterName} (AI)</div>
            </div>
          </div>
          <div class="bal" title="Balance" style="display: flex; align-items: center; gap: 4px;">
            <span>üí∞</span>
            <span style="font-size: 12px; color: var(--text);">${formatMoney(aiPlayer.balance)}</span>
          </div>
          <div class="chip" title="Tiles owned">üß© ${aiPlayer.tilesOwned}</div>
          <button class="plus" onclick="takeAITurn('${aiPlayer.gsId}')" style="background:#f59e0b; color:white;">ü§ñ AI</button>
        `;
        
        rosterEl.appendChild(row);
      }
    }
  }

  // === BOARD ===

  function nameForGs(gsId){
    // Check roster first
    let student = state.roster.find(r=>r.gsId===gsId);
    if (!student && state.aiPlayers) {
      // Check AI players if not found in roster
      student = state.aiPlayers.find(r=>r.gsId===gsId);
    }
    if (!student) {
      return "Unknown";
    }
    return student.name;
  }

  // Calculate tile price based on distance from center (premium center tiles)
  function calculateTilePrice(x, y, boardW, boardH) {
    const centerX = (boardW - 1) / 2;
    const centerY = (boardH - 1) / 2;
    const distanceFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
    const maxDistance = Math.sqrt(Math.pow(boardW / 2, 2) + Math.pow(boardH / 2, 2));
    
    // Rings: outer to inner, moderate slope
    const ringLevel = Math.floor((1 - distanceFromCenter / maxDistance) * 6);
    let price = 20 + (ringLevel * 10);
    
    // Premium center: if within Manhattan distance <= 1 of center, add premium
    const isCenterCore = (Math.abs(x - Math.round(centerX)) + Math.abs(y - Math.round(centerY))) <= 1;
    if (isCenterCore) {
      price += 30; // premium for exclusive real estate
    }
    return Math.max(20, Math.min(250, price));
  }

  // Shorten student name to fit in tile
  function shortenName(name, maxLength = 8) {
    if (name.length <= maxLength) return name;
    // Try to keep first name + last initial
    const parts = name.split(' ');
    if (parts.length >= 2) {
      return parts[0] + ' ' + parts[parts.length - 1][0];
    }
    // If single name, truncate with ellipsis
    return name.substring(0, maxLength - 1) + '‚Ä¶';
  }


  // Quick award function for common amounts
  window.quickAward = async (amount) => {
    if (!state.roster || state.roster.length === 0) return alert("No roster loaded.");
    state.roster.forEach(student => {
      student.balance = Math.max(0, student.balance + amount); // Prevent negative points
    });
    renderRoster();
    autoSaveWarPoints();
  };

  // === ROSTER SORTING ===
  window.sortWarRoster = (sortType) => {
    if (!state.roster || state.roster.length === 0) return alert("No roster loaded.");
    
    state.roster.sort((a, b) => {
      const nameA = a.name.toLowerCase();
      const nameB = b.name.toLowerCase();
      
      if (sortType === 'first') {
        // Sort by first name
        const firstNameA = nameA.split(' ')[0];
        const firstNameB = nameB.split(' ')[0];
        return firstNameA.localeCompare(firstNameB);
      } else if (sortType === 'last') {
        // Sort by last name
        const lastNameA = nameA.split(' ').pop() || '';
        const lastNameB = nameB.split(' ').pop() || '';
        return lastNameA.localeCompare(lastNameB);
      }
      
      return nameA.localeCompare(nameB);
    });
    
    renderRoster();
    autoSaveWarPoints();
    console.log(`Sorted roster by ${sortType} name`);
  };

  window.shuffleWarRoster = () => {
    if (!state.roster || state.roster.length === 0) return alert("No roster loaded.");
    
    // Fisher-Yates shuffle algorithm
    for (let i = state.roster.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [state.roster[i], state.roster[j]] = [state.roster[j], state.roster[i]];
    }
    
    renderRoster();
    autoSaveWarPoints();
    console.log("Shuffled roster");
  };
  

  // === TEAM RESOURCE MANAGEMENT ===
  function getTeamResources(teamId) {
    if (!state.teamMode || !teamId) return null;
    
    const teamMembers = state.roster.filter(student => student.teamId === teamId);
    const totalBalance = teamMembers.reduce((sum, student) => sum + student.balance, 0);
    const averageBalance = teamMembers.length > 0 ? totalBalance / teamMembers.length : 0;
    
    return {
      members: teamMembers,
      totalBalance: totalBalance,
      averageBalance: averageBalance,
      memberCount: teamMembers.length
    };
  }
  
  function canTeamAffordCost(teamId, cost) {
    if (!state.teamMode || !teamId) return false;
    
    const teamResources = getTeamResources(teamId);
    if (!teamResources) return false;
    
    // Team can afford if they have enough total resources
    return teamResources.totalBalance >= cost;
  }
  
  function deductTeamCost(teamId, cost, reason = '') {
    if (!state.teamMode || !teamId) return false;
    
    const teamResources = getTeamResources(teamId);
    if (!teamResources || teamResources.totalBalance < cost) return false;
    
    // Distribute cost evenly among team members
    const costPerMember = Math.ceil(cost / teamResources.memberCount);
    let remainingCost = cost;
    
    teamResources.members.forEach((member, index) => {
      const memberCost = Math.min(costPerMember, remainingCost);
      member.balance = Math.max(0, member.balance - memberCost);
      remainingCost -= memberCost;
      
      console.log(`${member.name} (${teamResources.members[0].teamName}) paid ${memberCost} points for ${reason}`);
    });
    
    return true;
  }

  // === AUTO-SAVE SYSTEM ===
  async function autoSaveWarPoints() {
    if (!state.currentRoster || !state.currentRosterId) return;
    
    try {
      // Update the roster data with current scores and game state
      const updatedRoster = {
        ...state.currentRoster,
        roster: state.roster.map(student => ({
          id: student.gsId,
          name: student.name,
          // Persist split points
          startingPoints: student.startingPoints || 0,
          earnedPoints: student.earnedPoints || 0,
          points: (student.startingPoints || 0) + (student.earnedPoints || 0),
          tilesOwned: student.tilesOwned,
          teamId: student.teamId,
          teamName: student.teamName,
          teamColor: student.teamColor,
          // Save character data
          characterName: student.characterName,
          characterRole: student.characterRole,
          characterFaction: student.characterFaction,
          startingCastles: student.startingCastles,
          weapons: student.weapons,
          mercenaries: student.mercenaries
        })),
        gameState: {
          board: state.board,
          tiles: state.board.tiles,
          truces: state.truces || []
        },
        scenario: state.scenario, // Save scenario data including character assignments
        victoryGoals: state.victoryGoals, // Save victory goals
        economy: state.economy || __activeEconomy || ECONOMY,
        lastModified: new Date().toISOString()
      };
      
      // Update in the rosters array
      const rosterIndex = state.rosters.findIndex(r => r.id === state.currentRosterId);
      if (rosterIndex >= 0) {
        state.rosters[rosterIndex] = updatedRoster;
        
        // Save to localStorage
        localStorage.setItem('tornadoRosters', JSON.stringify(state.rosters));
        
        // Save to Supabase if logged in (silently, no alerts)
        if (state.session && !state.offlineMode) {
          try {
            const { error } = await supabase.from('rosters').upsert({
              id: state.currentRosterId,
              teacher_id: state.session.user.id,
              name: state.currentRoster.name,
              data: updatedRoster,
              last_modified: new Date().toISOString()
            });
            if (error) {
              console.error('Supabase error:', error);
              // Graceful fallback if table missing
              if (error.code === 'PGRST205' || /Could not find the table 'public.rosters'/.test(error.message||'')) {
                console.warn("Supabase 'rosters' table missing. Saved locally only.");
              } else {
                throw error;
              }
            }
            if (error) {
              console.error('Supabase error:', error);
              if (error.code === 'PGRST205' || /Could not find the table 'public.rosters'/.test(error.message||'')) {
                console.warn("Supabase 'rosters' table missing. Saved locally only.");
              } else {
                throw error;
              }
            }
            console.log('Auto-saved war points to Supabase');
          } catch (error) {
            console.error('Error auto-saving to Supabase:', error);
            // Continue with local save even if Supabase fails
          }
        }
        
        console.log('Auto-saved war points to roster');
      }
    } catch (error) {
      console.error('Error auto-saving war points:', error);
    }
  }

  // Tornado button removed - tornado functionality moved to Student Market
  el("#btnTruces").onclick = () => {
    if (!state.selectedGsId) {
      alert('Please select a student first to manage their truces.');
      return;
    }
    showTeacherTruceModal();
  };

  // === Reset Earned Points Controls ===
  const resetEarnedGameBtn = document.getElementById('resetEarnedGameBtn');
  if (resetEarnedGameBtn) {
    resetEarnedGameBtn.onclick = () => {
      if (!state.roster || state.roster.length === 0) return;
      if (!confirm('Reset earned points for this game? This will keep character starting points and clear awarded/earned points.')) return;
      state.roster.forEach(s => {
        s.earnedPoints = 0;
        s.balance = (s.startingPoints || 0);
      });
      renderRoster();
      autoSaveWarPoints();
      alert('Earned points reset for this game.');
    };
  }

  const resetEarnedRosterBtn = document.getElementById('resetEarnedRosterBtn');
  if (resetEarnedRosterBtn) {
    resetEarnedRosterBtn.onclick = () => {
      if (!state.currentRoster) return;
      if (!confirm('Reset earned points on this roster? This updates the saved roster so future games start with earned=0 but keep starting points.')) return;
      // Update in-memory
      state.roster.forEach(s => {
        s.earnedPoints = 0;
        s.balance = (s.startingPoints || 0);
      });
      // Update saved roster object
      if (state.currentRoster.roster) {
        state.currentRoster.roster = state.currentRoster.roster.map(r => ({
          ...r,
          earnedPoints: 0,
          startingPoints: r.startingPoints || r.points || 0,
          points: r.startingPoints || r.points || 0
        }));
      }
      // Persist
      const idx = state.rosters.findIndex(r => r.id === state.currentRosterId);
      if (idx >= 0) {
        state.rosters[idx] = state.currentRoster;
        localStorage.setItem('tornadoRosters', JSON.stringify(state.rosters));
      }
      autoSaveWarPoints();
      renderRoster();
      alert('Roster earned points reset.');
    };
  }

  el("#btnReset").onclick = () => {
    if (!state.currentRoster) {
      alert('No roster selected. Please select a roster first.');
      return;
    }

    showNewGameModal();
  };

  // New Game button in map area
  el("#gameThemeTitle").onclick = () => {
    if (!state.currentRoster) {
      alert('No roster selected. Please select a roster first.');
      return;
    }

    showNewGameModal();
  };

  // === AUDIT (simple) ===
  // === FIGHT SCREEN FUNCTIONALITY ===
  let currentBattle = null;
  
  // Function to get scenario-specific battle items
  function getScenarioBattleItems(scenario) {
    if (!scenario) {
      // Default battle items for no scenario
      return {
        weapons: [
          { id: 'spear', name: 'Spear', cost: 30, power: 15, icon: 'üó°Ô∏è' },
          { id: 'crossbow', name: 'Crossbow', cost: 60, power: 20, icon: 'üèπ' },
          { id: 'catapult', name: 'Catapult', cost: 100, power: 30, icon: 'üè∞' }
        ],
        castles: [
          { id: 'wooden', name: 'Wooden Keep', cost: 50, power: 75, icon: 'üè†' },
          { id: 'stone', name: 'Stone Fortress', cost: 100, power: 150, icon: 'üè∞' },
          { id: 'iron', name: 'Iron Citadel', cost: 200, power: 300, icon: 'üèØ' }
        ]
      };
    }

    // Scenario-specific battle items
    console.log('Scenario ID:', scenario ? scenario.id : 'No scenario');
    console.log('Scenario object:', scenario);
    console.log('Scenario keys:', scenario ? Object.keys(scenario) : 'No scenario');
    
    if (!scenario) {
      console.log('No scenario found, using default items');
      return {
        weapons: [
          { id: 'spear', name: 'Spear', cost: 30, power: 15, icon: 'üó°Ô∏è' },
          { id: 'crossbow', name: 'Crossbow', cost: 60, power: 20, icon: 'üèπ' },
          { id: 'catapult', name: 'Catapult', cost: 100, power: 30, icon: 'üè∞' }
        ],
        castles: [
          { id: 'wooden', name: 'Wooden Keep', cost: 50, power: 75, icon: 'üè†' },
          { id: 'stone', name: 'Stone Fortress', cost: 100, power: 150, icon: 'üè∞' },
          { id: 'iron', name: 'Iron Citadel', cost: 200, power: 300, icon: 'üèØ' }
        ]
      };
    }
    
    // Check if scenario has scenarioId instead of id
    const scenarioId = scenario.id || scenario.scenarioId;
    console.log('Using scenario ID:', scenarioId);
    
    switch (scenarioId) {
      case 'harryPotter':
        return {
          weapons: [
            { id: 'wand', name: 'Wand', cost: 30, power: 15, icon: 'ü™Ñ' },
            { id: 'invisibility_cloak', name: 'Cloak of Invisibility', cost: 60, power: 20, icon: 'üëª' },
            { id: 'felix_felicis', name: 'Felix Felicis', cost: 100, power: 30, icon: 'üçÄ' }
          ],
          castles: [
            { id: 'wooden', name: 'Magical Cottage', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Hogwarts Castle', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Protected Hogwarts', cost: 200, power: 300, icon: 'üèØ' }
          ],
          allies: [
            { id: 'phoenix', name: 'Phoenix', cost: 150, power: 50, icon: 'üî•' },
            { id: 'hungarian_horntail', name: 'Hungarian Horntail', cost: 200, power: 75, icon: 'üêâ' },
            { id: 'basilisk', name: 'Basilisk', cost: 250, power: 100, icon: 'üêç' }
          ],
          spells: [
            { id: 'expelliarmus', name: 'Expelliarmus', cost: 80, power: 25, icon: '‚ö°' },
            { id: 'protego', name: 'Protego', cost: 120, power: 40, icon: 'üõ°Ô∏è' },
            { id: 'patronus', name: 'Expecto Patronum', cost: 200, power: 100, icon: 'ü¶å' }
          ]
        };

      case 'americanRevolution':
        return {
          weapons: [
            { id: 'musket', name: 'Musket', cost: 30, power: 15, icon: 'üî´' },
            { id: 'cannon', name: 'Cannon', cost: 60, power: 20, icon: 'üí£' },
            { id: 'naval_ship', name: 'Naval Ship', cost: 100, power: 30, icon: 'üö¢' }
          ],
          castles: [
            { id: 'wooden', name: 'Colonial Fort', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Revolutionary Stronghold', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Independence Fortress', cost: 200, power: 300, icon: 'üèØ' }
          ]
        };

      case 'starWars':
        return {
          weapons: [
            { id: 'blaster', name: 'Blaster', cost: 40, power: 20, icon: 'üî´' },
            { id: 'thermal_detonator', name: 'Thermal Detonator', cost: 80, power: 40, icon: 'üí•' },
            { id: 'x_wing', name: 'Starfighter Support', cost: 140, power: 70, icon: 'üõ∏' }
          ],
          castles: [
            { id: 'shield_outpost', name: 'Shield Outpost', cost: 75, power: 75, icon: 'üõ°Ô∏è' },
            { id: 'ion_cannon_base', name: 'Ion Cannon Base', cost: 150, power: 150, icon: 'üî≠' },
            { id: 'planetary_shield', name: 'Planetary Shield', cost: 300, power: 300, icon: 'ü™ê' }
          ]
        };

      case 'lordOfTheRings':
        return {
          weapons: [
            { id: 'sword', name: 'Elven Sword', cost: 40, power: 20, icon: 'üó°Ô∏è' },
            { id: 'bow', name: 'Ranger Bow', cost: 80, power: 40, icon: 'üèπ' },
            { id: 'ent_aid', name: 'Ent Aid', cost: 140, power: 70, icon: 'üå≥' }
          ],
          castles: [
            { id: 'stockade', name: 'Wooden Stockade', cost: 75, power: 75, icon: 'ü™µ' },
            { id: 'helm_deep', name: "Helm's Deep", cost: 150, power: 150, icon: 'üè∞' },
            { id: 'minas_tirith', name: 'White City Defenses', cost: 300, power: 300, icon: 'üèØ' }
          ]
        };

      case 'romeoAndJuliet':
        return {
          weapons: [
            { id: 'rapier', name: 'Rapier', cost: 30, power: 15, icon: 'üó°Ô∏è' },
            { id: 'crossbow', name: 'Crossbow', cost: 60, power: 20, icon: 'üèπ' },
            { id: 'guard_patrol', name: 'Guard Patrol', cost: 100, power: 30, icon: 'üõ°Ô∏è' }
          ],
          castles: [
            { id: 'manor', name: 'Family Manor', cost: 50, power: 75, icon: 'üèòÔ∏è' },
            { id: 'city_gate', name: 'City Gate', cost: 100, power: 150, icon: 'üö™' },
            { id: 'fortified_palazzo', name: 'Fortified Palazzo', cost: 200, power: 300, icon: 'üè∞' }
          ]
        };

      case 'worldWar2':
        return {
          weapons: [
            { id: 'rifle', name: 'Rifle', cost: 30, power: 15, icon: 'üî´' },
            { id: 'tank', name: 'Tank', cost: 60, power: 20, icon: 'üöó' },
            { id: 'bomber', name: 'Bomber', cost: 100, power: 30, icon: '‚úàÔ∏è' }
          ],
          castles: [
            { id: 'wooden', name: 'Bunker', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Military Base', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Fortress', cost: 200, power: 300, icon: 'üèØ' }
          ]
        };

      case 'starWars':
        return {
          weapons: [
            { id: 'blaster', name: 'Blaster', cost: 30, power: 15, icon: 'üî´' },
            { id: 'lightsaber', name: 'Lightsaber', cost: 60, power: 20, icon: '‚öîÔ∏è' },
            { id: 'death_star', name: 'Death Star', cost: 100, power: 30, icon: 'üåç' }
          ],
          castles: [
            { id: 'wooden', name: 'Rebel Base', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Imperial Outpost', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Death Star', cost: 200, power: 300, icon: 'üèØ' }
          ]
        };

      case 'avengers':
        return {
          weapons: [
            { id: 'shield', name: 'Vibranium Shield', cost: 30, power: 15, icon: 'üõ°Ô∏è' },
            { id: 'hammer', name: 'Mjolnir', cost: 60, power: 20, icon: 'üî®' },
            { id: 'infinity_gauntlet', name: 'Infinity Gauntlet', cost: 100, power: 30, icon: 'üëä' }
          ],
          castles: [
            { id: 'wooden', name: 'Avengers Safe House', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Avengers Tower', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Avengers Compound', cost: 200, power: 300, icon: 'üèØ' }
          ]
        };

      case 'theIliad':
        return {
          weapons: [
            { id: 'spear', name: 'Greek Spear', cost: 30, power: 15, icon: 'üó°Ô∏è' },
            { id: 'bow', name: 'Apollo\'s Bow', cost: 60, power: 20, icon: 'üèπ' },
            { id: 'chariot', name: 'War Chariot', cost: 100, power: 30, icon: 'üè∫' }
          ],
          castles: [
            { id: 'wooden', name: 'Greek Camp', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Troy Walls', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Troy Citadel', cost: 200, power: 300, icon: 'üèØ' }
          ]
        };

      case 'civilWar':
        return {
          weapons: [
            { id: 'rifle', name: 'Civil War Rifle', cost: 30, power: 15, icon: 'üî´' },
            { id: 'cannon', name: 'Field Cannon', cost: 60, power: 20, icon: 'üí£' },
            { id: 'ironclad', name: 'Ironclad Ship', cost: 100, power: 30, icon: 'üö¢' }
          ],
          castles: [
            { id: 'wooden', name: 'Union Camp', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Confederate Fort', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Fort Sumter', cost: 200, power: 300, icon: 'üèØ' }
          ]
        };

      case 'juliusCaesar':
        return {
          weapons: [
            { id: 'gladius', name: 'Gladius', cost: 30, power: 15, icon: 'üó°Ô∏è' },
            { id: 'pilum', name: 'Pilum', cost: 60, power: 20, icon: 'üèπ' },
            { id: 'ballista', name: 'Ballista', cost: 100, power: 30, icon: 'üè∞' }
          ],
          castles: [
            { id: 'wooden', name: 'Roman Camp', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Roman Fort', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Roman Citadel', cost: 200, power: 300, icon: 'üèØ' }
          ]
        };

      case 'animalFarm':
        return {
          weapons: [
            { id: 'pitchfork', name: 'Pitchfork', cost: 30, power: 15, icon: 'üó°Ô∏è' },
            { id: 'scythe', name: 'Scythe', cost: 60, power: 20, icon: 'üèπ' },
            { id: 'windmill', name: 'Windmill', cost: 100, power: 30, icon: 'üè∞' }
          ],
          castles: [
            { id: 'wooden', name: 'Animal Barn', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Farm House', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Command Center', cost: 200, power: 300, icon: 'üèØ' }
          ]
        };

      case 'romeoAndJuliet':
        return {
          weapons: [
            { id: 'rapier', name: 'Rapier', cost: 30, power: 15, icon: 'üó°Ô∏è' },
            { id: 'crossbow', name: 'Crossbow', cost: 60, power: 20, icon: 'üèπ' },
            { id: 'cannon', name: 'Cannon', cost: 100, power: 30, icon: 'üè∞' }
          ],
          castles: [
            { id: 'wooden', name: 'Montague Manor', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Capulet Palace', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Verona Castle', cost: 200, power: 300, icon: 'üèØ' }
          ]
        };

      case 'lordOfTheRings':
        return {
          weapons: [
            { id: 'sword', name: 'Elven Sword', cost: 30, power: 15, icon: 'üó°Ô∏è' },
            { id: 'bow', name: 'Elven Bow', cost: 60, power: 20, icon: 'üèπ' },
            { id: 'ring', name: 'One Ring', cost: 100, power: 30, icon: 'üíç' }
          ],
          castles: [
            { id: 'wooden', name: 'Hobbit Hole', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Minas Tirith', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Barad-d√ªr', cost: 200, power: 300, icon: 'üèØ' }
          ]
        };

      default:
        // Fallback to default items
        return {
          weapons: [
            { id: 'spear', name: 'Spear', cost: 30, power: 15, icon: 'üó°Ô∏è' },
            { id: 'crossbow', name: 'Crossbow', cost: 60, power: 20, icon: 'üèπ' },
            { id: 'catapult', name: 'Catapult', cost: 100, power: 30, icon: 'üè∞' }
          ],
          castles: [
            { id: 'wooden', name: 'Wooden Keep', cost: 50, power: 75, icon: 'üè†' },
            { id: 'stone', name: 'Stone Fortress', cost: 100, power: 150, icon: 'üè∞' },
            { id: 'iron', name: 'Iron Citadel', cost: 200, power: 300, icon: 'üèØ' }
          ]
        };
    }
  }
  
  // Function to add character starting weapons to battle screen
  function addCharacterStartingWeapons(student, isAttacker) {
    if (!student.weapons || student.weapons.length === 0) return;
    
    const weaponListId = isAttacker ? 'attackerWeaponList' : 'defenderWeaponList';
    const weaponList = document.getElementById(weaponListId);
    
    // Clear existing character weapons
    const existingCharacterWeapons = weaponList.querySelectorAll('.character-weapon');
    existingCharacterWeapons.forEach(weapon => weapon.remove());
    
    // Add character's starting weapons
    student.weapons.forEach(weapon => {
      const weaponElement = document.createElement('div');
      weaponElement.className = 'character-weapon';
      weaponElement.style.cssText = `
        background: #374151;
        padding: 8px;
        border-radius: 6px;
        margin: 4px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border: 2px solid #10b981;
      `;
      
      // Get weapon icon and power based on weapon name
      const weaponData = getWeaponData(weapon);
      
      weaponElement.innerHTML = `
        <span>${weaponData.icon} ${weapon} (Starting Weapon)</span>
        <button onclick="addCharacterWeapon('${weapon}', ${isAttacker})" 
                style="background: #10b981; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
          Use (Free)
        </button>
      `;
      
      weaponList.appendChild(weaponElement);
    });
  }
  
  // Function to get weapon data for character starting weapons
  function getWeaponData(weaponName) {
    const weaponMap = {
      'wand': { icon: 'ü™Ñ', power: 15, name: 'Wand' },
      'invisibility_cloak': { icon: 'üëª', power: 20, name: 'Cloak of Invisibility' },
      'felix_felicis': { icon: 'üçÄ', power: 30, name: 'Felix Felicis' },
      'elder wand': { icon: 'ü™Ñ', power: 25 },
      'time turner': { icon: '‚è∞', power: 20 },
      'horcruxes': { icon: 'üíÄ', power: 30 },
      'slytherin ring': { icon: 'üíç', power: 20 },
      'slytherin necklace': { icon: 'üìø', power: 20 },
      'musket': { icon: 'üî´', power: 15 },
      'cannon': { icon: 'üí£', power: 20 },
      'naval ship': { icon: 'üö¢', power: 30 },
      'rifle': { icon: 'üî´', power: 15 },
      'tank': { icon: 'üöó', power: 20 },
      'bomber': { icon: '‚úàÔ∏è', power: 30 },
      'blaster': { icon: 'üî´', power: 15 },
      'lightsaber': { icon: '‚öîÔ∏è', power: 20 },
      'death star': { icon: 'üåç', power: 30 },
      'vibranium shield': { icon: 'üõ°Ô∏è', power: 15 },
      'mjolnir': { icon: 'üî®', power: 20 },
      'infinity gauntlet': { icon: 'üëä', power: 30 },
      'greek spear': { icon: 'üó°Ô∏è', power: 15 },
      'apollo\'s bow': { icon: 'üèπ', power: 20 },
      'war chariot': { icon: 'üè∫', power: 30 },
      'civil war rifle': { icon: 'üî´', power: 15 },
      'field cannon': { icon: 'üí£', power: 20 },
      'ironclad ship': { icon: 'üö¢', power: 30 },
      'gladius': { icon: 'üó°Ô∏è', power: 15 },
      'pilum': { icon: 'üèπ', power: 20 },
      'ballista': { icon: 'üè∞', power: 30 },
      'pitchfork': { icon: 'üó°Ô∏è', power: 15 },
      'scythe': { icon: 'üèπ', power: 20 },
      'windmill': { icon: 'üè∞', power: 30 },
      'rapier': { icon: 'üó°Ô∏è', power: 15 },
      'crossbow': { icon: 'üèπ', power: 20 },
      'cannon': { icon: 'üè∞', power: 30 },
      'elven sword': { icon: 'üó°Ô∏è', power: 15 },
      'elven bow': { icon: 'üèπ', power: 20 },
      'one ring': { icon: 'üíç', power: 30 }
    };
    
    return weaponMap[weaponName.toLowerCase()] || { icon: '‚öîÔ∏è', power: 15 };
  }
  
  // Function to add character weapon to battle
  function addCharacterWeapon(weaponName, isAttacker) {
    if (!currentBattle) return;
    
    const weaponArray = isAttacker ? currentBattle.attackerWeapons : currentBattle.defenderWeapons;
    weaponArray.push(weaponName.toLowerCase());
    updateWeaponDisplay(isAttacker);
    updateBattleSummary();
  }
  
  function showFightScreen(attackerId, defenderId, tile) {
    const attacker = state.roster.find(r => r.gsId === attackerId);
    const defender = state.roster.find(r => r.gsId === defenderId);
    
    if (!attacker || !defender) return alert("Student not found");
    
    currentBattle = {
      attacker: attacker,
      defender: defender,
      tile: tile,
      attackerMercs: 0,
      attackerWeapons: [], // Array of weapons
      attackerAllies: [], // Array of allies
      attackerSpells: [], // Array of spells
      defenderMercs: 0,
      defenderWeapons: [], // Array of weapons
      defenderAllies: [], // Array of allies
      defenderSpells: [], // Array of spells
      defenderCastle: tile.castle_level || null, // Pre-built castle from tile
      defenderBattleCastle: null // Battle-screen castle
    };
    
    // Add purchased items to battle
    if (attacker.purchasedItems) {
      currentBattle.attackerWeapons = [...(attacker.purchasedItems.weapons || [])];
      currentBattle.attackerMercs = attacker.purchasedItems.mercenaries || 0;
      currentBattle.attackerAllies = [...(attacker.purchasedItems.allies || [])];
      currentBattle.attackerSpells = [...(attacker.purchasedItems.spells || [])];
    }
    
    if (defender.purchasedItems) {
      currentBattle.defenderWeapons = [...(defender.purchasedItems.weapons || [])];
      currentBattle.defenderMercs = defender.purchasedItems.mercenaries || 0;
      currentBattle.defenderAllies = [...(defender.purchasedItems.allies || [])];
      currentBattle.defenderSpells = [...(defender.purchasedItems.spells || [])];
    }
    
    // Get scenario-specific battle items
    // Try to get scenario from state.scenario or currentRoster.scenario
    const scenario = state.scenario || (state.currentRoster && state.currentRoster.scenario);
    const battleItems = getScenarioBattleItems(scenario);
    console.log('Battle screen scenario:', scenario);
    console.log('Battle items:', battleItems);
    
    // Update weapon buttons dynamically (use scenario items if present; otherwise economy defaults)
    const attackerWeaponButtons = [
      document.getElementById('attackerSpear'),
      document.getElementById('attackerCrossbow'),
      document.getElementById('attackerCatapult')
    ];
    
    const defenderWeaponButtons = [
      document.getElementById('defenderSpear'),
      document.getElementById('defenderCrossbow'),
      document.getElementById('defenderCatapult')
    ];
    
    const defenderCastleButtons = [
      document.getElementById('defenderCastle1'),
      document.getElementById('defenderCastle2'),
      document.getElementById('defenderCastle3')
    ];
    // Update castle buttons with active economy costs
    if (defenderCastleButtons[0]) defenderCastleButtons[0].textContent = `Wooden Keep (${getActiveEconomy().castleL1} pts)`;
    if (defenderCastleButtons[1]) defenderCastleButtons[1].textContent = `Stone Fortress (${getActiveEconomy().castleL2} pts)`;
    if (defenderCastleButtons[2]) defenderCastleButtons[2].textContent = `Iron Citadel (${getActiveEconomy().castleL3} pts)`;
    
    // Toggle allies/spells visibility by scenario
    const showAllies = Array.isArray(battleItems.allies) && battleItems.allies.length > 0;
    const showSpells = Array.isArray(battleItems.spells) && battleItems.spells.length > 0;
    const aAllies = document.getElementById('attackerAlliesSection');
    const aSpells = document.getElementById('attackerSpellsSection');
    const dAllies = document.getElementById('defenderAlliesSection');
    const dSpells = document.getElementById('defenderSpellsSection');
    if (aAllies) aAllies.style.display = showAllies ? '' : 'none';
    if (aSpells) aSpells.style.display = showSpells ? '' : 'none';
    if (dAllies) dAllies.style.display = showAllies ? '' : 'none';
    if (dSpells) dSpells.style.display = showSpells ? '' : 'none';

    // Update power legend to reflect scenario items
    const legend = document.getElementById('powerLegend');
    if (legend) {
      const w = (battleItems.weapons || []).map(w => w.name);
      const c = (battleItems.castles || []).map(c => c.name);
      legend.innerHTML = `
        <strong>How items affect power:</strong><br>
        ‚Ä¢ Mercenaries: +15 power each<br>
        ${w[0] ? `‚Ä¢ ${w[0]}: +50% power multiplier<br>` : ''}
        ${w[1] ? `‚Ä¢ ${w[1]}: +100% power multiplier<br>` : ''}
        ${w[2] ? `‚Ä¢ ${w[2]}: +200% power multiplier<br>` : ''}
        ‚Ä¢ Pre-built Castle L1: +150 power (2x bonus)<br>
        ‚Ä¢ Pre-built Castle L2: +300 power (2x bonus)<br>
        ‚Ä¢ Pre-built Castle L3: +600 power (2x bonus)<br>
        ${c[0] ? `‚Ä¢ ${c[0]}: +75 power<br>` : ''}
        ${c[1] ? `‚Ä¢ ${c[1]}: +150 power<br>` : ''}
        ${c[2] ? `‚Ä¢ ${c[2]}: +300 power<br>` : ''}
        <strong>Combo Bonuses:</strong><br>
        ‚Ä¢ 2+ items: +10% total power<br>
        ‚Ä¢ 3+ items: +25% total power<br>
        ‚Ä¢ 4+ items: +50% total power
      `;
    }

    // Update attacker weapon buttons
    (battleItems.weapons && battleItems.weapons.length ? battleItems.weapons : [
      { id: 'spear', name: 'Spear', cost: getActiveEconomy().weapons.spear, power: 15, icon: 'üó°Ô∏è' },
      { id: 'crossbow', name: 'Crossbow', cost: getActiveEconomy().weapons.crossbow, power: 30, icon: 'üèπ' },
      { id: 'catapult', name: 'Catapult', cost: getActiveEconomy().weapons.catapult, power: 60, icon: 'üéØ' }
    ]).forEach((weapon, index) => {
      if (attackerWeaponButtons[index]) {
        attackerWeaponButtons[index].textContent = `${weapon.icon} ${weapon.name} (${weapon.cost} pts)`;
        attackerWeaponButtons[index].setAttribute('data-weapon-id', weapon.id);
        attackerWeaponButtons[index].setAttribute('data-weapon-cost', weapon.cost);
        attackerWeaponButtons[index].setAttribute('data-weapon-power', weapon.power);
      }
    });
    
    // Update defender weapon buttons
    (battleItems.weapons && battleItems.weapons.length ? battleItems.weapons : [
      { id: 'spear', name: 'Spear', cost: getActiveEconomy().weapons.spear, power: 15, icon: 'üó°Ô∏è' },
      { id: 'crossbow', name: 'Crossbow', cost: getActiveEconomy().weapons.crossbow, power: 30, icon: 'üèπ' },
      { id: 'catapult', name: 'Catapult', cost: getActiveEconomy().weapons.catapult, power: 60, icon: 'üéØ' }
    ]).forEach((weapon, index) => {
      if (defenderWeaponButtons[index]) {
        defenderWeaponButtons[index].textContent = `${weapon.icon} ${weapon.name} (${weapon.cost} pts)`;
        defenderWeaponButtons[index].setAttribute('data-weapon-id', weapon.id);
        defenderWeaponButtons[index].setAttribute('data-weapon-cost', weapon.cost);
        defenderWeaponButtons[index].setAttribute('data-weapon-power', weapon.power);
      }
    });
    
    // Update defender castle buttons
    battleItems.castles.forEach((castle, index) => {
      if (defenderCastleButtons[index]) {
        defenderCastleButtons[index].textContent = `${castle.icon} ${castle.name} (${castle.cost} pts)`;
        defenderCastleButtons[index].setAttribute('data-castle-id', castle.id);
        defenderCastleButtons[index].setAttribute('data-castle-cost', castle.cost);
        defenderCastleButtons[index].setAttribute('data-castle-power', castle.power);
      }
    });
    
    // Update ally buttons if they exist
    if (battleItems.allies) {
      console.log('Updating ally buttons:', battleItems.allies);
      const attackerAllyButtons = [
        document.getElementById('attackerPhoenix'),
        document.getElementById('attackerHorntail'),
        document.getElementById('attackerBasilisk')
      ];
      console.log('Attacker ally buttons found:', attackerAllyButtons);
      
      const defenderAllyButtons = [
        document.getElementById('defenderPhoenix'),
        document.getElementById('defenderHorntail'),
        document.getElementById('defenderBasilisk')
      ];
      
      // Update attacker ally buttons
      battleItems.allies.forEach((ally, index) => {
        if (attackerAllyButtons[index]) {
          attackerAllyButtons[index].textContent = `${ally.icon} ${ally.name} (${ally.cost} pts)`;
          attackerAllyButtons[index].setAttribute('data-ally-id', ally.id);
          attackerAllyButtons[index].setAttribute('data-ally-cost', ally.cost);
          attackerAllyButtons[index].setAttribute('data-ally-power', ally.power);
        }
      });
      
      // Update defender ally buttons
      battleItems.allies.forEach((ally, index) => {
        if (defenderAllyButtons[index]) {
          defenderAllyButtons[index].textContent = `${ally.icon} ${ally.name} (${ally.cost} pts)`;
          defenderAllyButtons[index].setAttribute('data-ally-id', ally.id);
          defenderAllyButtons[index].setAttribute('data-ally-cost', ally.cost);
          defenderAllyButtons[index].setAttribute('data-ally-power', ally.power);
        }
      });
    }
    
    // Update spell buttons if they exist
    if (battleItems.spells) {
      console.log('Updating spell buttons:', battleItems.spells);
      const attackerSpellButtons = [
        document.getElementById('attackerExpelliarmus'),
        document.getElementById('attackerProtego'),
        document.getElementById('attackerPatronus')
      ];
      console.log('Attacker spell buttons found:', attackerSpellButtons);
      
      const defenderSpellButtons = [
        document.getElementById('defenderExpelliarmus'),
        document.getElementById('defenderProtego'),
        document.getElementById('defenderPatronus')
      ];
      
      // Update attacker spell buttons
      battleItems.spells.forEach((spell, index) => {
        if (attackerSpellButtons[index]) {
          attackerSpellButtons[index].textContent = `${spell.icon} ${spell.name} (${spell.cost} pts)`;
          attackerSpellButtons[index].setAttribute('data-spell-id', spell.id);
          attackerSpellButtons[index].setAttribute('data-spell-cost', spell.cost);
          attackerSpellButtons[index].setAttribute('data-spell-power', spell.power);
        }
      });
      
      // Update defender spell buttons
      battleItems.spells.forEach((spell, index) => {
        if (defenderSpellButtons[index]) {
          defenderSpellButtons[index].textContent = `${spell.icon} ${spell.name} (${spell.cost} pts)`;
          defenderSpellButtons[index].setAttribute('data-spell-id', spell.id);
          defenderSpellButtons[index].setAttribute('data-spell-cost', spell.cost);
          defenderSpellButtons[index].setAttribute('data-spell-power', spell.power);
        }
      });
    }
    
    // Add character starting weapons as available options
    addCharacterStartingWeapons(attacker, true); // true for attacker
    addCharacterStartingWeapons(defender, false); // false for defender
    
    // Check if students are in a truce
    const areInTruce = state.truces.some(truce => 
      (truce.student1 === attacker.gsId && truce.student2 === defender.gsId) ||
      (truce.student1 === defender.gsId && truce.student2 === attacker.gsId)
    );
    
    // Update modal content with character names
    const attackerDisplayName = attacker.characterName ? `${attacker.name} (${attacker.characterName})` : attacker.name;
    const defenderDisplayName = defender.characterName ? `${defender.name} (${defender.characterName})` : defender.name;
    
    document.getElementById('attackerName').textContent = attackerDisplayName;
    document.getElementById('defenderName').textContent = defenderDisplayName;
    document.getElementById('attackerBalance').textContent = attacker.balance;
    document.getElementById('defenderBalance').textContent = defender.balance;
    
    // Add truce indicator if students are in a truce
    if (areInTruce) {
      const truceIndicator = document.createElement('div');
      truceIndicator.style.cssText = `
        background: #10b981;
        color: white;
        padding: 10px;
        border-radius: 8px;
        margin: 10px 0;
        text-align: center;
        font-weight: bold;
      `;
      truceIndicator.innerHTML = 'ü§ù TRUCE ACTIVE - Resources can be shared!';
      
      // Insert after the battle summary
      const battleSummary = document.querySelector('#fightModal .card > div:last-child');
      battleSummary.parentNode.insertBefore(truceIndicator, battleSummary);
    }
    
    // Reset selections
    document.getElementById('attackerMercCount').textContent = '0';
    document.getElementById('defenderMercCount').textContent = '0';
    document.getElementById('attackerWeapons').textContent = 'None';
    document.getElementById('defenderWeapons').textContent = 'None';
    document.getElementById('attackerWeaponList').innerHTML = '';
    document.getElementById('defenderWeaponList').innerHTML = '';
    
    // Show pre-built castle if it exists
    if (tile.castle_level > 0) {
      const castleNames = ['', 'Wooden Keep', 'Stone Fortress', 'Iron Citadel'];
      document.getElementById('defenderCastle').textContent = `${castleNames[tile.castle_level]} (Pre-built)`;
    } else {
      document.getElementById('defenderCastle').textContent = 'None';
    }
    updateBattleSummary();
    
    // Show modal
    document.getElementById('fightModal').classList.add('show');
    
    // Pause AI stipend ticker during battle
    pauseAiStipendTicker();
  }
  
  // Helper functions for weapon management
  function addWeapon(type, isAttacker) {
    const weaponArray = isAttacker ? currentBattle.attackerWeapons : currentBattle.defenderWeapons;
    weaponArray.push(type);
    updateWeaponDisplay(isAttacker);
    updateBattleSummary();
  }
  function addAlly(type, isAttacker) {
    const allyArray = isAttacker ? currentBattle.attackerAllies : currentBattle.defenderAllies;
    allyArray.push(type);
    updateAllyDisplay(isAttacker);
    updateBattleSummary();
  }
  
  function addSpell(type, isAttacker) {
    const spellArray = isAttacker ? currentBattle.attackerSpells : currentBattle.defenderSpells;
    spellArray.push(type);
    updateSpellDisplay(isAttacker);
    updateBattleSummary();
  }
  
  function removeWeapon(index, isAttacker) {
    const weaponArray = isAttacker ? currentBattle.attackerWeapons : currentBattle.defenderWeapons;
    weaponArray.splice(index, 1);
    updateWeaponDisplay(isAttacker);
    updateBattleSummary();
  }
  
  function removeAlly(index, isAttacker) {
    const allyArray = isAttacker ? currentBattle.attackerAllies : currentBattle.defenderAllies;
    allyArray.splice(index, 1);
    updateAllyDisplay(isAttacker);
    updateBattleSummary();
  }
  
  function removeSpell(index, isAttacker) {
    const spellArray = isAttacker ? currentBattle.attackerSpells : currentBattle.defenderSpells;
    spellArray.splice(index, 1);
    updateSpellDisplay(isAttacker);
    updateBattleSummary();
  }
  
  // Make remove functions globally accessible
  window.removeWeapon = removeWeapon;
  window.removeAlly = removeAlly;
  window.removeSpell = removeSpell;
  
  function updateWeaponDisplay(isAttacker) {
    const weaponArray = isAttacker ? currentBattle.attackerWeapons : currentBattle.defenderWeapons;
    const summaryElement = isAttacker ? document.getElementById('attackerWeapons') : document.getElementById('defenderWeapons');
    const listElement = isAttacker ? document.getElementById('attackerWeaponList') : document.getElementById('defenderWeaponList');
    
    if (weaponArray.length === 0) {
      summaryElement.textContent = 'None';
      listElement.innerHTML = '';
    } else {
      summaryElement.textContent = `${weaponArray.length} weapon${weaponArray.length > 1 ? 's' : ''}`;
      
      // Create individual weapon items with remove buttons
      listElement.innerHTML = weaponArray.map((weapon, index) => {
        // Check if it's a character starting weapon first
        const weaponData = getWeaponData(weapon);
        let weaponName, weaponCost;
        
        if (weaponData.icon.includes('‚öîÔ∏è') && weaponData.power === 15) {
          // Character starting weapon
          weaponName = weaponData.name || weapon;
          weaponCost = 'Free';
        } else {
          // Regular weapon - get from button data attributes or fallback
          const weaponButton = document.querySelector(`[data-weapon-id="${weapon}"]`);
          if (weaponButton) {
            weaponName = weaponButton.textContent.split(' (')[0].replace(/[ü™ÑüëªüçÄ]/g, '').trim();
            weaponCost = weaponButton.getAttribute('data-weapon-cost') + ' pts';
          } else {
            // Fallback for generic weapons
        const weaponNames = { spear: 'Spear', crossbow: 'Crossbow', catapult: 'Catapult' };
        const weaponCosts = ECONOMY.weapons;
            weaponName = weaponNames[weapon] || weapon;
            weaponCost = weaponCosts[weapon] + ' pts';
          }
        }
        
        return `
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; padding: 4px 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
            <span>${weaponName} (${weaponCost})</span>
            <button onclick="removeWeapon(${index}, ${isAttacker})" style="background: #ef4444; color: white; border: none; padding: 2px 6px; border-radius: 4px; font-size: 12px; cursor: pointer;">√ó</button>
          </div>
        `;
      }).join('');
    }
  }
  
  function updateAllyDisplay(isAttacker) {
    const allyArray = isAttacker ? currentBattle.attackerAllies : currentBattle.defenderAllies;
    const summaryElement = isAttacker ? document.getElementById('attackerAllies') : document.getElementById('defenderAllies');
    const listElement = isAttacker ? document.getElementById('attackerAlliesList') : document.getElementById('defenderAlliesList');
    
    if (allyArray.length === 0) {
      summaryElement.textContent = 'None';
      listElement.innerHTML = '';
    } else {
      summaryElement.textContent = `${allyArray.length} all${allyArray.length > 1 ? 'ies' : 'y'}`;
      
      // Create individual ally items with remove buttons
      listElement.innerHTML = allyArray.map((ally, index) => {
        const allyNames = { phoenix: 'Phoenix', hungarian_horntail: 'Hungarian Horntail', basilisk: 'Basilisk' };
        const allyCosts = { phoenix: 150, hungarian_horntail: 200, basilisk: 250 };
        return `
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; padding: 4px 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
            <span>${allyNames[ally]} (${allyCosts[ally]} pts)</span>
            <button onclick="removeAlly(${index}, ${isAttacker})" style="background: #ef4444; color: white; border: none; padding: 2px 6px; border-radius: 4px; font-size: 12px; cursor: pointer;">√ó</button>
          </div>
        `;
      }).join('');
    }
  }
  
  function updateSpellDisplay(isAttacker) {
    const spellArray = isAttacker ? currentBattle.attackerSpells : currentBattle.defenderSpells;
    const summaryElement = isAttacker ? document.getElementById('attackerSpells') : document.getElementById('defenderSpells');
    const listElement = isAttacker ? document.getElementById('attackerSpellsList') : document.getElementById('defenderSpellsList');
    
    if (spellArray.length === 0) {
      summaryElement.textContent = 'None';
      listElement.innerHTML = '';
    } else {
      summaryElement.textContent = `${spellArray.length} spell${spellArray.length > 1 ? 's' : ''}`;
      
      // Create individual spell items with remove buttons
      listElement.innerHTML = spellArray.map((spell, index) => {
        const spellNames = { expelliarmus: 'Expelliarmus', protego: 'Protego', patronus: 'Expecto Patronum' };
        const spellCosts = { expelliarmus: 80, protego: 120, patronus: 200 };
        return `
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; padding: 4px 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
            <span>${spellNames[spell]} (${spellCosts[spell]} pts)</span>
            <button onclick="removeSpell(${index}, ${isAttacker})" style="background: #ef4444; color: white; border: none; padding: 2px 6px; border-radius: 4px; font-size: 12px; cursor: pointer;">√ó</button>
          </div>
        `;
      }).join('');
    }
  }

  function updateBattleSummary() {
    if (!currentBattle) return;
    
    // Calculate attacker power with new system
    const attackerBasePower = currentBattle.attackerMercs * 15; // Increased from 10
    
    // Calculate weapon power from multiple weapons - dynamic based on scenario
    let attackerWeaponPower = 0;
    currentBattle.attackerWeapons.forEach(weapon => {
      // Check if it's a character starting weapon first
      const weaponData = getWeaponData(weapon);
      let weaponPower = weaponData.power;
      
      // If not a character weapon, get power from button data attributes
      if (weaponPower === 15 && !weaponData.icon.includes('‚öîÔ∏è')) {
        const weaponButton = document.querySelector(`[data-weapon-id="${weapon}"]`);
        weaponPower = weaponButton ? parseInt(weaponButton.getAttribute('data-weapon-power')) || 15 : 
                     (weapon === 'spear' ? 15 : weapon === 'crossbow' ? 20 : 30);
      }
      
      attackerWeaponPower += weaponPower;
    });
    
    // Calculate ally power
    let attackerAllyPower = 0;
    currentBattle.attackerAllies.forEach(ally => {
      const allyButton = document.querySelector(`[data-ally-id="${ally}"]`);
      const allyPower = allyButton ? parseInt(allyButton.getAttribute('data-ally-power')) || 50 : 
                       (ally === 'phoenix' ? 50 : ally === 'hungarian_horntail' ? 75 : 100);
      attackerAllyPower += allyPower;
    });
    
    // Calculate spell power
    let attackerSpellPower = 0;
    currentBattle.attackerSpells.forEach(spell => {
      const spellButton = document.querySelector(`[data-spell-id="${spell}"]`);
      const spellPower = spellButton ? parseInt(spellButton.getAttribute('data-spell-power')) || 25 : 
                        (spell === 'expelliarmus' ? 25 : spell === 'protego' ? 40 : 100);
      attackerSpellPower += spellPower;
    });
    
    const attackerMercPower = attackerBasePower + attackerWeaponPower + attackerAllyPower + attackerSpellPower;
    
    // Calculate combo bonus for attacker
    const attackerItemCount = currentBattle.attackerMercs + currentBattle.attackerWeapons.length + 
                              currentBattle.attackerAllies.length + currentBattle.attackerSpells.length;
    const attackerComboBonus = attackerItemCount >= 4 ? 1.5 : 
                              attackerItemCount >= 3 ? 1.25 : 
                              attackerItemCount >= 2 ? 1.1 : 1;
    const attackerPower = attackerMercPower * attackerComboBonus;
    
    // Calculate defender power with new system
    const defenderBasePower = currentBattle.defenderMercs * 15; // Increased from 10
    
    // Calculate weapon power from multiple weapons - dynamic based on scenario
    let defenderWeaponPower = 0;
    currentBattle.defenderWeapons.forEach(weapon => {
      // Check if it's a character starting weapon first
      const weaponData = getWeaponData(weapon);
      let weaponPower = weaponData.power;
      
      // If not a character weapon, get power from button data attributes
      if (weaponPower === 15 && !weaponData.icon.includes('‚öîÔ∏è')) {
        const weaponButton = document.querySelector(`[data-weapon-id="${weapon}"]`);
        weaponPower = weaponButton ? parseInt(weaponButton.getAttribute('data-weapon-power')) || 15 : 
                     (weapon === 'spear' ? 15 : weapon === 'crossbow' ? 20 : 30);
      }
      
      defenderWeaponPower += weaponPower;
    });
    
    // Calculate ally power
    let defenderAllyPower = 0;
    currentBattle.defenderAllies.forEach(ally => {
      const allyButton = document.querySelector(`[data-ally-id="${ally}"]`);
      const allyPower = allyButton ? parseInt(allyButton.getAttribute('data-ally-power')) || 50 : 
                       (ally === 'phoenix' ? 50 : ally === 'hungarian_horntail' ? 75 : 100);
      defenderAllyPower += allyPower;
    });
    
    // Calculate spell power
    let defenderSpellPower = 0;
    currentBattle.defenderSpells.forEach(spell => {
      const spellButton = document.querySelector(`[data-spell-id="${spell}"]`);
      const spellPower = spellButton ? parseInt(spellButton.getAttribute('data-spell-power')) || 25 : 
                        (spell === 'expelliarmus' ? 25 : spell === 'protego' ? 40 : 100);
      defenderSpellPower += spellPower;
    });
    
    const defenderMercPower = defenderBasePower + defenderWeaponPower + defenderAllyPower + defenderSpellPower;
    // Calculate defender castle power - distinguish pre-built vs battle castles
    const defenderCastlePower = currentBattle.defenderCastle ? 
      (currentBattle.defenderCastle === 1 ? 150 : 
       currentBattle.defenderCastle === 2 ? 300 : 600) : 0; // Pre-built castles get 2x power
    const defenderBattleCastlePower = currentBattle.defenderBattleCastle ? 
      (currentBattle.defenderBattleCastle === 1 ? 75 : 
       currentBattle.defenderBattleCastle === 2 ? 150 : 300) : 0; // Battle castles get base power
    const defenderBaseTotal = defenderMercPower + defenderCastlePower + defenderBattleCastlePower;
    
    // Calculate combo bonus for defender
    const defenderItemCount = currentBattle.defenderMercs + 
      currentBattle.defenderWeapons.length + 
      currentBattle.defenderAllies.length + 
      currentBattle.defenderSpells.length +
      (currentBattle.defenderCastle ? 1 : 0) +
      (currentBattle.defenderBattleCastle ? 1 : 0);
    const defenderComboBonus = defenderItemCount >= 4 ? 1.5 : 
                              defenderItemCount >= 3 ? 1.25 : 
                              defenderItemCount >= 2 ? 1.1 : 1;
    const defenderPower = defenderBaseTotal * defenderComboBonus;
    
    // Check if students are in a truce
    const areInTruce = state.truces.some(truce => 
      (truce.student1 === currentBattle.attacker.gsId && truce.student2 === currentBattle.defender.gsId) ||
      (truce.student1 === currentBattle.defender.gsId && truce.student2 === currentBattle.attacker.gsId)
    );
    
    // Calculate costs
    let attackerWeaponCost = 0;
    currentBattle.attackerWeapons.forEach(weapon => {
      // Character starting weapons are free
      const weaponData = getWeaponData(weapon);
      let weaponCost = 0;
      
      // If not a character weapon, get cost from button data attributes
      if (weaponData.icon.includes('‚öîÔ∏è') && weaponData.power === 15) {
        const weaponButton = document.querySelector(`[data-weapon-id="${weapon}"]`);
        weaponCost = weaponButton ? parseInt(weaponButton.getAttribute('data-weapon-cost')) || 30 : 
                    (weapon === 'spear' ? getActiveEconomy().weapons.spear : weapon === 'crossbow' ? getActiveEconomy().weapons.crossbow : weapon === 'catapult' ? getActiveEconomy().weapons.catapult : 0);
      }
      
      attackerWeaponCost += weaponCost;
    });
    
    let defenderWeaponCost = 0;
    currentBattle.defenderWeapons.forEach(weapon => {
      // Character starting weapons are free
      const weaponData = getWeaponData(weapon);
      let weaponCost = 0;
      
      // If not a character weapon, get cost from button data attributes
      if (weaponData.icon.includes('‚öîÔ∏è') && weaponData.power === 15) {
        const weaponButton = document.querySelector(`[data-weapon-id="${weapon}"]`);
        weaponCost = weaponButton ? parseInt(weaponButton.getAttribute('data-weapon-cost')) || 30 : 
                    (weapon === 'spear' ? getActiveEconomy().weapons.spear : weapon === 'crossbow' ? getActiveEconomy().weapons.crossbow : weapon === 'catapult' ? getActiveEconomy().weapons.catapult : 0);
      }
      
      defenderWeaponCost += weaponCost;
    });
    
    // Calculate ally costs
    let attackerAllyCost = 0;
    currentBattle.attackerAllies.forEach(ally => {
      const allyButton = document.querySelector(`[data-ally-id="${ally}"]`);
      const allyCost = allyButton ? parseInt(allyButton.getAttribute('data-ally-cost')) || 150 : 
                       (ally === 'phoenix' ? 150 : ally === 'hungarian_horntail' ? 200 : 250);
      attackerAllyCost += allyCost;
    });
    
    let defenderAllyCost = 0;
    currentBattle.defenderAllies.forEach(ally => {
      const allyButton = document.querySelector(`[data-ally-id="${ally}"]`);
      const allyCost = allyButton ? parseInt(allyButton.getAttribute('data-ally-cost')) || 150 : 
                       (ally === 'phoenix' ? 150 : ally === 'hungarian_horntail' ? 200 : 250);
      defenderAllyCost += allyCost;
    });
    
    // Calculate spell costs
    let attackerSpellCost = 0;
    currentBattle.attackerSpells.forEach(spell => {
      const spellButton = document.querySelector(`[data-spell-id="${spell}"]`);
      const spellCost = spellButton ? parseInt(spellButton.getAttribute('data-spell-cost')) || 80 : 
                        (spell === 'expelliarmus' ? 80 : spell === 'protego' ? 120 : 200);
      attackerSpellCost += spellCost;
    });
    
    let defenderSpellCost = 0;
    currentBattle.defenderSpells.forEach(spell => {
      const spellButton = document.querySelector(`[data-spell-id="${spell}"]`);
      const spellCost = spellButton ? parseInt(spellButton.getAttribute('data-spell-cost')) || 80 : 
                        (spell === 'expelliarmus' ? 80 : spell === 'protego' ? 120 : 200);
      defenderSpellCost += spellCost;
    });
    
    let attackerCost = currentBattle.attackerMercs * getActiveEconomy().mercCost + attackerWeaponCost + attackerAllyCost + attackerSpellCost;
  let defenderCost = currentBattle.defenderMercs * getActiveEconomy().mercCost + defenderWeaponCost + defenderAllyCost + defenderSpellCost +
      (currentBattle.defenderBattleCastle === 1 ? getActiveEconomy().castleL1 : 
       currentBattle.defenderBattleCastle === 2 ? getActiveEconomy().castleL2 : 
       currentBattle.defenderBattleCastle === 3 ? getActiveEconomy().castleL3 : 0);
    
    // If students are in a truce, allow resource sharing with limits
    if (areInTruce) {
      const totalCost = attackerCost + defenderCost;
      const attackerBalance = currentBattle.attacker.balance;
      const defenderBalance = currentBattle.defender.balance;
      const totalBalance = attackerBalance + defenderBalance;
      
      // Limit money sharing to 50% of each student's balance
      const maxAttackerShare = Math.min(attackerCost, attackerBalance * 0.5);
      const maxDefenderShare = Math.min(defenderCost, defenderBalance * 0.5);
      
      // If total cost exceeds individual limits but is within combined limits, share costs
      if (attackerCost > attackerBalance || defenderCost > defenderBalance) {
        if (totalCost <= totalBalance) {
          // Distribute costs proportionally, respecting individual limits
          const attackerShare = Math.min(attackerCost, maxAttackerShare + (totalCost - maxAttackerShare - maxDefenderShare) * 0.5);
          const defenderShare = Math.min(defenderCost, maxDefenderShare + (totalCost - maxAttackerShare - maxDefenderShare) * 0.5);
          
          attackerCost = attackerShare;
          defenderCost = defenderShare;
        }
      }
    }
    
    // Calculate victory odds
    const totalPower = attackerPower + defenderPower;
    const attackerOdds = totalPower > 0 ? (attackerPower / totalPower) * 100 : 50;
    
    // Update display
    document.getElementById('attackerPower').textContent = attackerPower.toFixed(1);
    document.getElementById('defenderPower').textContent = defenderPower.toFixed(1);
    document.getElementById('attackerCost').textContent = attackerCost;
    document.getElementById('defenderCost').textContent = defenderCost;
    document.getElementById('victoryOdds').textContent = `Victory Odds: ${attackerOdds.toFixed(1)}%`;
    
    // Update balances in real-time
    document.getElementById('attackerBalance').textContent = currentBattle.attacker.balance - attackerCost;
    document.getElementById('defenderBalance').textContent = currentBattle.defender.balance - defenderCost;
    
    // Color code the odds
    const oddsElement = document.getElementById('victoryOdds');
    if (attackerOdds > 60) {
      oddsElement.style.color = '#10b981'; // Green for attacker advantage
    } else if (attackerOdds < 40) {
      oddsElement.style.color = '#ef4444'; // Red for defender advantage
    } else {
      oddsElement.style.color = '#facc15'; // Yellow for balanced
    }
  }
  
  // Fight screen event listeners
  document.getElementById('fightClose').onclick = () => {
    document.getElementById('fightModal').classList.remove('show');
    currentBattle = null;
    
    // Resume AI stipend ticker after battle
    resumeAiStipendTicker();
  };
  
  // Attacker mercenaries
  document.getElementById('attackerMercPlus').onclick = () => {
    if (currentBattle.attackerMercs < 20) {
      currentBattle.attackerMercs++;
      document.getElementById('attackerMercCount').textContent = currentBattle.attackerMercs;
      updateBattleSummary();
    }
  };
  
  document.getElementById('attackerMercMinus').onclick = () => {
    if (currentBattle.attackerMercs > 0) {
      currentBattle.attackerMercs--;
      document.getElementById('attackerMercCount').textContent = currentBattle.attackerMercs;
      updateBattleSummary();
    }
  };
  
  // Defender mercenaries
  document.getElementById('defenderMercPlus').onclick = () => {
    if (currentBattle.defenderMercs < 20) {
      currentBattle.defenderMercs++;
      document.getElementById('defenderMercCount').textContent = currentBattle.defenderMercs;
      updateBattleSummary();
    }
  };
  
  document.getElementById('defenderMercMinus').onclick = () => {
    if (currentBattle.defenderMercs > 0) {
      currentBattle.defenderMercs--;
      document.getElementById('defenderMercCount').textContent = currentBattle.defenderMercs;
      updateBattleSummary();
    }
  };
  
  // Attacker weapons - dynamic based on scenario
  document.getElementById('attackerSpear').onclick = () => {
    const weaponId = document.getElementById('attackerSpear').getAttribute('data-weapon-id') || 'spear';
    addWeapon(weaponId, true);
  };
  
  document.getElementById('attackerCrossbow').onclick = () => {
    const weaponId = document.getElementById('attackerCrossbow').getAttribute('data-weapon-id') || 'crossbow';
    addWeapon(weaponId, true);
  };
  
  document.getElementById('attackerCatapult').onclick = () => {
    const weaponId = document.getElementById('attackerCatapult').getAttribute('data-weapon-id') || 'catapult';
    addWeapon(weaponId, true);
  };
  
  // Defender weapons - dynamic based on scenario
  document.getElementById('defenderSpear').onclick = () => {
    const weaponId = document.getElementById('defenderSpear').getAttribute('data-weapon-id') || 'spear';
    addWeapon(weaponId, false);
  };
  
  document.getElementById('defenderCrossbow').onclick = () => {
    const weaponId = document.getElementById('defenderCrossbow').getAttribute('data-weapon-id') || 'crossbow';
    addWeapon(weaponId, false);
  };
  
  document.getElementById('defenderCatapult').onclick = () => {
    const weaponId = document.getElementById('defenderCatapult').getAttribute('data-weapon-id') || 'catapult';
    addWeapon(weaponId, false);
  };
  
  // Attacker allies - dynamic based on scenario
  document.getElementById('attackerPhoenix').onclick = () => {
    const allyId = document.getElementById('attackerPhoenix').getAttribute('data-ally-id') || 'phoenix';
    addAlly(allyId, true);
  };
  
  document.getElementById('attackerHorntail').onclick = () => {
    const allyId = document.getElementById('attackerHorntail').getAttribute('data-ally-id') || 'hungarian_horntail';
    addAlly(allyId, true);
  };
  
  document.getElementById('attackerBasilisk').onclick = () => {
    const allyId = document.getElementById('attackerBasilisk').getAttribute('data-ally-id') || 'basilisk';
    addAlly(allyId, true);
  };
  
  // Defender allies - dynamic based on scenario
  document.getElementById('defenderPhoenix').onclick = () => {
    const allyId = document.getElementById('defenderPhoenix').getAttribute('data-ally-id') || 'phoenix';
    addAlly(allyId, false);
  };
  
  document.getElementById('defenderHorntail').onclick = () => {
    const allyId = document.getElementById('defenderHorntail').getAttribute('data-ally-id') || 'hungarian_horntail';
    addAlly(allyId, false);
  };
  
  document.getElementById('defenderBasilisk').onclick = () => {
    const allyId = document.getElementById('defenderBasilisk').getAttribute('data-ally-id') || 'basilisk';
    addAlly(allyId, false);
  };
  
  // Attacker spells - dynamic based on scenario
  document.getElementById('attackerExpelliarmus').onclick = () => {
    const spellId = document.getElementById('attackerExpelliarmus').getAttribute('data-spell-id') || 'expelliarmus';
    addSpell(spellId, true);
  };
  
  document.getElementById('attackerProtego').onclick = () => {
    const spellId = document.getElementById('attackerProtego').getAttribute('data-spell-id') || 'protego';
    addSpell(spellId, true);
  };
  
  document.getElementById('attackerPatronus').onclick = () => {
    const spellId = document.getElementById('attackerPatronus').getAttribute('data-spell-id') || 'patronus';
    addSpell(spellId, true);
  };
  
  // Defender spells - dynamic based on scenario
  document.getElementById('defenderExpelliarmus').onclick = () => {
    const spellId = document.getElementById('defenderExpelliarmus').getAttribute('data-spell-id') || 'expelliarmus';
    addSpell(spellId, false);
  };
  
  document.getElementById('defenderProtego').onclick = () => {
    const spellId = document.getElementById('defenderProtego').getAttribute('data-spell-id') || 'protego';
    addSpell(spellId, false);
  };
  
  document.getElementById('defenderPatronus').onclick = () => {
    const spellId = document.getElementById('defenderPatronus').getAttribute('data-spell-id') || 'patronus';
    addSpell(spellId, false);
  };
  
  document.getElementById('removeDefenderCastle').onclick = () => {
    currentBattle.defenderBattleCastle = null;
    document.getElementById('defenderCastle').textContent = 'None';
    updateBattleSummary();
  };
  
  // Defender castles (battle-screen castles)
  document.getElementById('defenderCastle1').onclick = () => {
    currentBattle.defenderBattleCastle = 1;
    document.getElementById('defenderCastle').textContent = 'Wooden Keep (Battle)';
    updateBattleSummary();
  };
  
  document.getElementById('defenderCastle2').onclick = () => {
    currentBattle.defenderBattleCastle = 2;
    document.getElementById('defenderCastle').textContent = 'Stone Fortress (Battle)';
    updateBattleSummary();
  };
  
  document.getElementById('defenderCastle3').onclick = () => {
    currentBattle.defenderBattleCastle = 3;
    document.getElementById('defenderCastle').textContent = 'Iron Citadel (Battle)';
    updateBattleSummary();
  };
  // Simulate war button
  document.getElementById('simulateWar').onclick = async () => {
    if (!currentBattle) return;
    
    // Calculate weapon costs for multiple weapons
    let attackerWeaponCost = 0;
    currentBattle.attackerWeapons.forEach(weapon => {
      // Character starting weapons are free
      const weaponData = getWeaponData(weapon);
      let weaponCost = 0;
      
      // If not a character weapon, get cost from button data attributes
      if (weaponData.icon.includes('‚öîÔ∏è') && weaponData.power === 15) {
        const weaponButton = document.querySelector(`[data-weapon-id="${weapon}"]`);
        weaponCost = weaponButton ? parseInt(weaponButton.getAttribute('data-weapon-cost')) || 30 : 
                    (weapon === 'spear' ? getActiveEconomy().weapons.spear : weapon === 'crossbow' ? getActiveEconomy().weapons.crossbow : weapon === 'catapult' ? getActiveEconomy().weapons.catapult : 0);
      }
      
      attackerWeaponCost += weaponCost;
    });
    
    let defenderWeaponCost = 0;
    currentBattle.defenderWeapons.forEach(weapon => {
      // Character starting weapons are free
      const weaponData = getWeaponData(weapon);
      let weaponCost = 0;
      
      // If not a character weapon, get cost from button data attributes
      if (weaponData.icon.includes('‚öîÔ∏è') && weaponData.power === 15) {
        const weaponButton = document.querySelector(`[data-weapon-id="${weapon}"]`);
        weaponCost = weaponButton ? parseInt(weaponButton.getAttribute('data-weapon-cost')) || 30 : 
                    (weapon === 'spear' ? getActiveEconomy().weapons.spear : weapon === 'crossbow' ? getActiveEconomy().weapons.crossbow : weapon === 'catapult' ? getActiveEconomy().weapons.catapult : 0);
      }
      
      defenderWeaponCost += weaponCost;
    });
    
    // Calculate ally costs
    let attackerAllyCost = 0;
    currentBattle.attackerAllies.forEach(ally => {
      const allyButton = document.querySelector(`[data-ally-id="${ally}"]`);
      const allyCost = allyButton ? parseInt(allyButton.getAttribute('data-ally-cost')) || 150 : 
                       (ally === 'phoenix' ? 150 : ally === 'hungarian_horntail' ? 200 : 250);
      attackerAllyCost += allyCost;
    });
    
    let defenderAllyCost = 0;
    currentBattle.defenderAllies.forEach(ally => {
      const allyButton = document.querySelector(`[data-ally-id="${ally}"]`);
      const allyCost = allyButton ? parseInt(allyButton.getAttribute('data-ally-cost')) || 150 : 
                       (ally === 'phoenix' ? 150 : ally === 'hungarian_horntail' ? 200 : 250);
      defenderAllyCost += allyCost;
    });
    
    // Calculate spell costs
    let attackerSpellCost = 0;
    currentBattle.attackerSpells.forEach(spell => {
      const spellButton = document.querySelector(`[data-spell-id="${spell}"]`);
      const spellCost = spellButton ? parseInt(spellButton.getAttribute('data-spell-cost')) || 80 : 
                        (spell === 'expelliarmus' ? 80 : spell === 'protego' ? 120 : 200);
      attackerSpellCost += spellCost;
    });
    
    let defenderSpellCost = 0;
    currentBattle.defenderSpells.forEach(spell => {
      const spellButton = document.querySelector(`[data-spell-id="${spell}"]`);
      const spellCost = spellButton ? parseInt(spellButton.getAttribute('data-spell-cost')) || 80 : 
                        (spell === 'expelliarmus' ? 80 : spell === 'protego' ? 120 : 200);
      defenderSpellCost += spellCost;
    });
    
    let attackerCost = currentBattle.attackerMercs * getActiveEconomy().mercCost + attackerWeaponCost + attackerAllyCost + attackerSpellCost;
    let defenderCost = currentBattle.defenderMercs * getActiveEconomy().mercCost + defenderWeaponCost + defenderAllyCost + defenderSpellCost +
      (currentBattle.defenderBattleCastle === 1 ? getActiveEconomy().castleL1 : 
       currentBattle.defenderBattleCastle === 2 ? getActiveEconomy().castleL2 : 
       currentBattle.defenderBattleCastle === 3 ? getActiveEconomy().castleL3 : 0);
    
    // Check if students are in a truce and implement resource sharing
    const areInTruce = state.truces.some(truce => 
      (truce.student1 === currentBattle.attacker.gsId && truce.student2 === currentBattle.defender.gsId) ||
      (truce.student1 === currentBattle.defender.gsId && truce.student2 === currentBattle.attacker.gsId)
    );
    
    if (areInTruce) {
      const totalCost = attackerCost + defenderCost;
      const attackerBalance = currentBattle.attacker.balance;
      const defenderBalance = currentBattle.defender.balance;
      const totalBalance = attackerBalance + defenderBalance;
      
      // Limit money sharing to 50% of each student's balance
      const maxAttackerShare = Math.min(attackerCost, attackerBalance * 0.5);
      const maxDefenderShare = Math.min(defenderCost, defenderBalance * 0.5);
      
      // If total cost exceeds individual limits but is within combined limits, share costs
      if (attackerCost > attackerBalance || defenderCost > defenderBalance) {
        if (totalCost <= totalBalance) {
          // Distribute costs proportionally, respecting individual limits
          const attackerShare = Math.min(attackerCost, maxAttackerShare + (totalCost - maxAttackerShare - maxDefenderShare) * 0.5);
          const defenderShare = Math.min(defenderCost, maxDefenderShare + (totalCost - maxAttackerShare - maxDefenderShare) * 0.5);
          
          attackerCost = attackerShare;
          defenderCost = defenderShare;
        }
      }
    }
    
    // Check if students/teams have enough points for the battle
    let attackerCanAfford = false;
    let defenderCanAfford = false;
    
    if (state.teamMode && currentBattle.attacker.teamId) {
      // Team mode - check team resources
      attackerCanAfford = canTeamAffordCost(currentBattle.attacker.teamId, attackerCost);
      if (!attackerCanAfford) {
        const teamResources = getTeamResources(currentBattle.attacker.teamId);
        alert(`Insufficient team funds! ${currentBattle.attacker.teamName} needs ${attackerCost} points but has ${teamResources.totalBalance}.`);
        return;
      }
    } else {
      // Individual mode - check individual resources
      const attackerBalanceAfterCost = currentBattle.attacker.balance - attackerCost;
      attackerCanAfford = attackerBalanceAfterCost >= 0;
      if (!attackerCanAfford) {
        alert(`Insufficient funds! ${currentBattle.attacker.name} needs ${attackerCost} points but has ${currentBattle.attacker.balance}.`);
        return;
      }
    }
    
    if (state.teamMode && currentBattle.defender.teamId) {
      // Team mode - check team resources
      defenderCanAfford = canTeamAffordCost(currentBattle.defender.teamId, defenderCost);
      if (!defenderCanAfford) {
        const teamResources = getTeamResources(currentBattle.defender.teamId);
        alert(`Insufficient team funds! ${currentBattle.defender.teamName} needs ${defenderCost} points but has ${teamResources.totalBalance}.`);
        return;
      }
    } else {
      // Individual mode - check individual resources
      const defenderBalanceAfterCost = currentBattle.defender.balance - defenderCost;
      defenderCanAfford = defenderBalanceAfterCost >= 0;
      if (!defenderCanAfford) {
        alert(`Insufficient funds! ${currentBattle.defender.name} needs ${defenderCost} points but has ${currentBattle.defender.balance}.`);
        return;
      }
    }
    
    // Close modal
    document.getElementById('fightModal').classList.remove('show');
    
    // Resume AI stipend ticker after battle
    resumeAiStipendTicker();
    
    // Show battle animation
    showBattleAnimation();
    
    // Simulate battle after animation
    setTimeout(() => {
      simulateBattle();
    }, 3000);
  };
  
  function showBattleAnimation() {
    // Create battle animation overlay
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      font-size: 48px;
      color: white;
      text-align: center;
    `;
    
    overlay.innerHTML = `
      <div>
        <div style="font-size: 72px; margin-bottom: 20px;">‚öîÔ∏è</div>
        <div>${currentBattle.attacker.name} vs ${currentBattle.defender.name}</div>
        <div style="font-size: 24px; margin-top: 20px;">Battle in progress...</div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    
    setTimeout(() => {
      document.body.removeChild(overlay);
    }, 3000);
  }
  
  async function simulateBattle() {
    if (!currentBattle) return;
    
    // Calculate attacker power with new system
    const attackerBasePower = currentBattle.attackerMercs * 15;
    
    // Calculate weapon power from multiple weapons
    let attackerWeaponPower = 0;
    currentBattle.attackerWeapons.forEach(weapon => {
      const weaponPower = weapon === 'spear' ? 15 : 
                         weapon === 'crossbow' ? 20 : 30; // Base power per weapon
      attackerWeaponPower += weaponPower;
    });
    
    const attackerMercPower = attackerBasePower + attackerWeaponPower;
    
    // Calculate combo bonus for attacker
    const attackerItemCount = currentBattle.attackerMercs + currentBattle.attackerWeapons.length;
    const attackerComboBonus = attackerItemCount >= 4 ? 1.5 : 
                              attackerItemCount >= 3 ? 1.25 : 
                              attackerItemCount >= 2 ? 1.1 : 1;
    const attackerPower = attackerMercPower * attackerComboBonus;
    
    // Calculate defender power with new system
    const defenderBasePower = currentBattle.defenderMercs * 15;
    
    // Calculate weapon power from multiple weapons
    let defenderWeaponPower = 0;
    currentBattle.defenderWeapons.forEach(weapon => {
      const weaponPower = weapon === 'spear' ? 15 : 
                         weapon === 'crossbow' ? 20 : 30; // Base power per weapon
      defenderWeaponPower += weaponPower;
    });
    
    const defenderMercPower = defenderBasePower + defenderWeaponPower;
    // Calculate defender castle power - distinguish pre-built vs battle castles
    const defenderCastlePower = currentBattle.defenderCastle ? 
      (currentBattle.defenderCastle === 1 ? 150 : 
       currentBattle.defenderCastle === 2 ? 300 : 600) : 0; // Pre-built castles get 2x power
    const defenderBattleCastlePower = currentBattle.defenderBattleCastle ? 
      (currentBattle.defenderBattleCastle === 1 ? 75 : 
       currentBattle.defenderBattleCastle === 2 ? 150 : 300) : 0; // Battle castles get base power
    const defenderBaseTotal = defenderMercPower + defenderCastlePower + defenderBattleCastlePower;
    
    // Calculate combo bonus for defender
    const defenderItemCount = currentBattle.defenderMercs + 
      currentBattle.defenderWeapons.length + 
      currentBattle.defenderAllies.length + 
      currentBattle.defenderSpells.length +
      (currentBattle.defenderCastle ? 1 : 0) +
      (currentBattle.defenderBattleCastle ? 1 : 0);
    const defenderComboBonus = defenderItemCount >= 4 ? 1.5 : 
                              defenderItemCount >= 3 ? 1.25 : 
                              defenderItemCount >= 2 ? 1.1 : 1;
    const defenderPower = defenderBaseTotal * defenderComboBonus;
    
    const odds = attackerPower / (attackerPower + defenderPower);
    const roll = Math.random();
    const attackerWins = roll < odds;
    
    // Calculate costs
    let attackerWeaponCost = 0;
    currentBattle.attackerWeapons.forEach(weapon => {
      // Character starting weapons are free
      const weaponData = getWeaponData(weapon);
      let weaponCost = 0;
      
      // If not a character weapon, get cost from button data attributes
      if (weaponData.icon.includes('‚öîÔ∏è') && weaponData.power === 15) {
        const weaponButton = document.querySelector(`[data-weapon-id="${weapon}"]`);
        weaponCost = weaponButton ? parseInt(weaponButton.getAttribute('data-weapon-cost')) || 30 : 
                    (weapon === 'spear' ? 30 : weapon === 'crossbow' ? 60 : weapon === 'catapult' ? 100 : 0);
      }
      
      attackerWeaponCost += weaponCost;
    });
    
    let defenderWeaponCost = 0;
    currentBattle.defenderWeapons.forEach(weapon => {
      // Character starting weapons are free
      const weaponData = getWeaponData(weapon);
      let weaponCost = 0;
      
      // If not a character weapon, get cost from button data attributes
      if (weaponData.icon.includes('‚öîÔ∏è') && weaponData.power === 15) {
        const weaponButton = document.querySelector(`[data-weapon-id="${weapon}"]`);
        weaponCost = weaponButton ? parseInt(weaponButton.getAttribute('data-weapon-cost')) || 30 : 
                    (weapon === 'spear' ? 30 : weapon === 'crossbow' ? 60 : weapon === 'catapult' ? 100 : 0);
      }
      
      defenderWeaponCost += weaponCost;
    });
    
    // Calculate ally costs
    let attackerAllyCost = 0;
    currentBattle.attackerAllies.forEach(ally => {
      const allyButton = document.querySelector(`[data-ally-id="${ally}"]`);
      const allyCost = allyButton ? parseInt(allyButton.getAttribute('data-ally-cost')) || 150 : 
                       (ally === 'phoenix' ? 150 : ally === 'hungarian_horntail' ? 200 : 250);
      attackerAllyCost += allyCost;
    });
    
    let defenderAllyCost = 0;
    currentBattle.defenderAllies.forEach(ally => {
      const allyButton = document.querySelector(`[data-ally-id="${ally}"]`);
      const allyCost = allyButton ? parseInt(allyButton.getAttribute('data-ally-cost')) || 150 : 
                       (ally === 'phoenix' ? 150 : ally === 'hungarian_horntail' ? 200 : 250);
      defenderAllyCost += allyCost;
    });
    
    // Calculate spell costs
    let attackerSpellCost = 0;
    currentBattle.attackerSpells.forEach(spell => {
      const spellButton = document.querySelector(`[data-spell-id="${spell}"]`);
      const spellCost = spellButton ? parseInt(spellButton.getAttribute('data-spell-cost')) || 80 : 
                        (spell === 'expelliarmus' ? 80 : spell === 'protego' ? 120 : 200);
      attackerSpellCost += spellCost;
    });
    
    let defenderSpellCost = 0;
    currentBattle.defenderSpells.forEach(spell => {
      const spellButton = document.querySelector(`[data-spell-id="${spell}"]`);
      const spellCost = spellButton ? parseInt(spellButton.getAttribute('data-spell-cost')) || 80 : 
                        (spell === 'expelliarmus' ? 80 : spell === 'protego' ? 120 : 200);
      defenderSpellCost += spellCost;
    });
    
    const attackerCost = currentBattle.attackerMercs * getActiveEconomy().mercCost + attackerWeaponCost + attackerAllyCost + attackerSpellCost;
  const defenderCost = currentBattle.defenderMercs * getActiveEconomy().mercCost + defenderWeaponCost + defenderAllyCost + defenderSpellCost +
      (currentBattle.defenderBattleCastle === 1 ? getActiveEconomy().castleL1 : 
       currentBattle.defenderBattleCastle === 2 ? getActiveEconomy().castleL2 : 
       currentBattle.defenderBattleCastle === 3 ? getActiveEconomy().castleL3 : 0);
    
    // Apply battle results to current roster system
    // Check if students are in a truce for resource sharing
    const areInTruce = state.truces.some(truce => 
      (truce.student1 === currentBattle.attacker.gsId && truce.student2 === currentBattle.defender.gsId) ||
      (truce.student1 === currentBattle.defender.gsId && truce.student2 === currentBattle.attacker.gsId)
    );
    
    if (areInTruce) {
      // Truce resource sharing - weapons and mercenaries are free, only share money costs
      const attackerMoneyCost = currentBattle.attackerMercs * getActiveEconomy().mercCost; // Only mercenary money cost
      const defenderMoneyCost = currentBattle.defenderMercs * getActiveEconomy().mercCost +
        (currentBattle.defenderBattleCastle === 1 ? getActiveEconomy().castleL1 : 
         currentBattle.defenderBattleCastle === 2 ? getActiveEconomy().castleL2 : 
         currentBattle.defenderBattleCastle === 3 ? getActiveEconomy().castleL3 : 0); // Only mercenary and castle money costs
      
      const totalMoneyCost = attackerMoneyCost + defenderMoneyCost;
      const attackerBalance = currentBattle.attacker.balance;
      const defenderBalance = currentBattle.defender.balance;
      const totalBalance = attackerBalance + defenderBalance;
      
      if (totalMoneyCost <= totalBalance) {
        // Distribute money costs proportionally
        const attackerMoneyShare = Math.min(attackerMoneyCost, attackerBalance * 0.5);
        const defenderMoneyShare = Math.min(defenderMoneyCost, defenderBalance * 0.5);
        const remainingCost = totalMoneyCost - attackerMoneyShare - defenderMoneyShare;
        
        const attackerFinalShare = attackerMoneyShare + (remainingCost * 0.5);
        const defenderFinalShare = defenderMoneyCost + (remainingCost * 0.5);
        
        currentBattle.attacker.balance -= attackerFinalShare;
        currentBattle.defender.balance -= defenderFinalShare;
      } else {
        // Not enough combined funds
        alert(`Insufficient combined funds! Need ${totalMoneyCost} points but have ${totalBalance}.`);
        return;
      }
    } else {
      // Normal cost deduction
      if (state.teamMode && currentBattle.attacker.teamId) {
        // Team mode - deduct from team resources
        deductTeamCost(currentBattle.attacker.teamId, attackerCost, 'attack');
      } else {
        // Individual mode - deduct from individual balance
        currentBattle.attacker.balance -= attackerCost;
      }
      
      if (state.teamMode && currentBattle.defender.teamId) {
        // Team mode - deduct from team resources
        deductTeamCost(currentBattle.defender.teamId, defenderCost, 'defense');
      } else {
        // Individual mode - deduct from individual balance
        currentBattle.defender.balance -= defenderCost;
      }
    }
    
    // Auto-save points after battle
    try {
      await autoSaveWarPoints();
      console.log('Battle results saved successfully');
    } catch (error) {
      console.error('Error saving battle results:', error);
      // Force save to localStorage as fallback
      localStorage.setItem('tornadoRosters', JSON.stringify(state.rosters));
      console.log('Battle results saved to localStorage as fallback');
    }
    
    // Force update the display immediately after battle
    updateGridDisplay();
    syncTileCounts();
    updateVictoryTarget();
    updateTeamScoreboards();
    
    if (attackerWins) {
      // Attacker takes the tile
      console.log(`Battle result: ${currentBattle.attacker.name} wins! Taking tile from ${currentBattle.defender.name}`);
      console.log(`Tile before: owner=${currentBattle.tile.owner_game_student_id}, castle=${currentBattle.tile.castle_level}`);
      
      currentBattle.tile.owner_game_student_id = currentBattle.attacker.gsId;
      currentBattle.tile.castle_level = 0; // Destroy castle
      
      console.log(`Tile after: owner=${currentBattle.tile.owner_game_student_id}, castle=${currentBattle.tile.castle_level}`);
      
      // Update tile counts
      currentBattle.attacker.tilesOwned += 1;
      currentBattle.defender.tilesOwned = Math.max(0, currentBattle.defender.tilesOwned - 1);
      
      console.log(`Tile counts: ${currentBattle.attacker.name}=${currentBattle.attacker.tilesOwned}, ${currentBattle.defender.name}=${currentBattle.defender.tilesOwned}`);
    } else {
      console.log(`Battle result: ${currentBattle.defender.name} wins! Defends tile from ${currentBattle.attacker.name}`);
    }
    
    // Save the updated roster
    if (state.currentRoster) {
      // Update the roster data
      const attackerIndex = state.currentRoster.roster.findIndex(r => r.name === currentBattle.attacker.name);
      const defenderIndex = state.currentRoster.roster.findIndex(r => r.name === currentBattle.defender.name);
      
      if (attackerIndex >= 0) {
        state.currentRoster.roster[attackerIndex].points = currentBattle.attacker.balance;
      }
      if (defenderIndex >= 0) {
        state.currentRoster.roster[defenderIndex].points = currentBattle.defender.balance;
      }
      
      // Save game state to roster
      state.currentRoster.gameState = {
        board: state.board,
        tiles: state.board.tiles,
        truces: state.truces || []
      };
      
      // Save to localStorage
      const rosters = JSON.parse(localStorage.getItem('tornadoRosters') || '[]');
      const rosterIndex = rosters.findIndex(r => r.id === state.currentRoster.id);
      if (rosterIndex >= 0) {
        rosters[rosterIndex] = state.currentRoster;
        localStorage.setItem('tornadoRosters', JSON.stringify(rosters));
      }
    }
    
    // Show result
    const attackerWeaponText = currentBattle.attackerWeapon ? ` with ${currentBattle.attackerWeapon}` : '';
    const defenderWeaponText = currentBattle.defenderWeapon ? ` with ${currentBattle.defenderWeapon}` : '';
    const castleText = currentBattle.defenderCastle ? ` (Castle L${currentBattle.defenderCastle})` : '';
    
    alert(`‚öîÔ∏è BATTLE RESULT ‚öîÔ∏è\n\n` +
          `${currentBattle.attacker.name}${attackerWeaponText}: ${attackerPower.toFixed(1)} power\n` +
          `${currentBattle.defender.name}${defenderWeaponText}${castleText}: ${defenderPower.toFixed(1)} power\n\n` +
          `Odds: ${(odds*100).toFixed(1)}% ¬∑ Roll: ${roll.toFixed(2)}\n\n` +
          `üèÜ ${attackerWins ? currentBattle.attacker.name : currentBattle.defender.name} WINS! üèÜ\n\n` +
          `Costs: ${currentBattle.attacker.name} paid ${attackerCost} points, ${currentBattle.defender.name} paid ${defenderCost} points`);
    
    // Update the display
    updateGridDisplay();
    syncTileCounts();
    updateVictoryTarget();
    updateTeamScoreboards();
    
    // Check for victory condition after battle
    checkVictoryCondition();
    
    currentBattle = null;
  }

  // === TEAM COLOR CHANGE FUNCTIONALITY ===
  window.changeTeamColor = function(studentId) {
    const student = state.roster.find(r => r.gsId === studentId);
    if (!student || !student.teamId) return;
    
    const currentGame = state.localGames.find(g => g.id === state.gameId);
    if (!currentGame) return;
    
    // Show color picker
    const colorPicker = document.createElement('div');
    colorPicker.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    `;
    
    colorPicker.innerHTML = `
      <h3 style="margin: 0 0 15px 0;">Change Team Color</h3>
      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        ${teamColors.map(color => 
          `<div class="color-option" style="background-color: ${color}; width: 30px; height: 30px;" 
               data-color="${color}"></div>`
        ).join('')}
      </div>
      <button onclick="this.parentElement.remove()" style="margin-top: 15px; padding: 8px 16px; background: var(--accent); color: white; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
    `;
    
    document.body.appendChild(colorPicker);
    
    // Add click handlers for color selection
    colorPicker.querySelectorAll('.color-option').forEach(option => {
      option.addEventListener('click', () => {
        const newColor = option.dataset.color;
        
        // Update team color in game data
        const team = currentGame.teams.find(t => t.id === student.teamId);
        if (team) {
          team.color = newColor;
        }
        
        // Update all students in this team
        currentGame.roster.forEach(r => {
          if (r.teamId === student.teamId) {
            r.teamColor = newColor;
          }
        });
        
        // Save and refresh
        saveLocalGame(currentGame);
        renderRoster();
        loadTiles(); // Refresh tile colors
        
        document.body.removeChild(colorPicker);
      });
    });
  };


  // Initialize team mode sections

  // Check if we're coming from a roster page with a specific roster
  function checkForRosterFromRosterPage() {
    const currentRosterData = localStorage.getItem('currentRoster');
    if (currentRosterData) {
      try {
        const roster = JSON.parse(currentRosterData);
        console.log('Loading roster from roster page:', roster.name);
        
        // Load the roster
        loadRoster(roster.id);
        
        // Clear the temporary storage
        localStorage.removeItem('currentRoster');
        
        // Show scenario info if it exists
        if (roster.scenario) {
          showScenarioInfo(roster.scenario);
        }
        
        return true;
      } catch (error) {
        console.error('Error loading roster from roster page:', error);
        localStorage.removeItem('currentRoster');
      }
    }
    return false;
  }

  // Create a default roster when none exist
  async function createDefaultRoster() {
    console.log('Creating default roster...');
    
    const defaultRoster = {
      id: 'default-roster-' + Date.now(),
      name: 'Quick Start Roster',
      roster: [
        { name: 'Student 1', points: 10 },
        { name: 'Student 2', points: 10 },
        { name: 'Student 3', points: 10 },
        { name: 'Student 4', points: 10 }
      ],
      created: new Date().toISOString(),
      isQuickRoster: true
    };
    
    // Add to rosters
    state.rosters.push(defaultRoster);
    
    // Save to localStorage
    localStorage.setItem('tornadoRosters', JSON.stringify(state.rosters));
    
    // Save to Supabase if logged in
    if (state.session && !state.offlineMode) {
      try {
        const { error } = await supabase.from('rosters').upsert({
          id: defaultRoster.id,
          teacher_id: state.session.user.id,
          name: defaultRoster.name,
          data: defaultRoster,
          last_modified: new Date().toISOString()
        });
        if (error) {
          console.error('Supabase error in createDefaultRoster:', error);
          // Graceful fallback if table missing
          if (error.code === 'PGRST205' || /Could not find the table 'public.rosters'/.test(error.message||'')) {
            console.warn("Supabase 'rosters' table missing. Saved locally only.");
          }
        } else {
          console.log('Default roster saved to Supabase');
        }
      } catch (error) {
        console.error('Error saving default roster to Supabase:', error);
        // Continue with local save even if Supabase fails
      }
    }
    
    // Update UI
    rosterList.innerHTML = `<option value="">Select Roster‚Ä¶</option>` + (state.rosters.map(r =>
      `<option value="${r.id}">${r.name} (${r.roster ? r.roster.length : 0} students)${r.isQuickRoster ? ' üéÆ' : ''}</option>`
    ).join(""));
    
    // Select the default roster
    rosterList.value = defaultRoster.id;
    selectRoster(defaultRoster.id);
    
    console.log('Default roster created and selected');
  }
  function createRandomTeams() {
    if (!state.roster || state.roster.length < 2) {
      alert('Need at least 2 students to create teams!');
      return;
    }
    
    const numTeams = prompt('How many teams? (2-6)', '2');
    if (!numTeams || numTeams < 2 || numTeams > 6) return;
    
    const numTeamsInt = parseInt(numTeams);
    const students = [...state.roster];
    const teams = [];
    
    // Define team colors
    const teamColors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'];
    
    // Create teams
    for (let i = 0; i < numTeamsInt; i++) {
      teams.push({
        id: String.fromCharCode(65 + i), // A, B, C, etc.
        name: `Team ${String.fromCharCode(65 + i)}`,
        color: teamColors[i] || '#6b7280',
        students: []
      });
    }
    
    // Randomly assign students to teams
    const shuffled = [...students].sort(() => Math.random() - 0.5);
    shuffled.forEach((student, index) => {
      const teamIndex = index % numTeamsInt;
      teams[teamIndex].students.push(student.name);
      
      // Update student data
      student.teamId = teams[teamIndex].id;
      student.teamName = teams[teamIndex].name;
      student.teamColor = teams[teamIndex].color;
    });
    
    // Update roster with team information
    if (state.currentRoster) {
      state.currentRoster.teams = teams;
      state.currentRoster.teamMode = true;
      state.teamMode = true;
      
      // Save updated roster
      localStorage.setItem('tornadoRosters', JSON.stringify(state.rosters));
    }
    
    // Refresh display
    renderRoster();
    updateGridDisplay();
    
    alert(`Teams created! ${teams.map(t => `${t.name}: ${t.students.join(', ')}`).join('\n')}`);
  }
  
  // Show scenario information
  function showScenarioInfo(scenarioData) {
    const scenarioInfo = document.createElement('div');
    scenarioInfo.id = 'scenarioInfo';
    scenarioInfo.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 15px;
      border-radius: 10px;
      z-index: 1000;
      max-width: 300px;
      font-size: 14px;
    `;
    
    scenarioInfo.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h3 style="margin: 0; color: #ffd700;">${scenarioData.scenarioName}</h3>
        <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: white; font-size: 18px; cursor: pointer;">&times;</button>
      </div>
      <p style="margin: 0 0 10px 0; color: #ccc;">${scenarioData.scenarioType === 'historical' ? 'üèõÔ∏è Historical War' : 'üìö Literary Story'}</p>
      <div style="margin-bottom: 10px;">
        <strong style="color: #ffd700;">Factions:</strong>
        ${Object.values(scenarioData.factions).map(faction => 
          `<div style="margin: 5px 0; padding: 5px; background: ${faction.color}20; border-radius: 5px;">
            <span style="color: ${faction.color}; font-weight: bold;">${faction.name}</span>
          </div>`
        ).join('')}
      </div>
      ${scenarioData.enableAI ? '<p style="margin: 0; color: #4ade80;">ü§ñ AI opponents enabled</p>' : ''}
    `;
    
    document.body.appendChild(scenarioInfo);
    
    // Auto-hide after 10 seconds
    setTimeout(() => {
      if (scenarioInfo.parentElement) {
        scenarioInfo.remove();
      }
    }, 10000);
  }

  // initial load
  async function initializeApp() {
  const loadedFromRosterPage = checkForRosterFromRosterPage();
  if (!loadedFromRosterPage) {
      await loadRosters(true);
      
      // If no rosters exist, create a default one
      if (state.rosters.length === 0) {
        await createDefaultRoster();
      }
    }
  }
  
  // Start the app
  initializeApp();

  // Listen for roster updates from student war game
  window.addEventListener('storage', async function(e) {
    if (e.key === 'tornadoRosters' || e.key === 'rosterUpdateTrigger') {
      // Reload rosters when they're updated
      await loadRosters(true);
    }
  });

  // Listen for custom roster update events
  window.addEventListener('rosterUpdated', async function(e) {
    console.log('Roster updated from another tab:', e.detail);
    await loadRosters(true);
  });

  // Listen for truce updates from other tabs
  window.addEventListener('storage', function(e) {
    if (e.key === 'truceUpdateTrigger') {
      console.log('Truce update detected from another tab');
      // Reload truce data from localStorage
      const rosters = JSON.parse(localStorage.getItem('tornadoRosters') || '[]');
      const rosterIndex = rosters.findIndex(r => r.id === state.currentRosterId);
      if (rosterIndex !== -1) {
        state.truces = rosters[rosterIndex].truces || [];
        state.truceInvitations = rosters[rosterIndex].truceInvitations || [];
        console.log('Truce data reloaded:', { truces: state.truces.length, invitations: state.truceInvitations.length });
      }
    }
  });

  // Listen for custom truce events
  window.addEventListener('truceUpdated', function(e) {
    console.log('Truce event received:', e.detail);
    // Refresh any open truce modals
    const openModal = document.querySelector('div[style*="position: fixed"]');
    if (openModal && openModal.innerHTML.includes('Truce Management')) {
      openModal.remove();
      if (state.selectedGsId) {
        showTeacherTruceModal();
      }
    }
  });

  // Polling mechanism to check for truce updates
  let lastTruceCheck = Date.now();
  setInterval(function() {
    if (!state.currentRosterId) return;
    
    const rosters = JSON.parse(localStorage.getItem('tornadoRosters') || '[]');
    const rosterIndex = rosters.findIndex(r => r.id === state.currentRosterId);
    if (rosterIndex === -1) return;
    
    const savedTruces = rosters[rosterIndex].truces || [];
    const savedInvitations = rosters[rosterIndex].truceInvitations || [];
    
    // Check if truce data has changed
    const currentTruceCount = state.truces.length;
    const currentInvitationCount = (state.truceInvitations || []).length;
    const savedTruceCount = savedTruces.length;
    const savedInvitationCount = savedInvitations.length;
    
    if (currentTruceCount !== savedTruceCount || currentInvitationCount !== savedInvitationCount) {
      console.log('Teacher: Truce data changed, updating...', {
        truces: `${currentTruceCount} ‚Üí ${savedTruceCount}`,
        invitations: `${currentInvitationCount} ‚Üí ${savedInvitationCount}`
      });
      
      state.truces = savedTruces;
      state.truceInvitations = savedInvitations;
      
      // Refresh any open truce modals
      const openModal = document.querySelector('div[style*="position: fixed"]');
      if (openModal && openModal.innerHTML.includes('Truce Management')) {
        openModal.remove();
        if (state.selectedGsId) {
          showTeacherTruceModal();
        }
      }
    }
  }, 2000); // Check every 2 seconds

  // Check for updates when tab becomes visible
  document.addEventListener('visibilitychange', function() {
    if (!document.hidden && state.currentRosterId) {
      console.log('Teacher: Tab became visible, checking for truce updates...');
      // Trigger immediate check
      const rosters = JSON.parse(localStorage.getItem('tornadoRosters') || '[]');
      const rosterIndex = rosters.findIndex(r => r.id === state.currentRosterId);
      if (rosterIndex !== -1) {
        state.truces = rosters[rosterIndex].truces || [];
        state.truceInvitations = rosters[rosterIndex].truceInvitations || [];
        
        // Refresh any open truce modals
        const openModal = document.querySelector('div[style*="position: fixed"]');
        if (openModal && openModal.innerHTML.includes('Truce Management')) {
          openModal.remove();
          if (state.selectedGsId) {
            showTeacherTruceModal();
          }
        }
      }
    }
  });

  function showNewGameModal() {
    const modal = document.createElement('div');
    modal.id = 'newGameModal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    `;
    
    modal.innerHTML = `
      <div style="
        background: white;
        border-radius: 16px;
        padding: 2rem;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: #1e293b; font-size: 1.5rem;">üéÆ Start New Game</h2>
          <button onclick="closeNewGameModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b;">&times;</button>
        </div>
        
        <p style="margin-bottom: 1.5rem; color: #64748b;">
          Choose the mode and type of game you want to start with your current roster:
        </p>
        
        <div style="margin-bottom: 1.5rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">Game Mode:</label>
          <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
            <button id="schoolModeBtn" class="mode-btn active" style="
              flex: 1;
              padding: 0.75rem;
              background: #6f5c91;
              color: white;
              border: none;
              border-radius: 6px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s ease;
            ">üè´ School Mode</button>
            <button id="businessModeBtn" class="mode-btn" style="
              flex: 1;
              padding: 0.75rem;
              background: #64748b;
              color: white;
              border: none;
              border-radius: 6px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s ease;
            ">üè¢ Business Mode</button>
          </div>
        </div>
        
        <div style="margin-bottom: 1.5rem;">
          <button id="regularGameBtn" style="
            width: 100%;
            padding: 1rem;
            margin-bottom: 1rem;
            background: #6f5c91;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
          ">üéØ Regular Game</button>
          
          <p style="margin: 0 0 1rem 0; color: #64748b; font-size: 0.9rem;">
            <span class="mode-text-school">Standard Tornado War with your current roster. Students play as themselves with basic resources.</span>
            <span class="mode-text-business" style="display: none;">Standard Tornado War with your current roster. Employees compete with basic resources and metrics.</span>
          </p>
        </div>
        
        <div style="margin-bottom: 1.5rem;">
          <button id="scenarioGameBtn" style="
            width: 100%;
            padding: 1rem;
            margin-bottom: 1rem;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
          ">üìö Historical/Literary Scenario</button>
          
          <p style="margin: 0 0 1rem 0; color: #64748b; font-size: 0.9rem;">
            <span class="mode-text-school">Choose from 22 historical wars and literary stories. Students get authentic roles with period-appropriate weapons and personalities.</span>
            <span class="mode-text-business" style="display: none;">Choose from historical scenarios adapted for business contexts. Employees take on strategic roles with performance metrics.</span>
          </p>
        </div>
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="closeNewGameModal()" style="
            background: #64748b;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Cancel</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Add hover effects
    const regularBtn = document.getElementById('regularGameBtn');
    const scenarioBtn = document.getElementById('scenarioGameBtn');
    
    regularBtn.onmouseover = () => regularBtn.style.transform = 'translateY(-2px)';
    regularBtn.onmouseout = () => regularBtn.style.transform = 'translateY(0)';
    scenarioBtn.onmouseover = () => scenarioBtn.style.transform = 'translateY(-2px)';
    scenarioBtn.onmouseout = () => scenarioBtn.style.transform = 'translateY(0)';
    
    // Add click handlers
    // Mode switching logic
    const schoolModeBtn = document.getElementById('schoolModeBtn');
    const businessModeBtn = document.getElementById('businessModeBtn');
    let currentMode = 'school';
    
    schoolModeBtn.onclick = () => {
      currentMode = 'school';
      schoolModeBtn.style.background = '#6f5c91';
      businessModeBtn.style.background = '#64748b';
      schoolModeBtn.classList.add('active');
      businessModeBtn.classList.remove('active');
      
      // Update text visibility
      document.querySelectorAll('.mode-text-school').forEach(el => el.style.display = 'inline');
      document.querySelectorAll('.mode-text-business').forEach(el => el.style.display = 'none');
    };
    
    businessModeBtn.onclick = () => {
      currentMode = 'business';
      businessModeBtn.style.background = '#6f5c91';
      schoolModeBtn.style.background = '#64748b';
      businessModeBtn.classList.add('active');
      schoolModeBtn.classList.remove('active');
      
      // Update text visibility
      document.querySelectorAll('.mode-text-business').forEach(el => el.style.display = 'inline');
      document.querySelectorAll('.mode-text-school').forEach(el => el.style.display = 'none');
    };
    
    regularBtn.onclick = () => {
      closeNewGameModal();
      showDifficultySelectionModal('regular', currentMode);
    };
    
    scenarioBtn.onclick = () => {
      closeNewGameModal();
      // Add a small delay to ensure scenarios.js is loaded
      setTimeout(() => {
      showScenarioSelectionModal(currentMode);
      }, 100);
    };
  }
  
  function closeNewGameModal() {
    const modal = document.getElementById('newGameModal');
    if (modal) {
      modal.remove();
    }
  }
  
  function startRegularGame() {
    if (!confirm('Are you sure you want to start a new regular game? This will reset ALL game progress including:\n\n‚Ä¢ All territory ownership\n‚Ä¢ All castle levels\n‚Ä¢ All student balances\n‚Ä¢ All truces\n‚Ä¢ All game state\n\nThis action cannot be undone!')) {
      return;
    }
    
    // Clear any existing scenario data
    state.scenario = null;
    
    // Update game theme title
    updateGameThemeTitle();
    
    // Hide AI and educational controls
    const aiControls = document.getElementById('aiControls');
    const educationalControls = document.getElementById('educationalControls');
    if (aiControls) aiControls.style.display = 'none';
    if (educationalControls) educationalControls.style.display = 'none';
    
    resetGameToDefaults();
  }
  
  function showScenarioSelectionModal() {
    // Clear any existing scenario data when opening scenario selection
    if (state.currentRoster && state.currentRoster.scenario) {
      console.log('Clearing existing scenario data before scenario selection');
      delete state.currentRoster.scenario;
      state.scenario = null;
      
      // Clear character assignments
      state.roster.forEach(student => {
        student.characterName = null;
        student.characterRole = null;
        student.characterFaction = null;
        student.teamId = null;
        student.teamName = null;
        student.teamColor = null;
      });
      
      // Clear AI players
      state.aiPlayers = [];
      
      // Update game theme title
      updateGameThemeTitle();
      
      // Save the cleared roster (if function exists)
      if (typeof saveRoster === 'function') {
        saveRoster();
      }
    }
    
    // Check if scenarios are loaded
    if (typeof SCENARIOS === 'undefined') {
      console.error('SCENARIOS object not loaded yet!');
      alert('Scenarios are still loading. Please wait a moment and try again.');
      return;
    }
    
    console.log('Available scenarios:', Object.keys(SCENARIOS));
    
    const modal = document.createElement('div');
    modal.id = 'scenarioSelectionModal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1001;
    `;
    
    modal.innerHTML = `
      <div style="
        background: white;
        border-radius: 16px;
        padding: 2rem;
        max-width: 800px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: #1e293b; font-size: 1.5rem;">üìö Choose Scenario</h2>
          <button onclick="closeScenarioSelectionModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b;">&times;</button>
        </div>
        
        <p style="margin-bottom: 1.5rem; color: #64748b;">
          Select a historical war or literary story for your game:
        </p>
        
        <div style="margin-bottom: 1.5rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">Choose Scenario:</label>
          <select id="scenarioSelect" style="
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            margin-bottom: 1rem;
          ">
            <option value="">Select a scenario...</option>
            <optgroup label="üèõÔ∏è Historical Wars">
              <option value="americanRevolution">American Revolutionary War</option>
              <option value="civilWar">American Civil War</option>
              <option value="warOf1812">War of 1812</option>
              <option value="mexicanAmerican">Mexican-American War</option>
              <option value="spanishAmerican">Spanish-American War</option>
              <option value="worldWar1">World War 1</option>
              <option value="worldWar2">World War 2</option>
              <option value="crusades">The Crusades</option>
              <option value="hundredYearsWar">Hundred Years' War</option>
              <option value="russianCivilWar">Russian Civil War</option>
              <option value="spanishCivilWar">Spanish Civil War</option>
            </optgroup>
            <optgroup label="üìö Literature">
              <option value="juliusCaesar">Julius Caesar (Shakespeare)</option>
              <option value="animalFarm">Animal Farm (George Orwell)</option>
              <option value="nineteenEightyFour">1984 (George Orwell)</option>
              <option value="theIliad">The Iliad (Homer)</option>
              <option value="romeoAndJuliet">Romeo and Juliet (Shakespeare)</option>
              <option value="lordOfTheRings">The Lord of the Rings (J.R.R. Tolkien)</option>
              <option value="harryPotter">Harry Potter (J.K. Rowling)</option>
              <option value="dune">Dune (Frank Herbert)</option>
            </optgroup>
            <optgroup label="üé¨ Movies">
              <option value="avengers">Avengers</option>
              <option value="starWars">Star Wars</option>
              <option value="dcVsMarvel">DC vs Marvel</option>
              <option value="frozen">Frozen</option>
              <option value="minions">Minions</option>
              <option value="toyStory">Toy Story</option>
              <option value="moana">Moana</option>
            </optgroup>
            <optgroup label="üéÆ Gaming">
              <option value="pokemon">Pokemon: Fire vs Water vs Grass</option>
              <option value="superMario">Super Mario: Heroes vs Minions</option>
              <option value="fortniteVsMinecraft">Fortnite vs Minecraft</option>
            </optgroup>
            <optgroup label="üèõÔ∏è Mythology">
              <option value="greekMythology">Greek Mythology</option>
              <option value="romanMythology">Roman Mythology</option>
              <option value="percyJackson">Percy Jackson</option>
              <option value="monsterWars">Monster Wars</option>
              <option value="avatar">Avatar: The Last Airbender</option>
            </optgroup>
            <optgroup label="üèÄ Sports">
              <option value="nbaLegends">NBA Legends</option>
              <option value="nflLegends">NFL Legends</option>
              <option value="soccerLegends">International Soccer Legends</option>
            </optgroup>
            <optgroup label="üéµ Music">
              <option value="musicLegends">Rock vs Pop vs Rap</option>
            </optgroup>
            <optgroup label="üì∫ TV & Movies">
              <option value="disneyVsPixar">Disney Vs Pixar</option>
              <option value="gameOfThrones">Game of Thrones</option>
              <option value="hungerGames">Hunger Games</option>
            </optgroup>
            <optgroup label="üé® Custom Scenarios">
              <option value="custom">Create Custom Scenario</option>
            </optgroup>
          </select>
        </div>
        
        <div id="scenarioOptions">
            <div id="scenarioDetails" style="display: none;">
            <div id="scenarioInfo" style="
              background: #f8fafc;
              border: 1px solid #e2e8f0;
              border-radius: 8px;
              padding: 1rem;
              margin-bottom: 1rem;
            ">
              <h4 id="scenarioTitle" style="margin: 0 0 0.5rem 0; color: #1e293b;"></h4>
              <p id="scenarioDescription" style="margin: 0 0 0.5rem 0; color: #64748b;"></p>
              <div id="factionsPreview"></div>
                <div id="aiStatusBadge" style="display:none; margin-top: 8px; font-weight:600; color:#065f46; background:#d1fae5; border:1px solid #10b981; padding:4px 8px; border-radius:6px; width:max-content;">Class vs AI ON</div>
            </div>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">Role Assignment:</label>
              <div style="margin-bottom: 0.5rem;">
                <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
                  <input type="radio" name="roleAssignment" value="random" checked style="margin-right: 0.5rem;">
                  <span style="color: #1e293b;">Randomly assign students to factions</span>
                </label>
                <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
                  <input type="radio" name="roleAssignment" value="manual" style="margin-right: 0.5rem;">
                  <span style="color: #1e293b;">Manually assign students to roles</span>
                </label>
              </div>
            </div>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
                <input type="checkbox" id="enableAI" style="margin-right: 0.5rem;">
                <span style="font-weight: 600; color: #1e293b;">Class vs AI</span>
              </label>
            </div>
            
            <div id="aiOptions" style="display: none;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">AI Difficulty:</label>
              <select id="aiDifficulty" style="
                width: 100%;
                padding: 0.75rem;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 1rem;
                margin-bottom: 1rem;
              ">
                <option value="easy">Easy</option>
                <option value="medium" selected>Medium</option>
                <option value="hard">Hard</option>
              </select>
            </div>
          </div>
        </div>
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="closeScenarioSelectionModal()" style="
            background: #64748b;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Cancel</button>
          <button id="startScenarioGameBtn" onclick="startScenarioGame()" style="
            background: #10b981;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
          " disabled>Start Scenario Game</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Setup AI options toggle
    document.getElementById('enableAI').onchange = function() {
      const aiOptions = document.getElementById('aiOptions');
      aiOptions.style.display = this.checked ? 'block' : 'none';
    const badge = document.getElementById('aiStatusBadge');
    if (badge) badge.style.display = this.checked ? 'inline-block' : 'none';
    };
    
    // Setup scenario selection change handler
    document.getElementById('scenarioSelect').onchange = updateScenarioDetails;
  }
  
  window.closeScenarioSelectionModal = function() {
    const modal = document.getElementById('scenarioSelectionModal');
    if (modal) {
      modal.remove();
    }
  }
  function updateScenarioDetails() {
    const scenarioId = document.getElementById('scenarioSelect').value;
    const scenarioDetails = document.getElementById('scenarioDetails');
    const startBtn = document.getElementById('startScenarioGameBtn');
    
    console.log('updateScenarioDetails called with scenarioId:', scenarioId);
    console.log('SCENARIOS object available:', typeof SCENARIOS !== 'undefined');
    
    if (scenarioId === 'custom') {
      // Show custom scenario option
      document.getElementById('scenarioTitle').textContent = 'Create Custom Scenario';
      document.getElementById('scenarioDescription').textContent = 'Design your own scenario with custom factions, characters, and territories.';
      document.getElementById('factionsPreview').innerHTML = '<strong>Custom Scenario Builder:</strong><br>You will create your own factions, characters, and territories.';
      
      scenarioDetails.style.display = 'block';
      startBtn.disabled = false;
      startBtn.textContent = 'Open Custom Builder';
    } else if (scenarioId && typeof SCENARIOS !== 'undefined' && SCENARIOS[scenarioId]) {
      const scenario = SCENARIOS[scenarioId];
      console.log('Found scenario:', scenario.name);
      console.log('Scenario factions:', Object.keys(scenario.factions));
      
      // Update scenario info
      document.getElementById('scenarioTitle').textContent = scenario.name;
      document.getElementById('scenarioDescription').textContent = scenario.description;
      
      // Update factions preview
      const factionsPreview = document.getElementById('factionsPreview');
      factionsPreview.innerHTML = '<strong>Factions:</strong><br>';
      Object.values(scenario.factions).forEach(faction => {
        factionsPreview.innerHTML += `<div style="margin: 5px 0; padding: 5px; background: ${faction.color}20; border-radius: 5px;">
          <span style="color: ${faction.color}; font-weight: bold;">${faction.name}</span>
        </div>`;
      });
      
      scenarioDetails.style.display = 'block';
      startBtn.disabled = false;
      startBtn.textContent = 'Start Scenario Game';
    } else {
      console.log('Scenario not found or SCENARIOS not loaded. scenarioId:', scenarioId);
      if (typeof SCENARIOS !== 'undefined') {
        console.log('Available scenarios:', Object.keys(SCENARIOS));
      }
      scenarioDetails.style.display = 'none';
      startBtn.disabled = true;
      startBtn.textContent = 'Start Scenario Game';
    }
  }
  
  
  window.startScenarioGame = function() {
    const scenarioId = document.getElementById('scenarioSelect').value;
    const enableAI = document.getElementById('enableAI').checked;
    const aiDifficulty = document.getElementById('aiDifficulty').value;
    const roleAssignment = document.querySelector('input[name="roleAssignment"]:checked').value;
    
    if (!scenarioId) {
      alert('Please select a scenario.');
      return;
    }

    // Store scenario settings temporarily
    window.tempScenarioSettings = {
      scenarioId,
      enableAI,
      aiDifficulty,
      roleAssignment
    };

    // Close scenario modal and show difficulty selection
    closeScenarioSelectionModal();
    showDifficultySelectionModal('scenario');
  };

  // === STORY EVENTS FUNCTIONALITY ===
  
  // Story Events data structure
  const STORY_EVENTS = {
    'romeo_juliet': {
      name: 'Romeo & Juliet',
      scenes: [
        {
          id: 'act1_scene1',
          name: 'Act 1, Scene 1: Street Fight',
          summary: 'A street fight breaks out between Montague and Capulet servants. Benvolio tries to stop it, but Tybalt escalates the violence. Prince Escalus arrives and threatens death for future fights.',
          effects: [
            {
              type: 'character_points',
              character: 'Benvolio',
              points: 50,
              reason: 'Shows wisdom and peacemaking by trying to stop the fight. His calm approach demonstrates leadership qualities.'
            },
            {
              type: 'character_points', 
              character: 'Tybalt',
              points: -30,
              reason: 'Escalates violence and shows hot-headedness. His aggressive behavior brings shame to his family.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: -25,
              reason: 'Their servants started the street fight, bringing dishonor to the Montague name. The Prince\'s threat affects the whole family.'
            },
            {
              type: 'team_points',
              team: 'Capulet', 
              points: -25,
              reason: 'Their servants participated in the street fight, bringing dishonor to the Capulet name. The Prince\'s threat affects the whole family.'
            },
            {
              type: 'character_points',
              character: 'Prince Escalus',
              points: 40,
              reason: 'Shows strong leadership by stopping the fight and delivering justice. His authority brings order to Verona.'
            }
          ]
        },
        {
          id: 'act1_scene2',
          name: 'Act 1, Scene 2: Paris Asks for Juliet',
          summary: 'Paris asks Capulet for Juliet\'s hand in marriage. Capulet suggests Paris woo Juliet at the upcoming party.',
          effects: [
            {
              type: 'character_points',
              character: 'Paris',
              points: 35,
              reason: 'Shows proper courtship by asking permission first. His respectful approach demonstrates noble character.'
            },
            {
              type: 'character_points',
              character: 'Capulet',
              points: 25,
              reason: 'Shows wisdom by delaying the marriage and letting Juliet choose. His fatherly care protects Juliet\'s happiness.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: 20,
              reason: 'The family gains respect through Paris\'s noble courtship and Capulet\'s wise parenting. This brings honor to the Capulet house.'
            },
            {
              type: 'character_points',
              character: 'Juliet',
              points: 15,
              reason: 'Her father\'s protection shows she is valued and cared for, even though she doesn\'t know it yet.'
            }
          ]
        },
        {
          id: 'act1_scene3',
          name: 'Act 1, Scene 3: Lady Capulet & Nurse',
          summary: 'Lady Capulet and the Nurse discuss Juliet\'s upcoming marriage to Paris. Juliet is obedient but not enthusiastic.',
          effects: [
            {
              type: 'character_points',
              character: 'Juliet',
              points: 30,
              reason: 'Shows obedience and respect to her mother and family. Her dutiful nature demonstrates good character.'
            },
            {
              type: 'character_points',
              character: 'Nurse',
              points: 20,
              reason: 'Shows loyalty and support for Juliet\'s family. Her caring nature and long service bring honor.'
            },
            {
              type: 'character_points',
              character: 'Lady Capulet',
              points: 15,
              reason: 'Takes an active role in her daughter\'s future. Her involvement shows maternal care and family responsibility.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: 15,
              reason: 'The family unity and care for Juliet\'s future shows strong family bonds and noble intentions.'
            }
          ]
        },
        {
          id: 'act1_scene4',
          name: 'Act 1, Scene 4: Queen Mab Speech',
          summary: 'Mercutio delivers his famous Queen Mab speech about dreams, showing his wit and imagination.',
          effects: [
            {
              type: 'character_points',
              character: 'Mercutio',
              points: 50,
              reason: 'Delivers one of Shakespeare\'s most famous speeches, showing incredible wit, creativity, and poetic genius.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: 25,
              reason: 'Mercutio\'s brilliant speech brings great honor to the Montague faction. His wit makes the whole family proud.'
            },
            {
              type: 'character_points',
              character: 'Romeo',
              points: 15,
              reason: 'Benefits from Mercutio\'s friendship and wit. Having such a talented friend reflects well on Romeo.'
            },
            {
              type: 'character_points',
              character: 'Benvolio',
              points: 10,
              reason: 'As part of the Montague group, he shares in the honor brought by Mercutio\'s performance.'
            }
          ]
        },
        {
          id: 'act1_scene5',
          name: 'Act 1, Scene 5: Romeo & Juliet Meet',
          summary: 'Romeo and Juliet meet at the Capulet party and fall in love at first sight. Tybalt recognizes Romeo and wants to fight.',
          effects: [
            {
              type: 'character_points',
              character: 'Romeo',
              points: 70,
              reason: 'Finds true love and experiences the most powerful emotion possible. His pure love brings him great joy and purpose.'
            },
            {
              type: 'character_points',
              character: 'Juliet',
              points: 70,
              reason: 'Finds true love and experiences the most powerful emotion possible. Her pure love brings her great joy and purpose.'
            },
            {
              type: 'character_points',
              character: 'Tybalt',
              points: -50,
              reason: 'Wants to fight at a peaceful party, showing poor judgment and hot-headedness. His aggression threatens family honor.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: -30,
              reason: 'Tybalt\'s violent intentions at their own party bring shame to the Capulet family. His behavior reflects poorly on everyone.'
            },
            {
              type: 'character_points',
              character: 'Capulet',
              points: -20,
              reason: 'As head of the family, Tybalt\'s poor behavior reflects on his leadership. He should control his nephew better.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: 20,
              reason: 'Romeo\'s pure love and romantic nature brings honor to the Montague family. His genuine feelings show good character.'
            }
          ]
        },
        
        // ACT 2
        {
          id: 'act2_scene1_2',
          name: 'Act 2, Scenes 1-2: Balcony Scene',
          summary: 'Romeo sneaks into Capulet\'s orchard and overhears Juliet declaring her love. They exchange vows of love on the balcony.',
          effects: [
            {
              type: 'character_points',
              character: 'Romeo',
              points: 80,
              reason: 'Shows incredible courage by risking his life to see Juliet. His devotion and romantic bravery are inspiring.'
            },
            {
              type: 'character_points',
              character: 'Juliet',
              points: 80,
              reason: 'Shows remarkable courage by declaring her love despite the danger. Her honesty and passion are admirable.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: 30,
              reason: 'Romeo\'s romantic courage brings honor to the Montague family. His devotion shows the family\'s capacity for true love.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: 30,
              reason: 'Juliet\'s courage and honesty bring honor to the Capulet family. Her strength shows the family\'s noble character.'
            }
          ]
        },
        {
          id: 'act2_scene3',
          name: 'Act 2, Scene 3: Friar Laurence\'s Plan',
          summary: 'Romeo asks Friar Laurence to marry him and Juliet. The Friar agrees, hoping to end the feud between families.',
          effects: [
            {
              type: 'character_points',
              character: 'Friar Laurence',
              points: 60,
              reason: 'Shows wisdom and compassion by agreeing to marry the lovers. His plan to end the feud demonstrates noble intentions.'
            },
            {
              type: 'character_points',
              character: 'Romeo',
              points: 40,
              reason: 'Shows maturity by seeking proper marriage. His commitment to Juliet demonstrates his serious intentions.'
            },
            {
              type: 'character_points',
              character: 'Juliet',
              points: 40,
              reason: 'Her love inspires Romeo to seek marriage, showing her positive influence and the power of true love.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: 20,
              reason: 'Romeo\'s desire for proper marriage shows the Montague family\'s respect for tradition and honor.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: 20,
              reason: 'Juliet\'s influence leads to Romeo seeking marriage, showing the Capulet family\'s positive impact on others.'
            }
          ]
        },
        {
          id: 'act2_scene4_5',
          name: 'Act 2, Scenes 4-5: The Nurse as Messenger',
          summary: 'Mercutio and Benvolio tease Romeo about his love. The Nurse delivers messages between Romeo and Juliet about their wedding.',
          effects: [
            {
              type: 'character_points',
              character: 'Nurse',
              points: 45,
              reason: 'Shows incredible loyalty by risking her position to help Juliet. Her devotion to Juliet\'s happiness is admirable.'
            },
            {
              type: 'character_points',
              character: 'Mercutio',
              points: 25,
              reason: 'Shows friendship by teasing Romeo playfully. His wit and humor bring joy to his friends.'
            },
            {
              type: 'character_points',
              character: 'Benvolio',
              points: 20,
              reason: 'Shows loyalty to Romeo by supporting him. His friendship demonstrates the Montague family\'s strong bonds.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: 25,
              reason: 'The Nurse\'s loyalty to Juliet shows the Capulet family\'s ability to inspire deep devotion from their servants.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: 15,
              reason: 'Mercutio and Benvolio\'s friendship shows the Montague family\'s strong bonds and loyalty to each other.'
            }
          ]
        },
        {
          id: 'act2_scene6',
          name: 'Act 2, Scene 6: Secret Marriage',
          summary: 'Romeo and Juliet are secretly married by Friar Laurence. The lovers are overjoyed but know their families would disapprove.',
          effects: [
            {
              type: 'character_points',
              character: 'Romeo',
              points: 100,
              reason: 'Achieves his greatest dream by marrying his true love. This moment represents the pinnacle of romantic fulfillment.'
            },
            {
              type: 'character_points',
              character: 'Juliet',
              points: 100,
              reason: 'Achieves her greatest dream by marrying her true love. This moment represents the pinnacle of romantic fulfillment.'
            },
            {
              type: 'character_points',
              character: 'Friar Laurence',
              points: 70,
              reason: 'Performs a sacred act of love by uniting the lovers. His compassion and wisdom are at their highest point.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: 40,
              reason: 'Romeo\'s marriage represents the family\'s capacity for true love and commitment. His happiness brings honor to all Montagues.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: 40,
              reason: 'Juliet\'s marriage represents the family\'s capacity for true love and commitment. Her happiness brings honor to all Capulets.'
            }
          ]
        },
        
        // ACT 3
        {
          id: 'act3_scene1',
          name: 'Act 3, Scene 1: Mercutio and Tybalt Die',
          summary: 'Tybalt kills Mercutio in a duel, then Romeo kills Tybalt in revenge. Romeo is banished from Verona.',
          effects: [
            {
              type: 'character_points',
              character: 'Mercutio',
              points: -200,
              reason: 'Dies defending Romeo\'s honor. His death is tragic but shows his ultimate loyalty to his friend.'
            },
            {
              type: 'character_points',
              character: 'Tybalt',
              points: -200,
              reason: 'Dies after killing Mercutio. His violent nature leads to his own destruction and brings shame to his family.'
            },
            {
              type: 'character_points',
              character: 'Romeo',
              points: -150,
              reason: 'Kills Tybalt in revenge, leading to his banishment. His hot-headedness destroys his chance for happiness.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: -80,
              reason: 'Loses Mercutio, their greatest wit, and Romeo is banished. The family suffers terrible losses due to violence.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: -80,
              reason: 'Loses Tybalt, their fiercest warrior. The family suffers from the violence that Tybalt\'s aggression caused.'
            },
            {
              type: 'character_points',
              character: 'Prince Escalus',
              points: -30,
              reason: 'Must banish Romeo, showing that even his authority cannot prevent the tragic consequences of the feud.'
            }
          ]
        },
        {
          id: 'act3_scene2_3',
          name: 'Act 3, Scenes 2-3: Juliet\'s Grief & Romeo\'s Despair',
          summary: 'Juliet learns of Tybalt\'s death and Romeo\'s banishment. She grieves for Tybalt but loves Romeo. Romeo despairs with Friar Laurence.',
          effects: [
            {
              type: 'character_points',
              character: 'Juliet',
              points: -60,
              reason: 'Suffers terrible grief from losing her cousin and facing Romeo\'s banishment. Her heart is torn between love and family.'
            },
            {
              type: 'character_points',
              character: 'Romeo',
              points: -40,
              reason: 'Faces banishment and separation from Juliet. His despair shows the depth of his love but also his emotional instability.'
            },
            {
              type: 'character_points',
              character: 'Friar Laurence',
              points: 30,
              reason: 'Shows compassion by comforting Romeo and offering hope. His wisdom helps Romeo see beyond his immediate despair.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: -25,
              reason: 'Juliet\'s grief affects the whole family. The loss of Tybalt and Juliet\'s suffering brings sorrow to all Capulets.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: -25,
              reason: 'Romeo\'s banishment and despair affect the whole family. The loss of their son brings sorrow to all Montagues.'
            }
          ]
        },
        {
          id: 'act3_scene4_5',
          name: 'Act 3, Scenes 4-5: Wedding Plans & Farewell',
          summary: 'Capulet arranges Juliet\'s marriage to Paris. Romeo and Juliet spend their last night together before his banishment.',
          effects: [
            {
              type: 'character_points',
              character: 'Capulet',
              points: -40,
              reason: 'Forces Juliet into marriage without considering her feelings. His authoritarian behavior shows poor parenting.'
            },
            {
              type: 'character_points',
              character: 'Juliet',
              points: -50,
              reason: 'Faces forced marriage while secretly married to Romeo. Her situation becomes increasingly desperate and tragic.'
            },
            {
              type: 'character_points',
              character: 'Romeo',
              points: -30,
              reason: 'Must leave Juliet forever. His banishment separates him from his true love, causing immense suffering.'
            },
            {
              type: 'character_points',
              character: 'Paris',
              points: -20,
              reason: 'Unknowingly becomes part of forcing Juliet into an unwanted marriage. His good intentions lead to harm.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: -35,
              reason: 'Capulet\'s forced marriage plan creates family conflict and shows poor leadership. The family\'s unity is threatened.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: -20,
              reason: 'Romeo\'s banishment removes their son from the family. The Montagues lose their heir and suffer from the separation.'
            }
          ]
        },
        
        // ACT 4
        {
          id: 'act4_scene1_2',
          name: 'Act 4, Scenes 1-2: The Potion Plan',
          summary: 'Friar Laurence gives Juliet a sleeping potion to fake her death. Juliet agrees to the desperate plan to avoid marrying Paris.',
          effects: [
            {
              type: 'character_points',
              character: 'Juliet',
              points: -80,
              reason: 'Agrees to fake her own death, showing how desperate her situation has become. Her courage is admirable but tragic.'
            },
            {
              type: 'character_points',
              character: 'Friar Laurence',
              points: -30,
              reason: 'Creates a dangerous plan that could easily go wrong. His desperation leads to risky decisions.'
            },
            {
              type: 'character_points',
              character: 'Capulet',
              points: -25,
              reason: 'His forced marriage drives Juliet to desperate measures. His poor parenting creates the crisis.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: -40,
              reason: 'Juliet\'s desperate plan shows how the family\'s conflict has driven her to extreme measures. The family is falling apart.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: -20,
              reason: 'Romeo\'s absence means he cannot help Juliet in her time of need. The family\'s separation causes suffering.'
            }
          ]
        },
        {
          id: 'act4_scene3_5',
          name: 'Act 4, Scenes 3-5: Juliet\'s "Death"',
          summary: 'Juliet takes the potion and appears to die. Her family discovers her "death" and mourns. The wedding becomes a funeral.',
          effects: [
            {
              type: 'character_points',
              character: 'Juliet',
              points: -100,
              reason: 'Fakes her own death, the ultimate sacrifice for love. Her courage is extraordinary but her situation is tragic.'
            },
            {
              type: 'character_points',
              character: 'Capulet',
              points: -60,
              reason: 'Believes his daughter is dead. His grief shows he truly loved her, despite his poor decisions.'
            },
            {
              type: 'character_points',
              character: 'Lady Capulet',
              points: -50,
              reason: 'Loses her only child. Her grief is overwhelming and shows the depth of a mother\'s love.'
            },
            {
              type: 'character_points',
              character: 'Nurse',
              points: -40,
              reason: 'Loses the child she raised. Her grief shows her deep love for Juliet.'
            },
            {
              type: 'character_points',
              character: 'Paris',
              points: -30,
              reason: 'Loses his bride on their wedding day. His grief shows he truly cared for Juliet.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: -80,
              reason: 'The entire family mourns Juliet\'s "death." Their grief shows the family\'s love but also their tragic situation.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: -30,
              reason: 'Romeo will be devastated by Juliet\'s "death." The Montagues suffer from the consequences of the feud.'
            }
          ]
        },
        
        // ACT 5
        {
          id: 'act5_scene1_2',
          name: 'Act 5, Scenes 1-2: The Failed Plan',
          summary: 'Romeo learns of Juliet\'s "death" and buys poison. Friar John fails to deliver the letter explaining the plan to Romeo.',
          effects: [
            {
              type: 'character_points',
              character: 'Romeo',
              points: -120,
              reason: 'Believes Juliet is dead and decides to kill himself. His despair and love drive him to the ultimate sacrifice.'
            },
            {
              type: 'character_points',
              character: 'Friar Laurence',
              points: -50,
              reason: 'His plan fails due to circumstances beyond his control. His good intentions lead to disaster.'
            },
            {
              type: 'character_points',
              character: 'Friar John',
              points: -20,
              reason: 'Fails to deliver the crucial letter. His failure, though unintentional, leads to tragedy.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: -60,
              reason: 'Romeo\'s despair and plan to die affects the whole family. The Montagues face losing their son forever.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: -40,
              reason: 'The failed plan means Juliet will wake up alone. The Capulets face losing their daughter forever.'
            }
          ]
        },
        {
          id: 'act5_scene3',
          name: 'Act 5, Scene 3: The Final Tragedy',
          summary: 'Romeo kills Paris, then himself beside Juliet. Juliet awakens and kills herself. The families discover the tragedy and reconcile.',
          effects: [
            {
              type: 'character_points',
              character: 'Romeo',
              points: -300,
              reason: 'Dies by suicide, the ultimate tragedy. His love was pure but his despair led to his destruction.'
            },
            {
              type: 'character_points',
              character: 'Juliet',
              points: -300,
              reason: 'Dies by suicide, the ultimate tragedy. Her love was pure but her despair led to her destruction.'
            },
            {
              type: 'character_points',
              character: 'Paris',
              points: -200,
              reason: 'Dies trying to protect Juliet\'s tomb. His noble intentions lead to his death.'
            },
            {
              type: 'character_points',
              character: 'Capulet',
              points: -100,
              reason: 'Loses his daughter and realizes his role in the tragedy. His grief is overwhelming but leads to wisdom.'
            },
            {
              type: 'character_points',
              character: 'Montague',
              points: -100,
              reason: 'Loses his son and realizes his role in the tragedy. His grief is overwhelming but leads to wisdom.'
            },
            {
              type: 'character_points',
              character: 'Prince Escalus',
              points: -50,
              reason: 'Witnesses the ultimate consequence of the feud he tried to prevent. His failure to stop the violence is complete.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: -150,
              reason: 'Loses their son and heir. The family is devastated but finally learns the cost of hatred.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: -150,
              reason: 'Loses their daughter and heir. The family is devastated but finally learns the cost of hatred.'
            },
            {
              type: 'character_points',
              character: 'Friar Laurence',
              points: 50,
              reason: 'Survives to tell the truth and help the families reconcile. His wisdom finally brings peace from tragedy.'
            }
          ]
        },
        {
          id: 'act5_reconciliation',
          name: 'Epilogue: Family Reconciliation',
          summary: 'The Montague and Capulet families finally end their feud and honor Romeo and Juliet\'s love.',
          effects: [
            {
              type: 'character_points',
              character: 'Capulet',
              points: 100,
              reason: 'Finally learns from tragedy and ends the feud. His transformation shows the power of love over hatred.'
            },
            {
              type: 'character_points',
              character: 'Montague',
              points: 100,
              reason: 'Finally learns from tragedy and ends the feud. His transformation shows the power of love over hatred.'
            },
            {
              type: 'character_points',
              character: 'Prince Escalus',
              points: 80,
              reason: 'Witnesses the end of the feud and the power of love. His hope for peace is finally realized.'
            },
            {
              type: 'character_points',
              character: 'Friar Laurence',
              points: 70,
              reason: 'His wisdom and truth-telling help bring about reconciliation. His role in ending the feud is crucial.'
            },
            {
              type: 'team_points',
              team: 'Montague',
              points: 120,
              reason: 'The family finally learns the value of love over hatred. Their transformation brings honor to Romeo\'s memory.'
            },
            {
              type: 'team_points',
              team: 'Capulet',
              points: 120,
              reason: 'The family finally learns the value of love over hatred. Their transformation brings honor to Juliet\'s memory.'
            },
            {
              type: 'character_points',
              character: 'Romeo',
              points: 200,
              reason: 'Posthumously honored for his pure love. His sacrifice finally brings peace to Verona.'
            },
            {
              type: 'character_points',
              character: 'Juliet',
              points: 200,
              reason: 'Posthumously honored for her pure love. Her sacrifice finally brings peace to Verona.'
            }
          ]
        }
      ]
    }
  };

  // Initialize Story Events when scenario is loaded
  function initializeStoryEvents(scenarioId) {
    const storyEventsSection = document.getElementById('storyEventsSection');
    const storyEventSelect = document.getElementById('storyEventSelect');
    const triggerBtn = document.getElementById('triggerStoryEvent');
    
    if (!storyEventsSection || !storyEventSelect || !triggerBtn) return;
    
    // Defensive: ensure STORY_EVENTS exists and alias known IDs lazily
    if (typeof STORY_EVENTS === 'undefined') {
      console.warn('Story events not loaded yet');
      storyEventsSection.style.display = 'none';
      return;
    }
    // Map scenario aliases on demand
    if (!STORY_EVENTS[scenarioId]) {
      if (scenarioId === 'romeoAndJuliet' && STORY_EVENTS['romeo_juliet']) {
        STORY_EVENTS['romeoAndJuliet'] = STORY_EVENTS['romeo_juliet'];
      }
    }
    
    // Check if this scenario has story events
    if (STORY_EVENTS[scenarioId]) {
      storyEventsSection.style.display = 'block';
      // Ensure key story characters are present on the board for this scenario
      try { ensurePriorityCharactersForScenario(scenarioId); } catch(e){ console.warn('ensurePriorityCharactersForScenario error', e); }
      try { normalizeFactionsForScenario(scenarioId); } catch(e){ console.warn('normalizeFactionsForScenario error', e); }
      
      // Populate the dropdown
      storyEventSelect.innerHTML = '<option value="">Choose a scene...</option>';
      STORY_EVENTS[scenarioId].scenes.forEach(scene => {
        const option = document.createElement('option');
        option.value = scene.id;
        option.textContent = scene.name;
        storyEventSelect.appendChild(option);
      });
      
      // Enable/disable trigger button based on selection
      storyEventSelect.onchange = () => {
        triggerBtn.disabled = !storyEventSelect.value;
      };
      
      // Handle trigger button click
      triggerBtn.onclick = () => {
        if (!storyEventSelect.value) return;
        triggerStoryEvent(scenarioId, storyEventSelect.value);
      };
      
    } else {
      storyEventsSection.style.display = 'none';
    }
  }

  // Trigger a story event
  function triggerStoryEvent(scenarioId, sceneId) {
    const scenario = STORY_EVENTS[scenarioId];
    if (!scenario) return;
    
    const scene = scenario.scenes.find(s => s.id === sceneId);
    if (!scene) return;
    
    // Show confirmation modal with scene summary and effects
    showStoryEventModal(scene);
  }

  // Show story event confirmation modal
  function showStoryEventModal(scene) {
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1005;
    `;

    const effectsHtml = scene.effects.map(effect => {
      const pointsText = effect.points > 0 ? `+${effect.points}` : `${effect.points}`;
      const characterName = effect.character || effect.team;
      const bg = effect.points > 0 ? '#dcfce7' : '#fee2e2';
      const border = effect.points > 0 ? '#86efac' : '#fecaca';
      const color = effect.points > 0 ? '#166534' : '#7f1d1d';
      return `<div style="margin: 8px 0; padding: 10px 12px; background: ${bg}; border: 1px solid ${border}; color: ${color}; border-radius: 8px;">
        <strong>${characterName}</strong>: <span style="font-weight:700;">${pointsText}</span> ‚Äî ${effect.reason}
      </div>`;
    }).join('');

    const container = document.createElement('div');
    container.style.cssText = `
      background: #ffffff;
      color: #111827;
      border-radius: 14px;
      padding: 20px;
      max-width: 640px;
      width: 92%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 40px rgba(0,0,0,0.35);
    `;
    container.innerHTML = `
      <h2 style="margin: 0 0 12px 0; color: #111827;">${scene.name}</h2>
      <div style="margin-bottom: 16px; padding: 12px; background: #f3f4f6; border-radius: 8px; border-left: 4px solid #6f5c91; color:#111827;">
        <strong>Scene Summary:</strong><br>
        ${scene.summary}
      </div>
      <div style="margin-bottom: 16px;">
        <strong>Point Effects:</strong>
        ${effectsHtml}
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button id="storyModalCancel" style="
          padding: 10px 14px;
          border: 2px solid #e5e7eb;
          border-radius: 8px;
          background: white;
          color: #374151;
          cursor: pointer;
          font-weight: 600;
        ">Cancel</button>
        <button id="storyModalApply" style="
          padding: 10px 14px;
          border: none;
          border-radius: 8px;
          background: #6f5c91;
          color: #ffffff;
          cursor: pointer;
          font-weight: 700;
        ">Apply Effects</button>
      </div>
    `;

    modal.appendChild(container);
    document.body.appendChild(modal);

    const closeModal = () => modal.remove();
    container.querySelector('#storyModalCancel').addEventListener('click', closeModal);
    container.querySelector('#storyModalApply').addEventListener('click', () => {
      try {
        applyStoryEvent(scene.id);
      } catch (err) {
        console.error('Error applying story event', err);
      }
      closeModal();
    });
  }

  // Apply story event effects to students
  function applyStoryEvent(sceneId) {
    // Find the current scenario and scene
    let currentScenario = null;
    let currentScene = null;
    
    for (const [scenarioId, scenario] of Object.entries(STORY_EVENTS)) {
      const scene = scenario.scenes.find(s => s.id === sceneId);
      if (scene) {
        currentScenario = scenarioId;
        currentScene = scene;
        break;
      }
    }
    
    if (!currentScene) return;
    
    // Merge duplicate character effects so the same character is not rewarded twice
    const mergedCharacterEffects = {};
    const teamEffects = [];
    currentScene.effects.forEach(effect => {
      if (effect.type === 'character_points') {
        const key = (effect.character || '').toLowerCase();
        if (!mergedCharacterEffects[key]) {
          mergedCharacterEffects[key] = { ...effect };
        } else {
          mergedCharacterEffects[key].points += effect.points;
        }
      } else if (effect.type === 'team_points') {
        teamEffects.push(effect);
      }
    });

    const finalEffects = [
      ...Object.values(mergedCharacterEffects),
      ...teamEffects
    ];

    // Ensure factions are set before applying
    try { normalizeFactionsForScenario(currentScenario); } catch(_) {}

    // Apply each final effect
    finalEffects.forEach(effect => {
      if (effect.type === 'character_points') {
        applyCharacterPoints(effect.character, effect.points, effect.reason);
      } else if (effect.type === 'team_points') {
        applyTeamPoints(effect.team, effect.points, effect.reason);
      }
    });
    
    // Re-render UI and persist
    try { renderRoster(); } catch(e) { console.warn('renderRoster not available yet', e); }
    // Save roster changes
    saveRoster();
    
    // Optional feedback (non-blocking)
    try {
      const notice = document.createElement('div');
      notice.textContent = `Applied: ${currentScene.name}`;
      notice.style.cssText = 'position:fixed;bottom:16px;right:16px;background:#111827;color:#fff;padding:10px 14px;border-radius:8px;z-index:1006;opacity:0.95';
      document.body.appendChild(notice);
      setTimeout(()=>notice.remove(), 1500);
    } catch (_) {}
  }

  // Apply points to a specific character
  function applyCharacterPoints(characterName, points, reason) {
    if (!state.roster || state.roster.length === 0) return;
    const lower = (characterName || '').toLowerCase();
    const student = state.roster.find(s => (s.characterName && s.characterName.toLowerCase() === lower) || (s.name && s.name === characterName));
    if (!student) {
      console.warn(`Character "${characterName}" not found in roster`);
      return;
    }
    
    // Update earned/balance which drives UI scores
    const oldEarned = student.earnedPoints || 0;
    const delta = points;
    const newEarned = Math.max(0, oldEarned + delta);
    student.earnedPoints = newEarned;
    student.balance = (student.startingPoints || 0) + (student.earnedPoints || 0);
    console.log(`Applied ${points} to ${characterName}: earned ${oldEarned} ‚Üí ${newEarned} (${reason})`);
  }

  // Apply points to all students in a team/faction
  function applyTeamPoints(teamName, points, reason) {
    if (!state.roster || state.roster.length === 0) return;
    const isMatch = (student) => {
      const faction = (student.characterFaction || '').toLowerCase();
      const cname = (student.characterName || '').toLowerCase();
      const t = (teamName || '').toLowerCase();
      if (!t) return false;
      if (faction && faction.toLowerCase().includes(t)) return true;
      // Heuristics: characterName contains team keyword
      if (t === 'montague' && cname.includes('montague')) return true;
      if (t === 'capulet' && cname.includes('capulet')) return true;
      return false;
    };

    state.roster.filter(isMatch).forEach(student => {
      const oldEarned = student.earnedPoints || 0;
      const newEarned = Math.max(0, oldEarned + points);
      student.earnedPoints = newEarned;
      student.balance = (student.startingPoints || 0) + (student.earnedPoints || 0);
    });
    
    console.log(`Applied ${points} points to team ${teamName}: ${reason}`);
  }

  // Ensure important story characters are present by assigning them to unassigned students
  function ensurePriorityCharactersForScenario(scenarioId) {
    if (!STORY_EVENTS[scenarioId] || !state.roster) return;
    const scenes = STORY_EVENTS[scenarioId].scenes || [];
    const priorityCharacters = Array.from(new Set(
      scenes.flatMap(s => (s.effects || [])
        .filter(e => e.type === 'character_points' && e.character)
        .map(e => e.character))
    ));

    const present = new Set(state.roster.filter(s => s.characterName).map(s => s.characterName));
    const availableStudents = state.roster.filter(s => !s.characterName);
    let i = 0;
    priorityCharacters.forEach(charName => {
      if (present.has(charName)) return;
      const student = availableStudents[i++];
      if (!student) return;
      student.characterName = charName;
      // Infer faction from name
      if (charName.toLowerCase().includes('montague')) student.characterFaction = 'Montague';
      else if (charName.toLowerCase().includes('capulet')) student.characterFaction = 'Capulet';
    });
  }

  // Fill missing characterFaction using characterName heuristics for this scenario
  function normalizeFactionsForScenario(scenarioId){
    if (!state.roster) return;
    state.roster.forEach(s => {
      if (!s.characterFaction && s.characterName) {
        const cname = s.characterName.toLowerCase();
        if (cname.includes('montague')) s.characterFaction = 'Montague';
        else if (cname.includes('capulet')) s.characterFaction = 'Capulet';
      }
    });
  }

  function showDifficultySelectionModal(gameType, mode = 'school') {
    const modal = document.createElement('div');
    modal.id = 'difficultySelectionModal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1004;
    `;
    
    modal.innerHTML = `
      <div style="
        background: white;
        border-radius: 16px;
        padding: 2rem;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: #1e293b; font-size: 1.5rem;">‚öôÔ∏è Choose Difficulty</h2>
          <button onclick="closeDifficultySelectionModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b;">&times;</button>
        </div>
        
        <p style="margin-bottom: 1.5rem; color: #64748b;">
          Select the difficulty level for your ${gameType === 'regular' ? 'regular' : 'scenario'} game. This affects the cost of territories, weapons, mercenaries, and upgrades.
        </p>
        
        <div style="display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem;">
          <div class="difficulty-option" data-difficulty="easy" style="
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #f8fafc;
          " onmouseover="this.style.borderColor='#10b981'; this.style.backgroundColor='#f0fdf4'" onmouseout="this.style.borderColor='#e2e8f0'; this.style.backgroundColor='#f8fafc'">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h3 style="margin: 0 0 0.5rem 0; color: #1e293b;">üü¢ Easy</h3>
                <p style="margin: 0; color: #64748b; font-size: 0.9rem;">
                  Lower costs for territories, weapons, and upgrades. Perfect for shorter games or younger students.
                </p>
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #059669;">
                  ‚Ä¢ Territory costs: 50% of normal<br>
                  ‚Ä¢ Weapons: 50% of normal<br>
                  ‚Ä¢ Mercenaries: 50% of normal<br>
                  ‚Ä¢ Castle upgrades: 50% of normal
                </div>
              </div>
              <div style="font-size: 1.5rem;">üü¢</div>
            </div>
          </div>
          
          <div class="difficulty-option" data-difficulty="medium" style="
            border: 2px solid #3b82f6;
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #eff6ff;
          " onmouseover="this.style.borderColor='#1d4ed8'; this.style.backgroundColor='#dbeafe'" onmouseout="this.style.borderColor='#3b82f6'; this.style.backgroundColor='#eff6ff'">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h3 style="margin: 0 0 0.5rem 0; color: #1e293b;">üîµ Medium</h3>
                <p style="margin: 0; color: #64748b; font-size: 0.9rem;">
                  Standard costs for balanced gameplay. Recommended for most classroom situations.
                </p>
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #2563eb;">
                  ‚Ä¢ Territory costs: 100% of normal<br>
                  ‚Ä¢ Weapons: 100% of normal<br>
                  ‚Ä¢ Mercenaries: 100% of normal<br>
                  ‚Ä¢ Castle upgrades: 100% of normal
                </div>
              </div>
              <div style="font-size: 1.5rem;">üîµ</div>
            </div>
          </div>
          
          <div class="difficulty-option" data-difficulty="hard" style="
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #f8fafc;
          " onmouseover="this.style.borderColor='#dc2626'; this.style.backgroundColor='#fef2f2'" onmouseout="this.style.borderColor='#e2e8f0'; this.style.backgroundColor='#f8fafc'">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h3 style="margin: 0 0 0.5rem 0; color: #1e293b;">üî¥ Hard</h3>
                <p style="margin: 0; color: #64748b; font-size: 0.9rem;">
                  Higher costs for challenging gameplay. Great for advanced students or longer game sessions.
                </p>
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #dc2626;">
                  ‚Ä¢ Territory costs: 150% of normal<br>
                  ‚Ä¢ Weapons: 150% of normal<br>
                  ‚Ä¢ Mercenaries: 150% of normal<br>
                  ‚Ä¢ Castle upgrades: 150% of normal
                </div>
              </div>
              <div style="font-size: 1.5rem;">üî¥</div>
            </div>
          </div>
        </div>
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="closeDifficultySelectionModal()" style="
            background: #64748b;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Cancel</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Add click handlers for difficulty options
    modal.querySelectorAll('.difficulty-option').forEach(option => {
      option.onclick = () => {
        const difficulty = option.dataset.difficulty;
        closeDifficultySelectionModal();
        startGameWithDifficulty(gameType, difficulty);
      };
    });
  }

  function closeDifficultySelectionModal() {
    const modal = document.getElementById('difficultySelectionModal');
    if (modal) {
      modal.remove();
    }
  }

  function updateModeLabels(mode) {
    const modeIndicator = document.getElementById('modeIndicator');
    const rosterTitle = document.getElementById('rosterTitle');
    const businessSidebar = document.getElementById('businessSidebar');
    
    if (mode === 'business') {
      if (modeIndicator) {
        modeIndicator.textContent = 'Business Mode';
        modeIndicator.style.background = '#64748b';
      }
      if (rosterTitle) {
        rosterTitle.textContent = 'Employees';
      }
      if (businessSidebar) {
        businessSidebar.style.display = 'block';
      }
      // Update grid layout for business mode
      document.querySelector('.wrap').style.gridTemplateColumns = '400px 1fr 300px';
    } else {
      if (modeIndicator) {
        modeIndicator.textContent = 'School Mode';
        modeIndicator.style.background = '#6f5c91';
      }
      if (rosterTitle) {
        rosterTitle.textContent = 'Roster';
      }
      if (businessSidebar) {
        businessSidebar.style.display = 'none';
      }
      // Update grid layout for school mode
      document.querySelector('.wrap').style.gridTemplateColumns = '400px 1fr';
    }
  }

  // Top 25 Business Metrics
  const TOP_25_METRICS = [
    'Features shipped',
    'Bugs resolved', 
    'Code quality score',
    'Test coverage %',
    'CSAT/NPS delta',
    'Revenue influenced',
    'Deals closed',
    'Hours saved via automation',
    'Knowledge shares hosted',
    'Mentoring sessions',
    'Delivery time delta',
    'On-time task rate %',
    'Escalations handled',
    'Training hours',
    'Certifications earned',
    'New clients onboarded',
    'Retention rate improvement',
    'Innovation proposals',
    'Security issues resolved',
    'Downtime reduced',
    'Documentation completed',
    'Cross-team collaborations',
    'Product demos delivered',
    'Feedback surveys completed',
    'Peer kudos / votes'
  ];

  function initializeBusinessMode() {
    // Tab switching
    document.querySelectorAll('.business-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        
        // Update active tab
        document.querySelectorAll('.business-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Show corresponding panel
        document.querySelectorAll('.business-tab-panel').forEach(panel => {
          panel.style.display = 'none';
        });
        document.getElementById(`tab-${tabName}`).style.display = 'block';
        
        // Load tab content
        if (tabName === 'metrics') {
          loadMetricsTab();
        } else if (tabName === 'announcements') {
          loadAnnouncementsTab();
        } else if (tabName === 'rewards') {
          loadRewardsTab();
        } else if (tabName === 'leaderboard') {
          loadBusinessLeaderboard();
        }
      });
    });
    
    // Initialize metrics tab
    loadMetricsTab();
    loadAnnouncementsTab();
    loadRewardsTab();
    loadBusinessLeaderboard();
  }

  function loadMetricsTab() {
    const metricsList = document.getElementById('metricsList');
    if (!metricsList) return;
    
    metricsList.innerHTML = '<div style="font-size: 11px; color: var(--muted);">Select metrics to track performance...</div>';
    
    // Add Metric button handler
    const addMetricBtn = document.getElementById('addMetricBtn');
    if (addMetricBtn) {
      addMetricBtn.onclick = () => showAddMetricModal();
    }
    
    // CSV Import button handler
    const csvImportBtn = document.getElementById('csvImportBtn');
    if (csvImportBtn) {
      csvImportBtn.onclick = () => showCsvImportModal();
    }
  }

  function loadAnnouncementsTab() {
    const announcementsList = document.getElementById('announcementsList');
    if (!announcementsList) return;
    
    announcementsList.innerHTML = '<div style="font-size: 11px; color: var(--muted);">No announcements yet...</div>';
    
    // New Announcement button handler
    const newAnnouncementBtn = document.getElementById('newAnnouncementBtn');
    if (newAnnouncementBtn) {
      newAnnouncementBtn.onclick = () => showNewAnnouncementModal();
    }
  }

  function loadRewardsTab() {
    // Save Rewards button handler
    const saveRewardsBtn = document.getElementById('saveRewardsBtn');
    if (saveRewardsBtn) {
      saveRewardsBtn.onclick = () => {
        const teamReward = document.getElementById('rewardTeam').value;
        const playerReward = document.getElementById('rewardPlayer').value;
        
        if (teamReward || playerReward) {
          // Store rewards in state
          state.rewardTeam = teamReward;
          state.rewardPlayer = playerReward;
          
          alert('Rewards saved successfully!');
        } else {
          alert('Please enter at least one reward.');
        }
      };
    }
  }

  function loadBusinessLeaderboard() {
    const businessLeaderboard = document.getElementById('businessLeaderboard');
    if (!businessLeaderboard) return;
    
    // Simple leaderboard display
    businessLeaderboard.innerHTML = '<div style="font-size: 11px; color: var(--muted);">Team rankings will appear here...</div>';
  }

  function showAddMetricModal() {
    // Create modal for adding metrics
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    `;
    
    modal.innerHTML = `
      <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 1rem; max-width: 500px; width: 90%;">
        <h3 style="margin: 0 0 1rem 0; color: var(--text);">Add Performance Metric</h3>
        <div style="margin-bottom: 1rem;">
          <label style="display: block; margin-bottom: 0.5rem; color: var(--muted);">Metric Name:</label>
          <select id="metricSelect" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);">
            <option value="">Select from Top 25...</option>
            ${TOP_25_METRICS.map(metric => `<option value="${metric}">${metric}</option>`).join('')}
            <option value="custom">Custom Metric</option>
          </select>
        </div>
        <div style="margin-bottom: 1rem;">
          <label style="display: block; margin-bottom: 0.5rem; color: var(--muted);">Custom Name:</label>
          <input type="text" id="customMetricName" placeholder="Enter custom metric name" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);" disabled>
        </div>
        <div style="margin-bottom: 1rem;">
          <label style="display: block; margin-bottom: 0.5rem; color: var(--muted);">Weight:</label>
          <input type="number" id="metricWeight" value="1" min="0.1" max="10" step="0.1" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 4px; background: var(--panel); color: var(--text);">
        </div>
        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
          <button onclick="this.closest('div').parentElement.remove()" style="padding: 0.5rem 1rem; background: var(--border); color: var(--text); border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
          <button onclick="addMetric()" style="padding: 0.5rem 1rem; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;">Add Metric</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Handle metric selection
    const metricSelect = document.getElementById('metricSelect');
    const customMetricName = document.getElementById('customMetricName');
    
    metricSelect.onchange = () => {
      if (metricSelect.value === 'custom') {
        customMetricName.disabled = false;
        customMetricName.focus();
      } else {
        customMetricName.disabled = true;
        customMetricName.value = '';
      }
    };
  }

  function addMetric() {
    const metricSelect = document.getElementById('metricSelect');
    const customMetricName = document.getElementById('customMetricName');
    const metricWeight = document.getElementById('metricWeight');
    
    let metricName = metricSelect.value;
    if (metricName === 'custom') {
      metricName = customMetricName.value.trim();
      if (!metricName) {
        alert('Please enter a custom metric name.');
        return;
      }
    }
    
    if (!metricName) {
      alert('Please select or enter a metric name.');
      return;
    }
    
    // Add metric to state (in production, this would save to database)
    if (!state.businessMetrics) {
      state.businessMetrics = [];
    }
    
    state.businessMetrics.push({
      name: metricName,
      weight: parseFloat(metricWeight.value) || 1,
      source: 'MANUAL',
      createdAt: new Date().toISOString()
    });
    
    // Close modal and refresh metrics list
    document.querySelector('[onclick*="addMetric()"]').closest('div').parentElement.remove();
    loadMetricsTab();
    
    alert(`Metric "${metricName}" added successfully!`);
  }

  function showCsvImportModal() {
    alert('CSV Import functionality coming soon! This will allow bulk import of performance data.');
  }

  function showNewAnnouncementModal() {
    alert('New Announcement functionality coming soon! This will allow managers to post company updates.');
  }

  function startGameWithDifficulty(gameType, difficulty, mode = 'school') {
    // Store difficulty and mode in state
    state.gameDifficulty = difficulty;
    state.gameMode = mode;
    
    // Update UI labels
    updateModeLabels(mode);
    
    // Initialize business mode functionality if needed
    if (mode === 'business') {
      initializeBusinessMode();
    }
    
    if (gameType === 'regular') {
      startRegularGame();
    } else if (gameType === 'scenario') {
      // Use the stored scenario settings
      const settings = window.tempScenarioSettings;
      if (!settings) {
        alert('Scenario settings not found. Please try again.');
        return;
      }
      
      // Handle custom scenario
      if (settings.scenarioId === 'custom') {
        showCustomScenarioBuilder();
        return;
      }
      
      // Automatically clear any saved scenario
      if (state.currentRoster && state.currentRoster.scenario) {
        delete state.currentRoster.scenario;
        state.scenario = null;
        
        // Update game theme title
        updateGameThemeTitle();
        
        // Clear character assignments
        state.roster.forEach(student => {
          student.characterName = null;
          student.characterRole = null;
          student.characterFaction = null;
          student.teamId = null;
          student.teamName = null;
          student.teamColor = null;
        });
        
        console.log('Automatically cleared saved scenario from roster');
      }
      
      if (!confirm('Are you sure you want to start a new scenario game? This will reset ALL game progress including:\n\n‚Ä¢ All territory ownership\n‚Ä¢ All castle levels\n‚Ä¢ All student balances\n‚Ä¢ All truces\n‚Ä¢ All game state\n\nThis action cannot be undone!')) {
        return;
      }
      
      // Get scenario data
      const scenario = SCENARIOS[settings.scenarioId];
      if (!scenario) {
        alert('Scenario not found!');
        return;
      }
      
      // Create scenario data for the roster
      const scenarioData = {
        scenarioId: scenario.id,
        scenarioName: scenario.name,
        scenarioType: scenario.type,
        factions: scenario.factions,
        neutralTerritories: scenario.neutralTerritories,
        randomAssignment: settings.roleAssignment === 'random',
        enableAI: settings.enableAI,
        aiDifficulty: settings.aiDifficulty,
        gameDifficulty: difficulty
      };
      
      // Update current roster with scenario data
      state.currentRoster.scenario = scenarioData;

      // Persist AI config on roster for Class vs AI
      if (!state.currentRoster.aiConfig) state.currentRoster.aiConfig = {};
      state.currentRoster.aiConfig.classVsAI = !!settings.enableAI;
      state.currentRoster.aiConfig.difficulty = settings.aiDifficulty;
      
      // If AI is enabled, check assignment type
      if (settings.enableAI) {
        if (settings.roleAssignment === 'random') {
          // Random assignment with AI - proceed directly (students vs AI)
          initializeScenario(scenarioData);
          resetGameToDefaults();
          showScenarioInfo(scenarioData);
        } else {
          // Manual assignment with AI - show modal
          showAIRoleAssignmentModal(scenario, scenarioData, settings.roleAssignment);
        }
      } else if (settings.roleAssignment === 'manual') {
        // Manual assignment without AI
        showRoleAssignmentModal(scenario);
      } else {
        // Random assignment without AI - proceed directly
        initializeScenario(scenarioData);
        resetGameToDefaults();
        showScenarioInfo(scenarioData);
      }
    }
  }

  function showAIRoleAssignmentModal(scenario, scenarioData, roleAssignment) {
    const modal = document.createElement('div');
    modal.id = 'aiRoleAssignmentModal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1004;
    `;
    
    // Get all characters from all factions
    const allCharacters = [];
    Object.values(scenario.factions).forEach(faction => {
      faction.characters.forEach(char => {
        allCharacters.push({
          ...char,
          factionName: faction.name,
          factionColor: faction.color
        });
      });
    });
    
    // Add general roles
    Object.values(scenario.factions).forEach(faction => {
      faction.generalRoles.forEach(role => {
        allCharacters.push({
          name: `${role.name} (${faction.name})`,
          role: role.name,
          factionName: faction.name,
          factionColor: faction.color,
          startingCoins: role.startingCoins,
          startingWeapons: role.startingWeapons,
          startingMercenaries: role.startingMercenaries,
          startingCastles: role.startingCastles,
          personality: role.personality,
          quotes: role.quotes,
          description: `${role.name} of ${faction.name}`,
          isGeneralRole: true
        });
      });
    });
    
    modal.innerHTML = `
      <div style="
        background: white;
        border-radius: 16px;
        padding: 2rem;
        max-width: 1000px;
        width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: #1e293b; font-size: 1.5rem;">ü§ñ Assign AI Roles</h2>
          <button onclick="closeAIRoleAssignmentModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b;">&times;</button>
        </div>
        
        <p style="margin-bottom: 1.5rem; color: #64748b;">
          Choose which roles will be controlled by AI opponents in the ${scenario.name} scenario:
        </p>
        
        <div style="margin-bottom: 1.5rem;">
          <label style="display: flex; align-items: center; margin-bottom: 1rem;">
            <input type="checkbox" id="autoAssignBadGuys" checked style="margin-right: 0.5rem;">
            <span style="font-weight: 600; color: #1e293b;">Auto-assign "bad guy" roles to AI</span>
          </label>
          <p style="margin: 0 0 1rem 0; color: #64748b; font-size: 0.9rem; margin-left: 1.5rem;">
            AI will automatically take antagonist roles (e.g., Voldemort, Darth Vader, etc.)
          </p>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 1.5rem;">
          <!-- Students Column -->
          <div>
            <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Your Students</h3>
            <div id="aiStudentsList" style="
              border: 2px dashed #e2e8f0;
              border-radius: 8px;
              padding: 1rem;
              min-height: 300px;
              background: #f8fafc;
            ">
              ${state.roster.map(student => `
                <div class="ai-student-card" draggable="true" data-student-id="${student.gsId}" style="
                  background: white;
                  border: 1px solid #e2e8f0;
                  border-radius: 6px;
                  padding: 0.75rem;
                  margin-bottom: 0.5rem;
                  cursor: move;
                  transition: all 0.2s ease;
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.1)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                  <div style="font-weight: 600; color: #1e293b;">${student.name}</div>
                  <div style="font-size: 0.875rem; color: #64748b;">Unassigned</div>
                </div>
              `).join('')}
            </div>
          </div>
          
          <!-- Roles Column -->
          <div>
            <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Available Roles</h3>
            <div id="aiRolesList" style="
              border: 2px dashed #e2e8f0;
              border-radius: 8px;
              padding: 1rem;
              min-height: 300px;
              background: #f8fafc;
            ">
              ${allCharacters.map(char => `
                <div class="ai-role-card" data-role-id="${char.name}" data-is-antagonist="${isAntagonistRole(char.name, scenario.name)}" style="
                  background: white;
                  border: 1px solid #e2e8f0;
                  border-radius: 6px;
                  padding: 0.75rem;
                  margin-bottom: 0.5rem;
                  cursor: move;
                  transition: all 0.2s ease;
                  border-left: 4px solid ${char.factionColor};
                  ${isAntagonistRole(char.name, scenario.name) ? 'background: #fef2f2; border-left-color: #ef4444;' : ''}
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.1)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                  <div style="font-weight: 600; color: #1e293b;">${char.name}</div>
                  <div style="font-size: 0.875rem; color: #64748b;">${char.role} ‚Ä¢ ${char.factionName}</div>
                  <div style="font-size: 0.75rem; color: #94a3b8;">üí∞${char.startingCoins} ‚Ä¢ ‚öîÔ∏è${char.startingWeapons.join(', ')} ‚Ä¢ üè∞${char.startingCastles}</div>
                  ${isAntagonistRole(char.name, scenario.name) ? '<div style="font-size: 0.75rem; color: #ef4444; font-weight: bold;">üëπ Antagonist</div>' : ''}
                </div>
              `).join('')}
            </div>
          </div>
        </div>
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="closeAIRoleAssignmentModal()" style="
            background: #64748b;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Cancel</button>
          <button onclick="autoAssignBadGuys()" style="
            background: #f59e0b;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Auto-Assign Bad Guys</button>
          <button onclick="randomizeAIRoles()" style="
            background: #8b5cf6;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Randomize All</button>
          <button onclick="startGameWithAI()" style="
            background: #10b981;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
          ">Start Game</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Initialize drag and drop
    initializeAIDragDrop();
    
    // Auto-assign bad guys if checkbox is checked
    if (document.getElementById('autoAssignBadGuys').checked) {
      autoAssignBadGuys();
    }
  }
  
  window.closeAIRoleAssignmentModal = function() {
    const modal = document.getElementById('aiRoleAssignmentModal');
    if (modal) {
      modal.remove();
    }
  }
  
  function isAntagonistRole(characterName, scenarioName) {
    // Define antagonist roles for each scenario
    const antagonists = {
      'Harry Potter': ['Voldemort', 'Death Eater', 'Bellatrix Lestrange', 'Lucius Malfoy', 'Severus Snape'],
      'Star Wars': ['Darth Vader', 'Emperor Palpatine', 'Darth Maul', 'Stormtrooper', 'Imperial Officer'],
      'Avengers': ['Thanos', 'Loki', 'Ultron', 'Hydra Agent', 'Supervillain'],
      'DC vs Marvel': ['Joker', 'Lex Luthor', 'Magneto', 'Supervillain', 'Villain'],
      'Frozen': ['Hans', 'Weselton', 'Villain', 'Evil Duke'],
      'Minions': ['Scarlet Overkill', 'Villain', 'Evil Mastermind'],
      'Toy Story': ['Sid', 'Stinky Pete', 'Villain', 'Evil Toy'],
      'Moana': ['Te KƒÅ', 'Kakamora', 'Villain', 'Darkness'],
      'Julius Caesar': ['Brutus', 'Cassius', 'Republican', 'Senator'],
      'Animal Farm': ['Napoleon', 'Squealer', 'Pig', 'Ruler'],
      '1984': ['Big Brother', 'Party Member', 'Thought Police', 'O\'Brien'],
      'The Iliad': ['Hector', 'Paris', 'Trojan', 'Prince'],
      'Dune': ['Baron Harkonnen', 'Feyd-Rautha', 'Harkonnen', 'Villain']
    };
    
    return antagonists[scenarioName] && antagonists[scenarioName].some(antagonist => 
      characterName.toLowerCase().includes(antagonist.toLowerCase())
    );
  }
  
  function initializeAIDragDrop() {
    const studentsList = document.getElementById('aiStudentsList');
    const rolesList = document.getElementById('aiRolesList');
    
    // Make students draggable
    studentsList.querySelectorAll('.ai-student-card').forEach(card => {
      card.addEventListener('dragstart', function(e) {
        e.dataTransfer.setData('text/plain', this.dataset.studentId);
        e.dataTransfer.effectAllowed = 'move';
        this.style.opacity = '0.5';
      });
      
      card.addEventListener('dragend', function(e) {
        this.style.opacity = '1';
      });
    });
    
    // Make roles droppable
    rolesList.querySelectorAll('.ai-role-card').forEach(card => {
      card.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        this.style.backgroundColor = '#f0f9ff';
      });
      
      card.addEventListener('dragleave', function(e) {
        this.style.backgroundColor = this.dataset.isAntagonist === 'true' ? '#fef2f2' : 'white';
      });
      
      card.addEventListener('drop', function(e) {
        e.preventDefault();
        this.style.backgroundColor = this.dataset.isAntagonist === 'true' ? '#fef2f2' : 'white';
        
        const studentId = e.dataTransfer.getData('text/plain');
        const studentCard = document.querySelector(`[data-student-id="${studentId}"]`);
        
        if (studentCard && !this.querySelector('.student-assigned')) {
          // Create assigned student element
          const assignedStudent = document.createElement('div');
          assignedStudent.className = 'student-assigned';
          assignedStudent.style.cssText = `
            background: #10b981;
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            margin-top: 0.5rem;
            font-size: 0.875rem;
          `;
          assignedStudent.textContent = studentCard.querySelector('div').textContent;
          
          this.appendChild(assignedStudent);
          
          // Update student card
          studentCard.querySelector('div:last-child').textContent = this.querySelector('div').textContent;
          studentCard.style.opacity = '0.6';
          studentCard.draggable = false;
          
          // Store assignment
          this.dataset.assignedStudent = studentId;
        }
      });
    });
  }
  
  window.autoAssignBadGuys = function() {
    const antagonistRoles = Array.from(document.querySelectorAll('.ai-role-card[data-is-antagonist="true"]')).filter(card => !card.dataset.assignedStudent);
    const students = Array.from(document.querySelectorAll('.ai-student-card')).filter(card => card.draggable);
    
    // Assign students to antagonist roles
    students.forEach((student, index) => {
      if (index < antagonistRoles.length) {
        const role = antagonistRoles[index];
        const studentId = student.dataset.studentId;
        
        // Create assigned student element
        const assignedStudent = document.createElement('div');
        assignedStudent.className = 'student-assigned';
        assignedStudent.style.cssText = `
          background: #ef4444;
          color: white;
          padding: 0.5rem;
          border-radius: 4px;
          margin-top: 0.5rem;
          font-size: 0.875rem;
        `;
        assignedStudent.textContent = student.querySelector('div').textContent;
        
        role.appendChild(assignedStudent);
        
        // Update student card
        student.querySelector('div:last-child').textContent = role.querySelector('div').textContent;
        student.style.opacity = '0.6';
        student.draggable = false;
        
        // Store assignment
        role.dataset.assignedStudent = studentId;
      }
    });
  }
  
  window.randomizeAIRoles = function() {
    const students = Array.from(document.querySelectorAll('.ai-student-card')).filter(card => card.draggable);
    const roles = Array.from(document.querySelectorAll('.ai-role-card')).filter(card => !card.dataset.assignedStudent);
    
    // Shuffle students
    for (let i = students.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [students[i], students[j]] = [students[j], students[i]];
    }
    
    // Assign students to roles
    students.forEach((student, index) => {
      if (index < roles.length) {
        const role = roles[index];
        const studentId = student.dataset.studentId;
        
        // Create assigned student element
        const assignedStudent = document.createElement('div');
        assignedStudent.className = 'student-assigned';
        assignedStudent.style.cssText = `
          background: #10b981;
          color: white;
          padding: 0.5rem;
          border-radius: 4px;
          margin-top: 0.5rem;
          font-size: 0.875rem;
        `;
        assignedStudent.textContent = student.querySelector('div').textContent;
        
        role.appendChild(assignedStudent);
        
        // Update student card
        student.querySelector('div:last-child').textContent = role.querySelector('div').textContent;
        student.style.opacity = '0.6';
        student.draggable = false;
        
        // Store assignment
        role.dataset.assignedStudent = studentId;
      }
    });
  }
  
  window.startGameWithAI = function() {
    // Collect role assignments
    const roleAssignments = {};
    const aiAssignments = {};
    
    document.querySelectorAll('.ai-role-card[data-assigned-student]').forEach(roleCard => {
      const studentId = roleCard.dataset.assignedStudent;
      const roleName = roleCard.querySelector('div').textContent;
      const isAntagonist = roleCard.dataset.isAntagonist === 'true';
      
      if (isAntagonist) {
        aiAssignments[roleName] = {
          studentId: studentId,
          studentName: document.querySelector(`[data-student-id="${studentId}"]`).querySelector('div').textContent,
          isAI: true
        };
      } else {
        roleAssignments[studentId] = roleName;
      }
    });
    
    // Update scenario data with assignments
    const scenarioData = state.currentRoster.scenario;
    scenarioData.manualRoleAssignments = roleAssignments;
    scenarioData.aiAssignments = aiAssignments;
    
    // Close modal
    closeAIRoleAssignmentModal();
    
    // Initialize scenario
    initializeScenario(scenarioData);
    
    // Reset game with scenario
    resetGameToDefaults();
    
    // Show scenario info
    showScenarioInfo(scenarioData);
  }
  function showCustomScenarioBuilder() {
    const modal = document.createElement('div');
    modal.id = 'customScenarioBuilder';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1003;
    `;
    
    modal.innerHTML = `
      <div style="
        background: white;
        border-radius: 16px;
        padding: 2rem;
        max-width: 1200px;
        width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: #1e293b; font-size: 1.5rem;">üé® Custom Scenario Builder</h2>
          <button onclick="closeCustomScenarioBuilder()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b;">&times;</button>
        </div>
        
        <!-- Creation Method Selection -->
        <div style="margin-bottom: 1.5rem;">
          <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Choose Creation Method</h3>
          <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
            <button id="formMethodBtn" onclick="switchCreationMethod('form')" style="
              padding: 0.75rem 1.5rem;
              border: 2px solid #3b82f6;
              background: #3b82f6;
              color: white;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 600;
            ">üìù Fill Out Form</button>
            <button id="pasteMethodBtn" onclick="switchCreationMethod('paste')" style="
              padding: 0.75rem 1.5rem;
              border: 2px solid #e2e8f0;
              background: white;
              color: #64748b;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 600;
            ">üìã Copy & Paste</button>
          </div>
        </div>

        <div id="formCreationMethod" style="display: block;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 1.5rem;">
            <!-- Left Column: Scenario Setup -->
            <div>
              <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Scenario Setup</h3>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">Scenario Name:</label>
              <input type="text" id="customScenarioName" placeholder="Enter scenario name..." style="
                width: 100%;
                padding: 0.75rem;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 1rem;
              ">
            </div>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">Scenario Type:</label>
              <select id="customScenarioType" style="
                width: 100%;
                padding: 0.75rem;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 1rem;
              ">
                <option value="historical">Historical</option>
                <option value="literary">Literary</option>
                <option value="fantasy">Fantasy</option>
                <option value="sci-fi">Science Fiction</option>
                <option value="modern">Modern</option>
                <option value="other">Other</option>
              </select>
            </div>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">Description:</label>
              <textarea id="customScenarioDescription" placeholder="Describe your scenario..." style="
                width: 100%;
                padding: 0.75rem;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 1rem;
                min-height: 80px;
                resize: vertical;
              "></textarea>
            </div>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">Number of Factions:</label>
              <select id="customFactionCount" onchange="updateCustomFactions()" style="
                width: 100%;
                padding: 0.75rem;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 1rem;
              ">
                <option value="2">2 Factions</option>
                <option value="3">3 Factions</option>
                <option value="4">4 Factions</option>
                <option value="5">5 Factions</option>
                <option value="6">6 Factions</option>
              </select>
            </div>
            
            <div id="customFactionsContainer">
              <!-- Factions will be generated here -->
            </div>
          </div>
          
          <!-- Right Column: Characters & Territories -->
          <div>
            <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Characters & Territories</h3>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">Characters per Faction:</label>
              <input type="number" id="charactersPerFaction" value="3" min="1" max="10" onchange="updateCustomCharacters()" style="
                width: 100%;
                padding: 0.75rem;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 1rem;
              ">
            </div>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">Territories per Faction:</label>
              <input type="number" id="territoriesPerFaction" value="5" min="1" max="15" onchange="updateCustomTerritories()" style="
                width: 100%;
                padding: 0.75rem;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 1rem;
              ">
            </div>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">Neutral Territories:</label>
              <input type="number" id="neutralTerritories" value="8" min="0" max="20" style="
                width: 100%;
                padding: 0.75rem;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 1rem;
              ">
            </div>
            
            <div id="customCharactersContainer">
              <!-- Characters will be generated here -->
            </div>
            
            <div id="customTerritoriesContainer">
              <!-- Territories will be generated here -->
            </div>
          </div>
        </div>
        
        <!-- Student Assignment Section -->
        <div style="margin-bottom: 1.5rem;">
          <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Student Assignment</h3>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
            <div>
              <h4 style="margin: 0 0 0.5rem 0; color: #1e293b;">Your Students</h4>
              <div id="customStudentsList" style="
                border: 2px dashed #e2e8f0;
                border-radius: 8px;
                padding: 1rem;
                min-height: 200px;
                background: #f8fafc;
              ">
                ${state.roster.map(student => `
                  <div class="custom-student-card" draggable="true" data-student-id="${student.gsId}" style="
                    background: white;
                    border: 1px solid #e2e8f0;
                    border-radius: 6px;
                    padding: 0.75rem;
                    margin-bottom: 0.5rem;
                    cursor: move;
                    transition: all 0.2s ease;
                  ">
                    <div style="font-weight: 600; color: #1e293b;">${student.name}</div>
                    <div style="font-size: 0.875rem; color: #64748b;">Unassigned</div>
                  </div>
                `).join('')}
              </div>
            </div>
            
            <div>
              <h4 style="margin: 0 0 0.5rem 0; color: #1e293b;">Available Roles</h4>
              <div id="customRolesList" style="
                border: 2px dashed #e2e8f0;
                border-radius: 8px;
                padding: 1rem;
                min-height: 200px;
                background: #f8fafc;
              ">
                <p style="color: #64748b; text-align: center; margin: 2rem 0;">Create factions and characters first</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Copy & Paste Method -->
        <div id="pasteCreationMethod" style="display: none;">
          <div style="margin-bottom: 1.5rem;">
            <h3 style="margin: 0 0 1rem 0; color: #1e293b;">ü§ñ ChatGPT Integration</h3>
            <p style="color: #64748b; margin-bottom: 1rem;">Copy the prompt below, paste it into ChatGPT, fill in your scenario details, and paste the response back here.</p>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">ChatGPT Prompt (Copy this):</label>
              <textarea id="chatgptPrompt" readonly style="
                width: 100%;
                padding: 1rem;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 0.875rem;
                min-height: 200px;
                background: #f8fafc;
                font-family: monospace;
              ">Create a detailed scenario for a classroom war game based on: [YOUR SCENARIO HERE - e.g., "The War of 1812", "Romeo and Juliet", "Marvel vs DC", etc.]

Please format your response as a complete JSON object that can be directly imported into a game system. Include ALL of the following elements:

{
  "id": "unique_scenario_id",
  "name": "Scenario Name",
  "type": "historical|literary|fantasy|sci-fi|modern|other",
  "description": "Brief description of the scenario",
  "factions": {
    "faction1_key": {
      "name": "Faction Display Name",
      "color": "#hexcolor",
      "description": "Faction description",
      "territories": [
        {
          "name": "Territory Name",
          "cost": 100,
          "description": "Territory description"
        }
      ],
      "characters": [
        {
          "name": "Character Name",
          "role": "Character Role",
          "startingCoins": 150,
          "startingWeapons": ["weapon1", "weapon2"],
          "startingMercenaries": 5,
          "startingCastles": 4,
          "personality": "personality_type",
          "quotes": [
            "Character quote 1",
            "Character quote 2",
            "Character quote 3",
            "Character quote 4",
            "Character quote 5"
          ],
          "description": "Character description"
        }
      ],
      "generalRoles": [
        {
          "name": "General Role Name",
          "startingCoins": 30,
          "startingWeapons": [],
          "startingMercenaries": 0,
          "startingCastles": 0,
          "personality": "personality_type"
        }
      ]
    }
  },
  "neutralTerritories": [
    {
      "name": "Neutral Territory Name",
      "cost": 75,
      "description": "Neutral territory description"
    }
  ],
  "randomAssignment": true,
  "manualRoleAssignments": false,
  "aiAssignments": false
}
REQUIREMENTS:
- Create 2-4 factions with distinct themes and colors
- Each faction needs 8-10 territories with creative names and descriptions
- Each faction needs 5-8 named characters with unique personalities and 5 authentic quotes each
- Each faction needs 2-3 general roles for additional players
- Include 3-5 neutral territories
- Use appropriate hex colors (#000000 format) that are distinct and thematic
- Make quotes authentic to the character/setting
- Ensure all JSON syntax is valid
- Include ALL required fields exactly as shown above</textarea>
              <button onclick="copyChatGPTPrompt()" style="
                margin-top: 0.5rem;
                padding: 0.5rem 1rem;
                background: #3b82f6;
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 0.875rem;
              ">üìã Copy Prompt</button>
            </div>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: #1e293b;">Paste ChatGPT Response Here:</label>
              <textarea id="chatgptResponse" placeholder="Paste the JSON response from ChatGPT here..." style="
                width: 100%;
                padding: 1rem;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 0.875rem;
                min-height: 300px;
                font-family: monospace;
              "></textarea>
              <button onclick="parseChatGPTResponse()" style="
                margin-top: 0.5rem;
                padding: 0.5rem 1rem;
                background: #10b981;
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 0.875rem;
              ">‚úÖ Parse Response</button>
            </div>
            
            <div id="parseResult" style="
              padding: 1rem;
              border-radius: 8px;
              margin-top: 1rem;
              display: none;
            "></div>
          </div>
        </div>
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="closeCustomScenarioBuilder()" style="
            background: #64748b;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Cancel</button>
          <button onclick="randomizeCustomRoles()" style="
            background: #f59e0b;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Randomize All</button>
          <button onclick="saveCustomScenario()" style="
            background: #3b82f6;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Save Scenario</button>
          <button onclick="startCustomScenarioGame()" style="
            background: #10b981;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
          ">Start Game</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Initialize with default factions
    updateCustomFactions();
    initializeCustomDragDrop();
  }
  
  function closeCustomScenarioBuilder() {
    const modal = document.getElementById('customScenarioBuilder');
    if (modal) {
      modal.remove();
    }
  }

  // Switch between form and paste creation methods
  function switchCreationMethod(method) {
    const formMethod = document.getElementById('formCreationMethod');
    const pasteMethod = document.getElementById('pasteCreationMethod');
    const formBtn = document.getElementById('formMethodBtn');
    const pasteBtn = document.getElementById('pasteMethodBtn');
    
    if (method === 'form') {
      formMethod.style.display = 'block';
      pasteMethod.style.display = 'none';
      formBtn.style.background = '#3b82f6';
      formBtn.style.color = 'white';
      pasteBtn.style.background = 'white';
      pasteBtn.style.color = '#64748b';
    } else {
      formMethod.style.display = 'none';
      pasteMethod.style.display = 'block';
      pasteBtn.style.background = '#3b82f6';
      pasteBtn.style.color = 'white';
      formBtn.style.background = 'white';
      formBtn.style.color = '#64748b';
    }
  }

  // Copy ChatGPT prompt to clipboard
  function copyChatGPTPrompt() {
    const prompt = document.getElementById('chatgptPrompt');
    prompt.select();
    document.execCommand('copy');
    
    // Show feedback
    const button = event.target;
    const originalText = button.textContent;
    button.textContent = '‚úÖ Copied!';
    button.style.background = '#10b981';
    
    setTimeout(() => {
      button.textContent = originalText;
      button.style.background = '#3b82f6';
    }, 2000);
  }

  // Parse ChatGPT response and populate form
  function parseChatGPTResponse() {
    const response = document.getElementById('chatgptResponse').value.trim();
    const resultDiv = document.getElementById('parseResult');
    
    if (!response) {
      showParseResult('Please paste a response from ChatGPT first.', 'error');
      return;
    }
    
    try {
      // Try to parse JSON
      let scenarioData;
      try {
        scenarioData = JSON.parse(response);
      } catch (e) {
        // Try to extract JSON from markdown code blocks
        const jsonMatch = response.match(/```(?:json)?\s*(\{[\s\S]*\})\s*```/);
        if (jsonMatch) {
          scenarioData = JSON.parse(jsonMatch[1]);
        } else {
          throw new Error('No valid JSON found in response');
        }
      }
      
      // Validate required fields
      if (!scenarioData.id || !scenarioData.name || !scenarioData.factions) {
        throw new Error('Missing required fields: id, name, or factions');
      }
      
      // Populate form fields
      document.getElementById('customScenarioName').value = scenarioData.name;
      document.getElementById('customScenarioType').value = scenarioData.type || 'other';
      document.getElementById('customScenarioDescription').value = scenarioData.description || '';
      
      // Set faction count
      const factionCount = Object.keys(scenarioData.factions).length;
      document.getElementById('customFactionCount').value = Math.min(Math.max(factionCount, 2), 6);
      
      // Update factions
      updateCustomFactions();
      
      // Populate faction data
      Object.entries(scenarioData.factions).forEach(([factionKey, faction], index) => {
        const factionIndex = index;
        
        // Set faction name
        const factionNameInput = document.querySelector(`input[data-faction="${factionIndex}"].faction-name`);
        if (factionNameInput) factionNameInput.value = faction.name;
        
        // Set faction color
        const factionColorInput = document.querySelector(`input[data-faction="${factionIndex}"].faction-color`);
        if (factionColorInput) factionColorInput.value = faction.color;
        
        // Set faction description
        const factionDescInput = document.querySelector(`textarea[data-faction="${factionIndex}"].faction-description`);
        if (factionDescInput) factionDescInput.value = faction.description || '';
        
        // Add territories
        if (faction.territories) {
          faction.territories.forEach((territory, territoryIndex) => {
            const territoryInput = document.querySelector(`input[data-faction="${factionIndex}"][data-territory="${territoryIndex}"].territory-name`);
            if (territoryInput) territoryInput.value = territory.name;
          });
        }
        
        // Add characters
        if (faction.characters) {
          faction.characters.forEach((character, charIndex) => {
            const charNameInput = document.querySelector(`input[data-faction="${factionIndex}"][data-char="${charIndex}"].char-name`);
            if (charNameInput) charNameInput.value = character.name;
            
            const charRoleInput = document.querySelector(`input[data-faction="${factionIndex}"][data-char="${charIndex}"].char-role`);
            if (charRoleInput) charRoleInput.value = character.role;
          });
        }
      });
      
      // Store the parsed data for later use
      window.parsedScenarioData = scenarioData;
      
      showParseResult(`‚úÖ Successfully parsed scenario "${scenarioData.name}" with ${factionCount} factions!`, 'success');
      
    } catch (error) {
      showParseResult(`‚ùå Error parsing response: ${error.message}`, 'error');
    }
  }

  function showParseResult(message, type) {
    const resultDiv = document.getElementById('parseResult');
    resultDiv.style.display = 'block';
    resultDiv.style.background = type === 'success' ? '#d1fae5' : '#fee2e2';
    resultDiv.style.color = type === 'success' ? '#065f46' : '#991b1b';
    resultDiv.style.border = `2px solid ${type === 'success' ? '#10b981' : '#ef4444'}`;
    resultDiv.textContent = message;
  }
  
  function updateCustomFactions() {
    const factionCount = parseInt(document.getElementById('customFactionCount').value);
    const container = document.getElementById('customFactionsContainer');
    
    container.innerHTML = '';
    
    const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'];
    
    for (let i = 0; i < factionCount; i++) {
      const factionDiv = document.createElement('div');
      factionDiv.style.cssText = `
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
      `;
      
      factionDiv.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
          <div style="width: 20px; height: 20px; background: ${colors[i]}; border-radius: 50%; margin-right: 0.5rem;"></div>
          <input type="text" placeholder="Faction ${i + 1} Name" class="faction-name" data-faction-index="${i}" style="
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-weight: 600;
          ">
        </div>
        <textarea placeholder="Faction description..." class="faction-description" data-faction-index="${i}" style="
          width: 100%;
          padding: 0.5rem;
          border: 1px solid #e2e8f0;
          border-radius: 4px;
          font-size: 0.875rem;
          min-height: 60px;
          resize: vertical;
        "></textarea>
      `;
      
      container.appendChild(factionDiv);
    }
    
    // Update characters and territories
    updateCustomCharacters();
    updateCustomTerritories();
  }
  
  function updateCustomCharacters() {
    const charactersPerFaction = parseInt(document.getElementById('charactersPerFaction').value);
    const factionCount = parseInt(document.getElementById('customFactionCount').value);
    const container = document.getElementById('customCharactersContainer');
    
    container.innerHTML = '<h4 style="margin: 0 0 0.5rem 0; color: #1e293b;">Characters</h4>';
    
    const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'];
    
    for (let factionIndex = 0; factionIndex < factionCount; factionIndex++) {
      const factionDiv = document.createElement('div');
      factionDiv.style.cssText = `
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
        border-left: 4px solid ${colors[factionIndex]};
      `;
      
      factionDiv.innerHTML = `
        <h5 style="margin: 0 0 0.5rem 0; color: #1e293b;">Faction ${factionIndex + 1} Characters</h5>
        <div class="characters-list" data-faction-index="${factionIndex}">
          ${Array.from({length: charactersPerFaction}, (_, charIndex) => `
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr; gap: 0.5rem; margin-bottom: 0.5rem;">
              <input type="text" placeholder="Character name" class="char-name" data-faction="${factionIndex}" data-char="${charIndex}" style="padding: 0.5rem; border: 1px solid #e2e8f0; border-radius: 4px;">
              <input type="text" placeholder="Role" class="char-role" data-faction="${factionIndex}" data-char="${charIndex}" style="padding: 0.5rem; border: 1px solid #e2e8f0; border-radius: 4px;">
              <input type="number" placeholder="Coins" class="char-coins" data-faction="${factionIndex}" data-char="${charIndex}" value="100" min="0" style="padding: 0.5rem; border: 1px solid #e2e8f0; border-radius: 4px;">
              <input type="text" placeholder="Weapons" class="char-weapons" data-faction="${factionIndex}" data-char="${charIndex}" style="padding: 0.5rem; border: 1px solid #e2e8f0; border-radius: 4px;">
              <input type="number" placeholder="Castles" class="char-castles" data-faction="${factionIndex}" data-char="${charIndex}" value="1" min="0" style="padding: 0.5rem; border: 1px solid #e2e8f0; border-radius: 4px;">
            </div>
          `).join('')}
        </div>
      `;
      
      container.appendChild(factionDiv);
    }
    
    updateCustomRolesList();
  }
  
  function updateCustomTerritories() {
    const territoriesPerFaction = parseInt(document.getElementById('territoriesPerFaction').value);
    const factionCount = parseInt(document.getElementById('customFactionCount').value);
    const container = document.getElementById('customTerritoriesContainer');
    
    container.innerHTML = '<h4 style="margin: 0 0 0.5rem 0; color: #1e293b;">Territories</h4>';
    
    const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'];
    
    for (let factionIndex = 0; factionIndex < factionCount; factionIndex++) {
      const factionDiv = document.createElement('div');
      factionDiv.style.cssText = `
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
        border-left: 4px solid ${colors[factionIndex]};
      `;
      
      factionDiv.innerHTML = `
        <h5 style="margin: 0 0 0.5rem 0; color: #1e293b;">Faction ${factionIndex + 1} Territories</h5>
        <div class="territories-list" data-faction-index="${factionIndex}">
          ${Array.from({length: territoriesPerFaction}, (_, terrIndex) => `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.5rem;">
              <input type="text" placeholder="Territory name" class="terr-name" data-faction="${factionIndex}" data-terr="${terrIndex}" style="padding: 0.5rem; border: 1px solid #e2e8f0; border-radius: 4px;">
              <input type="number" placeholder="Cost" class="terr-cost" data-faction="${factionIndex}" data-terr="${terrIndex}" value="50" min="0" style="padding: 0.5rem; border: 1px solid #e2e8f0; border-radius: 4px;">
            </div>
          `).join('')}
        </div>
      `;
      
      container.appendChild(factionDiv);
    }
  }
  
  function updateCustomRolesList() {
    const rolesList = document.getElementById('customRolesList');
    const factionCount = parseInt(document.getElementById('customFactionCount').value);
    const charactersPerFaction = parseInt(document.getElementById('charactersPerFaction').value);
    
    if (factionCount === 0) {
      rolesList.innerHTML = '<p style="color: #64748b; text-align: center; margin: 2rem 0;">Create factions and characters first</p>';
      return;
    }
    
    rolesList.innerHTML = '';
    const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'];
    
    for (let factionIndex = 0; factionIndex < factionCount; factionIndex++) {
      for (let charIndex = 0; charIndex < charactersPerFaction; charIndex++) {
        const roleCard = document.createElement('div');
        roleCard.className = 'custom-role-card';
        roleCard.dataset.factionIndex = factionIndex;
        roleCard.dataset.charIndex = charIndex;
        roleCard.style.cssText = `
          background: white;
          border: 1px solid #e2e8f0;
          border-radius: 6px;
          padding: 0.75rem;
          margin-bottom: 0.5rem;
          cursor: move;
          transition: all 0.2s ease;
          border-left: 4px solid ${colors[factionIndex]};
        `;
        
        roleCard.innerHTML = `
          <div style="font-weight: 600; color: #1e293b;">Character ${charIndex + 1}</div>
          <div style="font-size: 0.875rem; color: #64748b;">Faction ${factionIndex + 1}</div>
          <div style="font-size: 0.75rem; color: #94a3b8;">üí∞100 ‚Ä¢ ‚öîÔ∏èSword ‚Ä¢ üè∞1</div>
        `;
        
        rolesList.appendChild(roleCard);
      }
    }
  }
  
  function initializeCustomDragDrop() {
    const studentsList = document.getElementById('customStudentsList');
    const rolesList = document.getElementById('customRolesList');
    
    // Make students draggable
    studentsList.querySelectorAll('.custom-student-card').forEach(card => {
      card.addEventListener('dragstart', function(e) {
        e.dataTransfer.setData('text/plain', this.dataset.studentId);
        e.dataTransfer.effectAllowed = 'move';
        this.style.opacity = '0.5';
      });
      
      card.addEventListener('dragend', function(e) {
        this.style.opacity = '1';
      });
    });
    
    // Make roles droppable
    rolesList.addEventListener('click', function(e) {
      const roleCard = e.target.closest('.custom-role-card');
      if (roleCard) {
        roleCard.style.backgroundColor = '#f0f9ff';
        setTimeout(() => {
          roleCard.style.backgroundColor = 'white';
        }, 200);
      }
    });
  }
  
  function randomizeCustomRoles() {
    const students = Array.from(document.querySelectorAll('.custom-student-card')).filter(card => card.draggable);
    const roles = Array.from(document.querySelectorAll('.custom-role-card')).filter(card => !card.dataset.assignedStudent);
    
    // Shuffle students
    for (let i = students.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [students[i], students[j]] = [students[j], students[i]];
    }
    
    // Assign students to roles
    students.forEach((student, index) => {
      if (index < roles.length) {
        const role = roles[index];
        const studentId = student.dataset.studentId;
        
        // Create assigned student element
        const assignedStudent = document.createElement('div');
        assignedStudent.className = 'student-assigned';
        assignedStudent.style.cssText = `
          background: #10b981;
          color: white;
          padding: 0.5rem;
          border-radius: 4px;
          margin-top: 0.5rem;
          font-size: 0.875rem;
        `;
        assignedStudent.textContent = student.querySelector('div').textContent;
        
        role.appendChild(assignedStudent);
        
        // Update student card
        student.querySelector('div:last-child').textContent = role.querySelector('div').textContent;
        student.style.opacity = '0.6';
        student.draggable = false;
        
        // Store assignment
        role.dataset.assignedStudent = studentId;
      }
    });
  }
  
  function saveCustomScenario() {
    const scenarioName = document.getElementById('customScenarioName').value.trim();
    const scenarioType = document.getElementById('customScenarioType').value;
    const scenarioDescription = document.getElementById('customScenarioDescription').value.trim();
    
    if (!scenarioName) {
      alert('Please enter a scenario name.');
      return;
    }
    
    // Collect faction data
    const factions = {};
    const factionCount = parseInt(document.getElementById('customFactionCount').value);
    const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'];
    
    for (let i = 0; i < factionCount; i++) {
      const factionName = document.querySelector(`input[data-faction-index="${i}"].faction-name`).value.trim();
      const factionDescription = document.querySelector(`textarea[data-faction-index="${i}"].faction-description`).value.trim();
      
      if (!factionName) {
        alert(`Please enter a name for Faction ${i + 1}.`);
        return;
      }
      
      // Collect characters
      const characters = [];
      const charactersPerFaction = parseInt(document.getElementById('charactersPerFaction').value);
      
      for (let charIndex = 0; charIndex < charactersPerFaction; charIndex++) {
        const charName = document.querySelector(`input[data-faction="${i}"][data-char="${charIndex}"].char-name`).value.trim();
        const charRole = document.querySelector(`input[data-faction="${i}"][data-char="${charIndex}"].char-role`).value.trim();
        const charCoins = parseInt(document.querySelector(`input[data-faction="${i}"][data-char="${charIndex}"].char-coins`).value) || 100;
        const charWeapons = document.querySelector(`input[data-faction="${i}"][data-char="${charIndex}"].char-weapons`).value.trim() || 'Sword';
        const charCastles = parseInt(document.querySelector(`input[data-faction="${i}"][data-char="${charIndex}"].char-castles`).value) || 1;
        
        if (charName) {
          characters.push({
            id: `char_${i}_${charIndex}`,
            name: charName,
            role: charRole || `Character ${charIndex + 1}`,
            startingResources: {
              coins: charCoins,
              weapons: charWeapons.split(',').map(w => w.trim()).filter(w => w),
              mercenaries: 0,
              castles: charCastles
            },
            personality: 'Balanced',
            quotes: ['Let\'s make our move!', 'Time for action!', 'Forward!', 'We can do this!', 'Victory awaits!'],
            history: `${charName} is a key character in this scenario.`
          });
        }
      }
      
      // Collect territories
      const territories = [];
      const territoriesPerFaction = parseInt(document.getElementById('territoriesPerFaction').value);
      
      for (let terrIndex = 0; terrIndex < territoriesPerFaction; terrIndex++) {
        const terrName = document.querySelector(`input[data-faction="${i}"][data-terr="${terrIndex}"].terr-name`).value.trim();
        const terrCost = parseInt(document.querySelector(`input[data-faction="${i}"][data-terr="${terrIndex}"].terr-cost`).value) || 50;
        
        if (terrName) {
          territories.push({
            name: terrName,
            cost: terrCost,
            description: `${terrName} is an important territory for ${factionName}.`
          });
        }
      }
      
      factions[`faction_${i}`] = {
        name: factionName,
        color: colors[i],
        description: factionDescription || `${factionName} is one of the main factions in this scenario.`,
        territories: territories,
        characters: characters,
        generalRoles: [
          {
            name: 'Soldier',
            startingCoins: 50,
            startingWeapons: ['Sword'],
            startingMercenaries: 0,
            startingCastles: 0,
            personality: 'Aggressive',
            quotes: ['For the cause!', 'Attack!', 'Victory!', 'Charge!', 'Fight!']
          }
        ]
      };
    }
    
    // Create scenario data
    const scenarioData = {
      id: `custom_${Date.now()}`,
      name: scenarioName,
      type: scenarioType,
      description: scenarioDescription,
      factions: factions,
      neutralTerritories: Array.from({length: parseInt(document.getElementById('neutralTerritories').value)}, (_, i) => ({
        name: `Neutral Territory ${i + 1}`,
        cost: 75,
        description: `A neutral territory that can be claimed by any faction.`
      }))
    };
    
    // Save to localStorage
    const customScenarios = JSON.parse(localStorage.getItem('customScenarios') || '[]');
    customScenarios.push(scenarioData);
    localStorage.setItem('customScenarios', JSON.stringify(customScenarios));
    
    alert(`Custom scenario "${scenarioName}" saved successfully!`);
  }
  function startCustomScenarioGame() {
    const scenarioName = document.getElementById('customScenarioName').value.trim();
    
    if (!scenarioName) {
      alert('Please enter a scenario name and save it first.');
      return;
    }
    
    // Get the saved scenario
    const customScenarios = JSON.parse(localStorage.getItem('customScenarios') || '[]');
    const scenario = customScenarios.find(s => s.name === scenarioName);
    
    if (!scenario) {
      alert('Please save the scenario first.');
      return;
    }
    
    // Collect role assignments
    const roleAssignments = {};
    document.querySelectorAll('.custom-role-card[data-assigned-student]').forEach(roleCard => {
      const studentId = roleCard.dataset.assignedStudent;
      const factionIndex = roleCard.dataset.factionIndex;
      const charIndex = roleCard.dataset.charIndex;
      const charName = document.querySelector(`input[data-faction="${factionIndex}"][data-char="${charIndex}"].char-name`).value.trim();
      roleAssignments[studentId] = charName || `Character ${parseInt(charIndex) + 1}`;
    });
    
    // Create scenario data for the roster
    const scenarioData = {
      scenarioId: scenario.id,
      scenarioName: scenario.name,
      scenarioType: scenario.type,
      factions: scenario.factions,
      neutralTerritories: scenario.neutralTerritories,
      randomAssignment: Object.keys(roleAssignments).length === 0,
      manualRoleAssignments: roleAssignments,
      enableAI: false,
      aiDifficulty: 'medium'
    };
    
    // Update current roster with scenario data
    state.currentRoster.scenario = scenarioData;
    
    // Close modal
    closeCustomScenarioBuilder();
    
    // Initialize scenario
    initializeScenario(scenarioData);
    
    // Reset game with scenario
    resetGameToDefaults();
    
    // Show scenario info
    showScenarioInfo(scenarioData);
  }

  function showRoleAssignmentModal(scenario) {
    const modal = document.createElement('div');
    modal.id = 'roleAssignmentModal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1002;
    `;
    
    // Get all available characters from all factions
    const allCharacters = [];
    Object.values(scenario.factions).forEach(faction => {
      faction.characters.forEach(char => {
        allCharacters.push({
          ...char,
          factionName: faction.name,
          factionColor: faction.color
        });
      });
    });
    
    // Add general roles
    Object.values(scenario.factions).forEach(faction => {
      faction.generalRoles.forEach(role => {
        allCharacters.push({
          name: `${role.name} (${faction.name})`,
          role: role.name,
          factionName: faction.name,
          factionColor: faction.color,
          startingCoins: role.startingCoins,
          startingWeapons: role.startingWeapons,
          startingMercenaries: role.startingMercenaries,
          startingCastles: role.startingCastles,
          personality: role.personality,
          quotes: role.quotes,
          description: `${role.name} of ${faction.name}`,
          isGeneralRole: true
        });
      });
    });
    
    modal.innerHTML = `
      <div style="
        background: white;
        border-radius: 16px;
        padding: 2rem;
        max-width: 1000px;
        width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: #1e293b; font-size: 1.5rem;">üë• Assign Student Roles</h2>
          <button onclick="closeRoleAssignmentModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b;">&times;</button>
        </div>
        
        <p style="margin-bottom: 1.5rem; color: #64748b;">
          Drag students to assign them to specific roles in the ${scenario.name} scenario:
        </p>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 1.5rem;">
          <!-- Students Column -->
          <div>
            <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Students</h3>
            <div id="studentsList" style="
              border: 2px dashed #e2e8f0;
              border-radius: 8px;
              padding: 1rem;
              min-height: 300px;
              background: #f8fafc;
            ">
              ${state.roster.map(student => `
                <div class="student-card" draggable="true" data-student-id="${student.gsId}" style="
                  background: white;
                  border: 1px solid #e2e8f0;
                  border-radius: 6px;
                  padding: 0.75rem;
                  margin-bottom: 0.5rem;
                  cursor: move;
                  transition: all 0.2s ease;
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.1)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                  <div style="font-weight: 600; color: #1e293b;">${student.name}</div>
                  <div style="font-size: 0.875rem; color: #64748b;">Unassigned</div>
                </div>
              `).join('')}
            </div>
          </div>
          
          <!-- Roles Column -->
          <div>
            <h3 style="margin: 0 0 1rem 0; color: #1e293b;">Available Roles</h3>
            <div id="rolesList" style="
              border: 2px dashed #e2e8f0;
              border-radius: 8px;
              padding: 1rem;
              min-height: 300px;
              background: #f8fafc;
            ">
              ${allCharacters.map(char => `
                <div class="role-card" data-role-id="${char.name}" style="
                  background: white;
                  border: 1px solid #e2e8f0;
                  border-radius: 6px;
                  padding: 0.75rem;
                  margin-bottom: 0.5rem;
                  cursor: move;
                  transition: all 0.2s ease;
                  border-left: 4px solid ${char.factionColor};
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.1)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                  <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
                    <div>
                      <div style="font-weight: 600; color: #1e293b;">${char.name}</div>
                      <div style="font-size: 0.875rem; color: #64748b;">${char.role} ‚Ä¢ ${char.factionName}</div>
                      <div style="font-size: 0.75rem; color: #94a3b8;">üí∞${char.startingCoins} ‚Ä¢ ‚öîÔ∏è${char.startingWeapons.join(', ')} ‚Ä¢ üè∞${char.startingCastles}</div>
                    </div>
                    <label style="display:flex; align-items:center; gap:4px; font-size:12px; color:#334155; user-select:none;">
                      <input type="checkbox" class="role-ai-toggle" style="margin:0;"> ü§ñ AI
                    </label>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        </div>
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="closeRoleAssignmentModal()" style="
            background: #64748b;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Cancel</button>
          <button onclick="randomizeAllRoles()" style="
            background: #f59e0b;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Randomize All</button>
          <button onclick="startGameWithManualRoles()" style="
            background: #10b981;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
          ">Start Game</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Initialize drag and drop
    initializeRoleAssignmentDragDrop();
  }
  
  function closeRoleAssignmentModal() {
    const modal = document.getElementById('roleAssignmentModal');
    if (modal) {
      modal.remove();
    }
  }
  
  function initializeRoleAssignmentDragDrop() {
    const studentsList = document.getElementById('studentsList');
    const rolesList = document.getElementById('rolesList');
    
    // Make students draggable
    studentsList.querySelectorAll('.student-card').forEach(card => {
      card.addEventListener('dragstart', function(e) {
        e.dataTransfer.setData('text/plain', this.dataset.studentId);
        e.dataTransfer.effectAllowed = 'move';
        this.style.opacity = '0.5';
      });
      
      card.addEventListener('dragend', function(e) {
        this.style.opacity = '1';
      });
    });
    
    // Make roles droppable
    rolesList.querySelectorAll('.role-card').forEach(card => {
      card.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        this.style.backgroundColor = '#f0f9ff';
      });
      
      card.addEventListener('dragleave', function(e) {
        this.style.backgroundColor = 'white';
      });
      
      card.addEventListener('drop', function(e) {
        e.preventDefault();
        this.style.backgroundColor = 'white';
        
        // If this role is flagged as AI, do not allow student drop
        if (this.dataset.ai === 'true') {
          return;
        }

        const studentId = e.dataTransfer.getData('text/plain');
        const studentCard = document.querySelector(`[data-student-id="${studentId}"]`);
        
        if (studentCard && !this.querySelector('.student-assigned')) {
          // Create assigned student element
          const assignedStudent = document.createElement('div');
          assignedStudent.className = 'student-assigned';
          assignedStudent.style.cssText = `
            background: #10b981;
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            margin-top: 0.5rem;
            font-size: 0.875rem;
          `;
          assignedStudent.textContent = studentCard.querySelector('div').textContent;
          
          this.appendChild(assignedStudent);
          
          // Update student card
          studentCard.querySelector('div:last-child').textContent = this.querySelector('div').textContent;
          studentCard.style.opacity = '0.6';
          studentCard.draggable = false;
          
          // Store assignment
          this.dataset.assignedStudent = studentId;
        }
      });
    });
  }

  // Toggle handlers for per-role AI flags
  document.addEventListener('change', function(e) {
    if (e.target && e.target.classList && e.target.classList.contains('role-ai-toggle')) {
      const roleCard = e.target.closest('.role-card');
      if (!roleCard) return;
      const isAI = e.target.checked;
      roleCard.dataset.ai = isAI ? 'true' : 'false';

      // If marking AI, clear any student assignment visual and dataset
      if (isAI) {
        const assigned = roleCard.querySelector('.student-assigned');
        if (assigned) assigned.remove();
        delete roleCard.dataset.assignedStudent;
      }
    }
  });
  
  function randomizeAllRoles() {
    const students = Array.from(document.querySelectorAll('.student-card')).filter(card => card.draggable);
    const roles = Array.from(document.querySelectorAll('.role-card')).filter(card => !card.dataset.assignedStudent);
    
    // Shuffle students
    for (let i = students.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [students[i], students[j]] = [students[j], students[i]];
    }
    
    // Assign students to roles
    students.forEach((student, index) => {
      if (index < roles.length) {
        const role = roles[index];
        const studentId = student.dataset.studentId;
        
        // Create assigned student element
        const assignedStudent = document.createElement('div');
        assignedStudent.className = 'student-assigned';
        assignedStudent.style.cssText = `
          background: #10b981;
          color: white;
          padding: 0.5rem;
          border-radius: 4px;
          margin-top: 0.5rem;
          font-size: 0.875rem;
        `;
        assignedStudent.textContent = student.querySelector('div').textContent;
        
        role.appendChild(assignedStudent);
        
        // Update student card
        student.querySelector('div:last-child').textContent = role.querySelector('div').textContent;
        student.style.opacity = '0.6';
        student.draggable = false;
        
        // Store assignment
        role.dataset.assignedStudent = studentId;
      }
    });
  }
  
  function startGameWithManualRoles() {
    // Collect role assignments
    const roleAssignments = {};
    const aiAssignments = {};
    document.querySelectorAll('.role-card[data-assigned-student]').forEach(roleCard => {
      const studentId = roleCard.dataset.assignedStudent;
      const roleName = roleCard.querySelector('div').textContent;
      roleAssignments[studentId] = roleName;
    });

    // Collect AI flagged roles
    document.querySelectorAll('.role-card[data-ai="true"]').forEach(roleCard => {
      const roleName = roleCard.querySelector('div').textContent;
      const factionLabel = roleCard.querySelector('div + div');
      const factionText = factionLabel ? factionLabel.textContent : '';
      const factionName = factionText.includes('‚Ä¢') ? factionText.split('‚Ä¢').pop().trim() : '';
      aiAssignments[roleName] = {
        studentId: null,
        studentName: null,
        roleName: roleName,
        factionName: factionName,
        isAI: true
      };
    });
    
    // Update scenario data with manual assignments
    const scenarioData = state.currentRoster.scenario;
    scenarioData.manualRoleAssignments = roleAssignments;
    if (Object.keys(aiAssignments).length > 0) {
      scenarioData.aiAssignments = aiAssignments;
    }
    
    // Initialize scenario
    initializeScenario(scenarioData);
    
    // Close modal
    closeRoleAssignmentModal();
    
    // Reset game with scenario
    resetGameToDefaults();
    
    // Show scenario info
    showScenarioInfo(scenarioData);
  }

  // Get theme-appropriate market items based on current scenario
  function getThemeAppropriateMarketItems() {
    const economy = getActiveEconomy();
    
    if (!state.scenario || !state.scenario.scenarioId) {
      // Default items if no scenario
      return {
        weapons: [
          { name: 'Spear', description: '+15 attack power', cost: economy.weapons.spear },
          { name: 'Crossbow', description: '+20 attack power', cost: economy.weapons.crossbow },
          { name: 'Catapult', description: '+30 attack power', cost: economy.weapons.catapult }
        ],
        allies: [
          { name: 'War Elephant', description: 'Powerful war beast', cost: Math.round(150 * (economy.weapons.spear / 40)) },
          { name: 'Siege Engine', description: 'Heavy siege weapon', cost: Math.round(200 * (economy.weapons.spear / 40)) }
        ]
      };
    }

    const scenarioId = state.scenario.scenarioId;
    
    switch (scenarioId) {
      case 'harryPotter':
        return {
          weapons: [
            { name: 'Wand', description: '+15 magical power', cost: economy.weapons.spear },
            { name: 'Enchanted Sword', description: '+20 magical power', cost: economy.weapons.crossbow },
            { name: 'Elder Wand', description: '+30 magical power', cost: economy.weapons.catapult }
          ],
          allies: [
            { name: 'Phoenix', description: 'Magical ally', cost: Math.round(150 * (economy.weapons.spear / 40)) },
            { name: 'Hungarian Horntail', description: 'Powerful dragon ally', cost: Math.round(200 * (economy.weapons.spear / 40)) }
          ]
        };
      
      case 'worldWar2':
        return {
          weapons: [
            { name: 'Rifle', description: '+15 attack power', cost: 40 },
            { name: 'Machine Gun', description: '+20 attack power', cost: 80 },
            { name: 'Artillery', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'Tank Battalion', description: 'Armored division', cost: 150 },
            { name: 'Air Squadron', description: 'Fighter aircraft', cost: 200 }
          ]
        };
      
      case 'starWars':
        return {
          weapons: [
            { name: 'Blaster', description: '+15 attack power', cost: 40 },
            { name: 'Lightsaber', description: '+20 attack power', cost: 80 },
            { name: 'Death Star', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'X-Wing Squadron', description: 'Fighter squadron', cost: 150 },
            { name: 'Millennium Falcon', description: 'Fast transport', cost: 200 }
          ]
        };
      
      case 'animalFarm':
        return {
          weapons: [
            { name: 'Pitchfork', description: '+15 attack power', cost: economy.weapons.spear },
            { name: 'Scythe', description: '+20 attack power', cost: economy.weapons.crossbow },
            { name: 'Windmill', description: '+30 attack power', cost: economy.weapons.catapult }
          ],
          allies: [
            { name: 'Farm Dog Pack', description: 'Loyal farm dogs', cost: Math.round(150 * (economy.weapons.spear / 40)) },
            { name: 'Wild Boar', description: 'Fierce wild boar', cost: Math.round(200 * (economy.weapons.spear / 40)) }
          ]
        };
      
      case 'romeoJuliet':
        return {
          weapons: [
            { name: 'Rapier', description: '+15 attack power', cost: 40 },
            { name: 'Dagger', description: '+20 attack power', cost: 80 },
            { name: 'Poison Vial', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'City Guards', description: 'Verona city guards', cost: 150 },
            { name: 'Friar Laurence', description: 'Wise friar ally', cost: 200 }
          ]
        };
      
      case 'lordOfTheRings':
        return {
          weapons: [
            { name: 'Elven Bow', description: '+15 attack power', cost: 40 },
            { name: 'Orcish Axe', description: '+20 attack power', cost: 80 },
            { name: 'Ring of Power', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'Ent Army', description: 'Tree-like creatures', cost: 150 },
            { name: 'Eagle Squadron', description: 'Giant eagles', cost: 200 }
          ]
        };
      
      case 'marvelVsDC':
        return {
          weapons: [
            { name: 'Vibranium Shield', description: '+15 attack power', cost: 40 },
            { name: 'Kryptonite', description: '+20 attack power', cost: 80 },
            { name: 'Infinity Gauntlet', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'Avengers Squad', description: 'Superhero team', cost: 150 },
            { name: 'Justice League', description: 'DC superheroes', cost: 200 }
          ]
        };
      
      case 'fortniteVsMinecraft':
        return {
          weapons: [
            { name: 'Assault Rifle', description: '+15 attack power', cost: 40 },
            { name: 'Diamond Sword', description: '+20 attack power', cost: 80 },
            { name: 'Rocket Launcher', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'Battle Bus', description: 'Fortnite transport', cost: 150 },
            { name: 'Ender Dragon', description: 'Minecraft boss', cost: 200 }
          ]
        };
      
      case 'romanMythology':
        return {
          weapons: [
            { name: 'Gladius', description: '+15 attack power', cost: 40 },
            { name: 'Thunderbolt', description: '+20 attack power', cost: 80 },
            { name: 'Trident', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'Centaur Army', description: 'Half-horse warriors', cost: 150 },
            { name: 'Minotaur', description: 'Labyrinth guardian', cost: 200 }
          ]
        };
      
      case 'percyJackson':
        return {
          weapons: [
            { name: 'Celestial Bronze Sword', description: '+15 attack power', cost: 40 },
            { name: 'Riptide', description: '+20 attack power', cost: 80 },
            { name: 'Master Bolt', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'Pegasus', description: 'Flying horse', cost: 150 },
            { name: 'Cerberus', description: 'Three-headed dog', cost: 200 }
          ]
        };
      
      case 'monsterWars':
        return {
          weapons: [
            { name: 'Wooden Stake', description: '+15 attack power', cost: 40 },
            { name: 'Silver Bullet', description: '+20 attack power', cost: 80 },
            { name: 'Holy Water', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'Vampire Bat Swarm', description: 'Flying creatures', cost: 150 },
            { name: 'Werewolf Pack', description: 'Moon-touched wolves', cost: 200 }
          ]
        };
      
      case 'nbaLegends':
        return {
          weapons: [
            { name: 'Basketball', description: '+15 attack power', cost: 40 },
            { name: 'Sneakers', description: '+20 attack power', cost: 80 },
            { name: 'Championship Ring', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'Dream Team', description: 'All-star lineup', cost: 150 },
            { name: 'Hall of Fame', description: 'Legendary players', cost: 200 }
          ]
        };
      
      case 'nflLegends':
        return {
          weapons: [
            { name: 'Football', description: '+15 attack power', cost: 40 },
            { name: 'Helmet', description: '+20 attack power', cost: 80 },
            { name: 'Super Bowl Trophy', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'All-Pro Team', description: 'Elite players', cost: 150 },
            { name: 'Hall of Fame', description: 'Legendary players', cost: 200 }
          ]
        };
      
      case 'soccerLegends':
        return {
          weapons: [
            { name: 'Soccer Ball', description: '+15 attack power', cost: 40 },
            { name: 'Cleats', description: '+20 attack power', cost: 80 },
            { name: 'World Cup Trophy', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'Dream Team', description: 'All-star lineup', cost: 150 },
            { name: 'Hall of Fame', description: 'Legendary players', cost: 200 }
          ]
        };
      
      case 'rockPopRap':
        return {
          weapons: [
            { name: 'Electric Guitar', description: '+15 attack power', cost: 40 },
            { name: 'Microphone', description: '+20 attack power', cost: 80 },
            { name: 'Grammy Award', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'Backup Band', description: 'Musical support', cost: 150 },
            { name: 'Record Label', description: 'Industry backing', cost: 200 }
          ]
        };
      
      case 'americanRevolution':
        return {
          weapons: [
            { name: 'Musket', description: '+15 attack power', cost: 40 },
            { name: 'Cannon', description: '+20 attack power', cost: 80 },
            { name: 'Naval Fleet', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'Continental Army', description: 'Revolutionary forces', cost: 150 },
            { name: 'French Navy', description: 'Allied naval support', cost: 200 }
          ]
        };
      
      default:
        return {
          weapons: [
            { name: 'Spear', description: '+15 attack power', cost: 40 },
            { name: 'Crossbow', description: '+20 attack power', cost: 80 },
            { name: 'Catapult', description: '+30 attack power', cost: 140 }
          ],
          allies: [
            { name: 'War Elephant', description: 'Powerful war beast', cost: 150 },
            { name: 'Siege Engine', description: 'Heavy siege weapon', cost: 200 }
          ]
        };
    }
  }
  function showStudentMarket(studentGsId) {
    const student = state.roster.find(s => s.gsId === studentGsId);
    
    if (!student) {
      alert('Student not found!');
      return;
    }
    
    // Initialize student's purchased items if not exists
    if (!student.purchasedItems) {
      student.purchasedItems = {
        weapons: [],
        mercenaries: 0,
        allies: [],
        spells: []
      };
    }
    
    const marketItems = getThemeAppropriateMarketItems();
    
    const modal = document.createElement('div');
    modal.id = 'studentMarketModal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1005;
    `;
    
    modal.innerHTML = `
      <div style="
        background: white;
        border-radius: 16px;
        padding: 2rem;
        max-width: 800px;
        width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
          <h2 style="margin: 0; color: #1e293b; font-size: 1.5rem;">üõí Student Market - ${student.name}</h2>
          <button onclick="closeStudentMarket()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #64748b;">&times;</button>
        </div>
        
        <div style="background: #f8fafc; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <div style="font-weight: 600; color: #1e293b;">üí∞ Balance: ${formatMoney(student.balance)}</div>
              <div style="font-size: 0.875rem; color: #64748b;">Character: ${student.characterName || 'None'}</div>
            </div>
            <div style="text-align: right;">
              <div style="font-size: 0.875rem; color: #64748b;">Current Items:</div>
              <div style="font-size: 0.75rem; color: #64748b;">
                ‚öîÔ∏è ${student.purchasedItems.weapons.length} weapons | 
                üë• ${student.purchasedItems.mercenaries} mercenaries | 
                üßô ${student.purchasedItems.allies.length} allies | 
                ‚ú® ${student.purchasedItems.spells.length} spells
              </div>
            </div>
          </div>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 1.5rem;">
          <!-- Weapons Section -->
          <div>
            <h3 style="margin: 0 0 1rem 0; color: #1e293b;">‚öîÔ∏è Weapons</h3>
            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
              ${marketItems.weapons.map(weapon => `
                <div class="market-item" data-type="weapon" data-item="${weapon.name.toLowerCase().replace(/\s+/g, '_')}" data-cost="${weapon.cost}" style="
                  background: #f8fafc;
                  border: 1px solid #e2e8f0;
                  border-radius: 6px;
                  padding: 0.75rem;
                  cursor: pointer;
                  transition: all 0.2s ease;
                " onmouseover="this.style.backgroundColor='#f0f9ff'" onmouseout="this.style.backgroundColor='#f8fafc'">
                  <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                      <div style="font-weight: 600; color: #1e293b;">${weapon.name}</div>
                      <div style="font-size: 0.75rem; color: #64748b;">${weapon.description}</div>
                    </div>
                    <div style="font-weight: 600; color: #059669;">${weapon.cost} pts</div>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
          
          <!-- Mercenaries & Allies Section -->
          <div>
            <h3 style="margin: 0 0 1rem 0; color: #1e293b;">üë• Mercenaries & Allies</h3>
            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
              <div class="market-item" data-type="mercenary" data-item="mercenary" data-cost="15" style="
                background: #f8fafc;
                border: 1px solid #e2e8f0;
                border-radius: 6px;
                padding: 0.75rem;
                cursor: pointer;
                transition: all 0.2s ease;
              " onmouseover="this.style.backgroundColor='#f0f9ff'" onmouseout="this.style.backgroundColor='#f8fafc'">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <div>
                    <div style="font-weight: 600; color: #1e293b;">Mercenary</div>
                    <div style="font-size: 0.75rem; color: #64748b;">+10 attack power each</div>
                  </div>
                  <div style="font-weight: 600; color: #059669;">15 pts</div>
                </div>
              </div>
              
              ${marketItems.allies.map(ally => `
                <div class="market-item" data-type="ally" data-item="${ally.name.toLowerCase().replace(/\s+/g, '_')}" data-cost="${ally.cost}" style="
                  background: #f8fafc;
                  border: 1px solid #e2e8f0;
                  border-radius: 6px;
                  padding: 0.75rem;
                  cursor: pointer;
                  transition: all 0.2s ease;
                " onmouseover="this.style.backgroundColor='#f0f9ff'" onmouseout="this.style.backgroundColor='#f8fafc'">
                  <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                      <div style="font-weight: 600; color: #1e293b;">${ally.name}</div>
                      <div style="font-size: 0.75rem; color: #64748b;">${ally.description}</div>
                    </div>
                    <div style="font-weight: 600; color: #059669;">${ally.cost} pts</div>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        </div>
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="closeStudentMarket()" style="
            background: #64748b;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 1rem;
          ">Close Market</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Add click handlers for market items
    modal.querySelectorAll('.market-item').forEach(item => {
      item.onclick = () => {
        const type = item.dataset.type;
        const itemName = item.dataset.item;
        const cost = parseInt(item.dataset.cost);
        
        if (student.balance < cost) {
          alert(`Insufficient funds! Need ${cost} points but have ${student.balance}.`);
          return;
        }
        
        // Purchase item
        student.balance -= cost;
        
        if (type === 'weapon') {
          student.purchasedItems.weapons.push(itemName);
        } else if (type === 'mercenary') {
          student.purchasedItems.mercenaries += 1;
        } else if (type === 'ally') {
          student.purchasedItems.allies.push(itemName);
        }
        
        // Update display
        renderRoster();
        closeStudentMarket();
        showStudentMarket(studentGsId); // Reopen to show updated balance
        
        alert(`${student.name} purchased ${itemName} for ${cost} points!`);
      };
    });
  }
  
  function closeStudentMarket() {
    const modal = document.getElementById('studentMarketModal');
    if (modal) {
      modal.remove();
    }
  }

  // Make function globally accessible
  window.closeStudentMarket = closeStudentMarket;

  function showTeacherTruceModal() {
    const selectedStudent = state.roster.find(s => s.gsId === state.selectedGsId);
    
    if (!selectedStudent) {
      alert('Selected student not found!');
      return;
    }

    // Get current truces for this student
    const currentTruces = state.truces.filter(truce => 
      truce.student1 === selectedStudent.gsId || truce.student2 === selectedStudent.gsId
    );

    // Get pending invitations sent to this student
    const incomingInvitations = (state.truceInvitations || []).filter(inv => 
      inv.toStudentId === selectedStudent.gsId
    );

    // Get pending invitations sent by this student
    const outgoingInvitations = (state.truceInvitations || []).filter(inv => 
      inv.fromStudentId === selectedStudent.gsId
    );

    // Get students this student can send truce to (not already in truce, not self, not already invited)
    const availableStudents = state.roster.filter(student => 
      student.gsId !== selectedStudent.gsId &&
      !currentTruces.some(truce => 
        truce.student1 === student.gsId || truce.student2 === student.gsId
      ) &&
      !outgoingInvitations.some(inv => inv.toStudentId === student.gsId) &&
      currentTruces.length < 3 // Limit to 3 truces
    );

    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background: rgba(0,0,0,0.8); z-index: 1000; display: flex; 
      align-items: center; justify-content: center; padding: 20px;
    `;
    
    modal.innerHTML = `
      <div style="background: var(--panel); border: 1px solid var(--border); border-radius: 12px; 
                  padding: 24px; max-width: 800px; max-height: 80vh; overflow-y: auto;">
        <h2 style="margin: 0 0 16px; color: var(--accent);">ü§ù Truce Management - ${selectedStudent.name} (Teacher View)</h2>
        
        <div style="background: #1e3a8a; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
          <h4 style="margin: 0 0 8px; color: #60a5fa;">üìä Truce Status</h4>
          <p style="margin: 4px 0; color: #93c5fd;">Current Truces: ${currentTruces.length}/3</p>
          <p style="margin: 4px 0; color: #93c5fd;">Pending Invitations: ${incomingInvitations.length}</p>
          <p style="margin: 4px 0; color: #93c5fd;">Teacher managing truces for: ${selectedStudent.name}</p>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
          <div>
            <h3 style="color: #10b981; margin: 0 0 12px;">üì® Incoming Invitations</h3>
            ${incomingInvitations.length === 0 ? 
              '<p style="color: var(--muted); font-style: italic;">No pending invitations</p>' :
              incomingInvitations.map(inv => {
                const fromStudent = state.roster.find(s => s.gsId === inv.fromStudentId);
                return `
                  <div style="background: #374151; padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span>From: ${fromStudent ? fromStudent.name : 'Unknown'}</span>
                      <div>
                        <button onclick="respondToTeacherTruce('${inv.id}', true)" style="background: #10b981; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; margin-right: 4px;">Accept</button>
                        <button onclick="respondToTeacherTruce('${inv.id}', false)" style="background: #ef4444; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer;">Deny</button>
                      </div>
                    </div>
                  </div>
                `;
              }).join('')
            }
          </div>
          
          <div>
            <h3 style="color: #3b82f6; margin: 0 0 12px;">üì§ Outgoing Invitations</h3>
            ${outgoingInvitations.length === 0 ? 
              '<p style="color: var(--muted); font-style: italic;">No pending invitations</p>' :
              outgoingInvitations.map(inv => {
                const toStudent = state.roster.find(s => s.gsId === inv.toStudentId);
                return `
                  <div style="background: #374151; padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                      <span>To: ${toStudent ? toStudent.name : 'Unknown'}</span>
                      <button onclick="cancelTeacherTruceInvitation('${inv.id}')" style="background: #6b7280; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer;">Cancel</button>
                    </div>
                  </div>
                `;
              }).join('')
            }
          </div>
        </div>
        
        <div style="margin-bottom: 16px;">
          <h3 style="color: #8b5cf6; margin: 0 0 12px;">ü§ù Current Truces</h3>
          ${currentTruces.length === 0 ? 
            '<p style="color: var(--muted); font-style: italic;">No active truces</p>' :
            currentTruces.map(truce => {
              const otherStudent = state.roster.find(s => 
                s.gsId === (truce.student1 === selectedStudent.gsId ? truce.student2 : truce.student1)
              );
              return `
                <div style="background: #374151; padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                  <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>With: ${otherStudent ? otherStudent.name : 'Unknown'}</span>
                    <button onclick="endTeacherTruce('${truce.id}')" style="background: #ef4444; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer;">End Truce</button>
                  </div>
                </div>
              `;
            }).join('')
          }
        </div>
        
        ${availableStudents.length > 0 && currentTruces.length < 3 ? `
        <div style="margin-bottom: 16px;">
          <h3 style="color: #f59e0b; margin: 0 0 12px;">üìù Send New Truce Invitation</h3>
          <div style="display: grid; grid-template-columns: 1fr auto; gap: 8px;">
            <select id="teacherTruceTargetSelect" style="padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--panel); color: var(--text);">
              <option value="">Select a student...</option>
              ${availableStudents.map(student => 
                `<option value="${student.gsId}">${student.name}</option>`
              ).join('')}
            </select>
            <button onclick="sendTeacherTruceInvitation()" style="background: #f59e0b; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">Send Invitation</button>
          </div>
        </div>
        ` : currentTruces.length >= 3 ? 
          '<p style="color: #ef4444; font-style: italic;">This student has reached the maximum of 3 truces</p>' :
          '<p style="color: var(--muted); font-style: italic;">No students available for truce</p>'
        }

        <button onclick="this.parentElement.parentElement.remove()" 
                style="background: var(--accent); color: white; border: none; 
                       padding: 12px 24px; border-radius: 8px; cursor: pointer; 
                       font-size: 16px; width: 100%;">
          Close Truce Manager
        </button>
      </div>
    `;
    
    document.body.appendChild(modal);
  }

  window.sendTeacherTruceInvitation = function() {
    const targetSelect = document.getElementById('teacherTruceTargetSelect');
    const targetStudentId = targetSelect.value;
    
    if (!targetStudentId) {
      alert('Please select a student to send a truce invitation to.');
      return;
    }
    
    const selectedStudent = state.roster.find(s => s.gsId === state.selectedGsId);
    
    if (!selectedStudent) {
      alert('Selected student not found!');
      return;
    }
    
    // Check if invitation already exists
    const existingInvitation = (state.truceInvitations || []).find(inv => 
      inv.fromStudentId === selectedStudent.gsId && inv.toStudentId === targetStudentId
    );
    
    if (existingInvitation) {
      alert('A truce invitation has already been sent to this student.');
      return;
    }
    
    // Create new invitation
    const invitation = {
      id: `truce_inv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      fromStudentId: selectedStudent.gsId,
      toStudentId: targetStudentId,
      timestamp: new Date().toISOString()
    };
    
    if (!state.truceInvitations) state.truceInvitations = [];
    state.truceInvitations.push(invitation);
    
    // Save to localStorage
    const rosters = JSON.parse(localStorage.getItem('tornadoRosters') || '[]');
    const rosterIndex = rosters.findIndex(r => r.id === state.currentRosterId);
    if (rosterIndex !== -1) {
      rosters[rosterIndex].truceInvitations = state.truceInvitations;
      localStorage.setItem('tornadoRosters', JSON.stringify(rosters));
    }
    
    // Notify other tabs about truce invitation
    localStorage.setItem('truceUpdateTrigger', Date.now().toString());
    window.dispatchEvent(new CustomEvent('truceUpdated', {
      detail: { action: 'invitation_sent', invitation: invitation }
    }));
    
    alert('Truce invitation sent successfully!');
    
    // Refresh modal
    document.querySelector('div[style*="position: fixed"]').remove();
    showTeacherTruceModal();
  }

  window.respondToTeacherTruce = function(invitationId, accept) {
    const invitation = (state.truceInvitations || []).find(inv => inv.id === invitationId);
    if (!invitation) {
      alert('Invitation not found!');
      return;
    }
    
    const selectedStudent = state.roster.find(s => s.gsId === state.selectedGsId);
    
    if (!selectedStudent) {
      alert('Selected student not found!');
      return;
    }
    
    if (accept) {
      // Check if either student already has 3 truces
      const fromStudent = state.roster.find(s => s.gsId === invitation.fromStudentId);
      const fromStudentTruces = state.truces.filter(truce => 
        truce.student1 === fromStudent.gsId || truce.student2 === fromStudent.gsId
      );
      const toStudentTruces = state.truces.filter(truce => 
        truce.student1 === selectedStudent.gsId || truce.student2 === selectedStudent.gsId
      );
      
      if (fromStudentTruces.length >= 3 || toStudentTruces.length >= 3) {
        alert('One of the students has reached the maximum of 3 truces.');
        // Remove invitation
        state.truceInvitations = state.truceInvitations.filter(inv => inv.id !== invitationId);
        return;
      }
      
      // Create truce
      const truce = {
        id: `truce_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        student1: invitation.fromStudentId,
        student2: invitation.toStudentId,
        timestamp: new Date().toISOString()
      };
      
      state.truces.push(truce);
    }
    
    // Remove invitation
    if (!state.truceInvitations) state.truceInvitations = [];
    state.truceInvitations = state.truceInvitations.filter(inv => inv.id !== invitationId);
    
    // Save to localStorage
    const rosters = JSON.parse(localStorage.getItem('tornadoRosters') || '[]');
    const rosterIndex = rosters.findIndex(r => r.id === state.currentRosterId);
    if (rosterIndex !== -1) {
      rosters[rosterIndex].truces = state.truces;
      rosters[rosterIndex].truceInvitations = state.truceInvitations;
      localStorage.setItem('tornadoRosters', JSON.stringify(rosters));
    }
    
    // Notify other tabs about truce response
    localStorage.setItem('truceUpdateTrigger', Date.now().toString());
    window.dispatchEvent(new CustomEvent('truceUpdated', {
      detail: { action: accept ? 'truce_accepted' : 'truce_declined', invitation: invitation }
    }));
    
    alert(accept ? 'Truce accepted!' : 'Truce invitation declined.');
    
    // Refresh modal
    document.querySelector('div[style*="position: fixed"]').remove();
    showTeacherTruceModal();
  }

  window.cancelTeacherTruceInvitation = function(invitationId) {
    if (!state.truceInvitations) state.truceInvitations = [];
    state.truceInvitations = state.truceInvitations.filter(inv => inv.id !== invitationId);
    
    // Save to localStorage
    const rosters = JSON.parse(localStorage.getItem('tornadoRosters') || '[]');
    const rosterIndex = rosters.findIndex(r => r.id === state.currentRosterId);
    if (rosterIndex !== -1) {
      rosters[rosterIndex].truceInvitations = state.truceInvitations;
      localStorage.setItem('tornadoRosters', JSON.stringify(rosters));
    }
    
    // Notify other tabs about truce cancellation
    localStorage.setItem('truceUpdateTrigger', Date.now().toString());
    window.dispatchEvent(new CustomEvent('truceUpdated', {
      detail: { action: 'invitation_cancelled', invitationId: invitationId }
    }));
    
    alert('Truce invitation cancelled.');
    
    // Refresh modal
    document.querySelector('div[style*="position: fixed"]').remove();
    showTeacherTruceModal();
  }

  window.endTeacherTruce = function(truceId) {
    if (!confirm('Are you sure you want to end this truce?')) {
      return;
    }
    
    state.truces = state.truces.filter(truce => truce.id !== truceId);
    
    // Save to localStorage
    const rosters = JSON.parse(localStorage.getItem('tornadoRosters') || '[]');
    const rosterIndex = rosters.findIndex(r => r.id === state.currentRosterId);
    if (rosterIndex !== -1) {
      rosters[rosterIndex].truces = state.truces;
      localStorage.setItem('tornadoRosters', JSON.stringify(rosters));
    }
    
    // Notify other tabs about truce ending
    localStorage.setItem('truceUpdateTrigger', Date.now().toString());
    window.dispatchEvent(new CustomEvent('truceUpdated', {
      detail: { action: 'truce_ended', truceId: truceId }
    }));
    
    alert('Truce ended.');
    
    // Refresh modal
    document.querySelector('div[style*="position: fixed"]').remove();
    showTeacherTruceModal();
  }
  // === AI SIMULATION SYSTEM ===
  
  // AI Character class
  class AICharacter {
    constructor(characterData, factionId, scenarioData) {
      this.id = characterData.id || `ai_${Math.random().toString(36).substr(2, 9)}`;
      this.name = characterData.name;
      this.role = characterData.role;
      this.personality = characterData.personality;
      this.quotes = characterData.quotes || [];
      this.factionId = factionId;
      this.scenarioData = scenarioData;
      this.currentQuoteIndex = 0;
      this.lastMoveTime = 0;
      this.moveCooldown = 2000; // 2 seconds between moves
    }

    // Get a quote based on situation
    getQuote(situation = 'general') {
      if (this.quotes.length === 0) return `${this.name} acts!`;
      
      // Rotate through quotes
      const quote = this.quotes[this.currentQuoteIndex];
      this.currentQuoteIndex = (this.currentQuoteIndex + 1) % this.quotes.length;
      return quote;
    }

    // Check if AI can make a move (cooldown)
    canMove() {
      return Date.now() - this.lastMoveTime > this.moveCooldown;
    }

    // Record move time
    recordMove() {
      this.lastMoveTime = Date.now();
    }

    // AI decision making based on personality
    makeDecision(gameState, availableActions) {
      const personality = this.personality.toLowerCase();
      let decision = null;

      // Personality-based decision making
      switch (personality) {
        case 'aggressive':
        case 'military':
        case 'offensive':
          decision = this.makeAggressiveDecision(availableActions);
          break;
        case 'defensive':
        case 'strategic':
          decision = this.makeDefensiveDecision(availableActions);
          break;
        case 'economic':
        case 'diplomatic':
          decision = this.makeEconomicDecision(availableActions);
          break;
        case 'brave':
        case 'heroic':
          decision = this.makeBraveDecision(availableActions);
          break;
        case 'cunning':
        case 'clever':
          decision = this.makeCunningDecision(availableActions);
          break;
        case 'wise':
        case 'intellectual':
          decision = this.makeWiseDecision(availableActions);
          break;
        default:
          decision = this.makeRandomDecision(availableActions);
      }

      return decision;
    }

    makeAggressiveDecision(actions) {
      // Prefer attacking and expanding
      const attackActions = actions.filter(a => a.type === 'attack');
      const expandActions = actions.filter(a => a.type === 'claim');
      
      if (attackActions.length > 0) {
        return attackActions[Math.floor(Math.random() * attackActions.length)];
      }
      if (expandActions.length > 0) {
        return expandActions[Math.floor(Math.random() * expandActions.length)];
      }
      return actions[Math.floor(Math.random() * actions.length)];
    }

    makeDefensiveDecision(actions) {
      // Prefer building castles and defending
      const buildActions = actions.filter(a => a.type === 'build');
      const defendActions = actions.filter(a => a.type === 'defend');
      
      if (buildActions.length > 0) {
        return buildActions[Math.floor(Math.random() * buildActions.length)];
      }
      if (defendActions.length > 0) {
        return defendActions[Math.floor(Math.random() * defendActions.length)];
      }
      return actions[Math.floor(Math.random() * actions.length)];
    }

    makeEconomicDecision(actions) {
      // Prefer economic actions
      const economicActions = actions.filter(a => 
        a.type === 'trade' || a.type === 'collect' || a.type === 'upgrade'
      );
      
      if (economicActions.length > 0) {
        return economicActions[Math.floor(Math.random() * economicActions.length)];
      }
      return actions[Math.floor(Math.random() * actions.length)];
    }

    makeBraveDecision(actions) {
      // Prefer heroic actions
      const heroicActions = actions.filter(a => 
        a.type === 'attack' || a.type === 'rescue' || a.type === 'challenge'
      );
      
      if (heroicActions.length > 0) {
        return heroicActions[Math.floor(Math.random() * heroicActions.length)];
      }
      return actions[Math.floor(Math.random() * actions.length)];
    }

    makeCunningDecision(actions) {
      // Prefer sneaky or strategic actions
      const cunningActions = actions.filter(a => 
        a.type === 'spy' || a.type === 'trick' || a.type === 'ambush'
      );
      
      if (cunningActions.length > 0) {
        return cunningActions[Math.floor(Math.random() * cunningActions.length)];
      }
      return actions[Math.floor(Math.random() * actions.length)];
    }

    makeWiseDecision(actions) {
      // Prefer thoughtful actions
      const wiseActions = actions.filter(a => 
        a.type === 'plan' || a.type === 'advise' || a.type === 'negotiate'
      );
      
      if (wiseActions.length > 0) {
        return wiseActions[Math.floor(Math.random() * wiseActions.length)];
      }
      return actions[Math.floor(Math.random() * actions.length)];
    }

    makeRandomDecision(actions) {
      return actions[Math.floor(Math.random() * actions.length)];
    }
  }

  // AI Simulation Manager
  class AISimulationManager {
    constructor() {
      this.aiCharacters = new Map();
      this.isSimulating = false;
      this.simulationQueue = [];
      this.currentSimulationIndex = 0;
    }

    // Initialize AI characters from scenario data
    initializeAI(scenarioData, rosterData) {
      this.aiCharacters.clear();
      
      if (!scenarioData || !scenarioData.factions) return;

      // Create AI characters for each faction
      Object.entries(scenarioData.factions).forEach(([factionId, faction]) => {
        if (faction.characters) {
          faction.characters.forEach(charData => {
            const aiChar = new AICharacter(charData, factionId, scenarioData);
            this.aiCharacters.set(aiChar.id, aiChar);
          });
        }
      });
    }

    // Get available actions for AI character
    getAvailableActions(aiCharacter, gameState) {
      const actions = [];
      
      // Get character's territories
      const characterTiles = state.board.tiles.filter(tile => 
        tile.owner_game_student_id === aiCharacter.id
      );

      // Claim unowned territories
      const unownedTiles = state.board.tiles.filter(tile => 
        !tile.owner_game_student_id && 
        this.canCharacterAttackTile(aiCharacter, tile, characterTiles)
      );

      unownedTiles.forEach(tile => {
        actions.push({
          type: 'claim',
          tileId: tile.id,
          cost: tile.cost || 10,
          description: `Claim ${tile.name || 'territory'}`
        });
      });

      // Attack enemy territories
      const enemyTiles = state.board.tiles.filter(tile => 
        tile.owner_game_student_id && 
        tile.owner_game_student_id !== aiCharacter.id &&
        this.canCharacterAttackTile(aiCharacter, tile, characterTiles)
      );

      enemyTiles.forEach(tile => {
        actions.push({
          type: 'attack',
          tileId: tile.id,
          cost: tile.cost || 10,
          description: `Attack ${tile.name || 'territory'}`
        });
      });

      // Build castles on owned territories
      characterTiles.forEach(tile => {
        if (!tile.castleLevel || tile.castleLevel < 3) {
          const cost = tile.castleLevel === 0 ? 50 : tile.castleLevel === 1 ? 100 : 200;
          actions.push({
            type: 'build',
            tileId: tile.id,
            cost: cost,
            description: `Build castle on ${tile.name || 'territory'}`
          });
        }
      });

      return actions;
    }

    // Check if character can attack a tile (adjacency)
    canCharacterAttackTile(aiCharacter, targetTile, characterTiles) {
      if (characterTiles.length === 0) return true; // Initial placement

      for (const characterTile of characterTiles) {
        if (this.areTilesAdjacent(characterTile, targetTile)) {
          return true;
        }
      }

      // Check truce territories
      const characterTruces = state.truces.filter(truce =>
        truce.student1 === aiCharacter.id || truce.student2 === aiCharacter.id
      );

      for (const truce of characterTruces) {
        const trucePartnerId = truce.student1 === aiCharacter.id ? truce.student2 : truce.student1;
        const trucePartnerTiles = state.board.tiles.filter(t => t.owner_game_student_id === trucePartnerId);

        for (const truceTile of trucePartnerTiles) {
          if (this.areTilesAdjacent(truceTile, targetTile)) {
            return true;
          }
        }
      }

      return false;
    }

    // Check if two tiles are adjacent
    areTilesAdjacent(tile1, tile2) {
      const dx = Math.abs(tile1.x - tile2.x);
      const dy = Math.abs(tile1.y - tile2.y);
      return (dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0);
    }

    // Execute AI move
    async executeAIMove(aiCharacter, action) {
      try {
        // Show AI move notification
        this.showAIMoveNotification(aiCharacter, action);

        // Execute the action
        switch (action.type) {
          case 'claim':
            await this.executeClaimAction(aiCharacter, action);
            break;
          case 'attack':
            await this.executeAttackAction(aiCharacter, action);
            break;
          case 'build':
            await this.executeBuildAction(aiCharacter, action);
            break;
        }

        // Record move time
        aiCharacter.recordMove();

        // Update display
        updateGridDisplay();
        renderRoster();

      } catch (error) {
        console.error('AI move execution error:', error);
      }
    }

    // Execute claim action
    async executeClaimAction(aiCharacter, action) {
      const tile = state.board.tiles.find(t => t.id === action.tileId);
      if (!tile) return;

      // Simulate claiming the tile
      tile.owner_game_student_id = aiCharacter.id;
      
      // Update roster if character exists
      const rosterEntry = state.roster.find(r => r.gsId === aiCharacter.id);
      if (rosterEntry) {
        rosterEntry.points = (rosterEntry.points || 0) - action.cost;
      }
    }

    // Execute attack action
    async executeAttackAction(aiCharacter, action) {
      const tile = state.board.tiles.find(t => t.id === action.tileId);
      if (!tile) return;

      // Simulate battle
      const attacker = state.roster.find(r => r.gsId === aiCharacter.id);
      const defender = state.roster.find(r => r.gsId === tile.owner_game_student_id);
      
      if (!attacker || !defender) return;

      // Simple battle simulation
      const attackerPower = (attacker.points || 0) + (tile.castleLevel || 0) * 20;
      const defenderPower = (defender.points || 0) + (tile.castleLevel || 0) * 20;
      
      const randomFactor = Math.random() * 0.4 + 0.8; // 0.8 to 1.2
      const finalAttackerPower = attackerPower * randomFactor;

      if (finalAttackerPower > defenderPower) {
        // Attacker wins
        tile.owner_game_student_id = aiCharacter.id;
        tile.castleLevel = Math.max(0, (tile.castleLevel || 0) - 1);
        
        // Update points
        attacker.points = (attacker.points || 0) - action.cost;
        defender.points = Math.max(0, (defender.points || 0) - action.cost);
      } else {
        // Defender wins
        attacker.points = Math.max(0, (attacker.points || 0) - action.cost);
      }
    }

    // Execute build action
    async executeBuildAction(aiCharacter, action) {
      const tile = state.board.tiles.find(t => t.id === action.tileId);
      if (!tile) return;

      const rosterEntry = state.roster.find(r => r.gsId === aiCharacter.id);
      if (!rosterEntry) return;

      if ((rosterEntry.points || 0) >= action.cost) {
        tile.castleLevel = (tile.castleLevel || 0) + 1;
        rosterEntry.points = (rosterEntry.points || 0) - action.cost;
      }
    }

    // Show AI move notification
    showAIMoveNotification(aiCharacter, action) {
      const quote = aiCharacter.getQuote();
      
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 12px;
        max-width: 300px;
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
      `;

      notification.innerHTML = `
        <div style="font-weight: bold; color: var(--accent); margin-bottom: 4px;">
          ${aiCharacter.name} (${aiCharacter.role})
        </div>
        <div style="font-size: 14px; margin-bottom: 4px;">
          ${action.description}
        </div>
        <div style="font-style: italic; color: var(--muted); font-size: 12px;">
          "${quote}"
        </div>
      `;

      // Add CSS animation
      if (!document.getElementById('aiNotificationStyle')) {
        const style = document.createElement('style');
        style.id = 'aiNotificationStyle';
        style.textContent = `
          @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
          }
        `;
        document.head.appendChild(style);
      }

      document.body.appendChild(notification);

      // Remove notification after 3 seconds
      setTimeout(() => {
        notification.style.animation = 'slideIn 0.3s ease-out reverse';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, 3000);
    }

    // Simulate all AI moves
    async simulateAllAI() {
      if (this.isSimulating) return;

      this.isSimulating = true;
      this.simulationQueue = Array.from(this.aiCharacters.values());
      this.currentSimulationIndex = 0;

      // Show simulation status
      this.showSimulationStatus();

      // Process each AI character
      for (let i = 0; i < this.simulationQueue.length; i++) {
        const aiCharacter = this.simulationQueue[i];
        
        if (aiCharacter.canMove()) {
          const availableActions = this.getAvailableActions(aiCharacter, state);
          
          if (availableActions.length > 0) {
            const decision = aiCharacter.makeDecision(state, availableActions);
            await this.executeAIMove(aiCharacter, decision);
            
            // Small delay between moves for better UX
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        }
      }

      this.isSimulating = false;
      this.hideSimulationStatus();
    }

    // Simulate single AI move
    async simulateSingleAI(aiCharacterId) {
      const aiCharacter = this.aiCharacters.get(aiCharacterId);
      if (!aiCharacter || !aiCharacter.canMove()) return;

      const availableActions = this.getAvailableActions(aiCharacter, state);
      
      if (availableActions.length > 0) {
        const decision = aiCharacter.makeDecision(state, availableActions);
        await this.executeAIMove(aiCharacter, decision);
      }
    }

    // Show simulation status
    showSimulationStatus() {
      const status = document.createElement('div');
      status.id = 'aiSimulationStatus';
      status.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 10px;
        padding: 20px;
        z-index: 1001;
        text-align: center;
      `;

      status.innerHTML = `
        <div style="color: var(--accent); font-weight: bold; margin-bottom: 10px;">
          AI Simulation in Progress
        </div>
        <div style="color: var(--text);">
          Processing AI moves...
        </div>
      `;

      document.body.appendChild(status);
    }

    // Hide simulation status
    hideSimulationStatus() {
      const status = document.getElementById('aiSimulationStatus');
      if (status) {
        status.remove();
      }
    }
  }

  // Global AI manager instance
  const aiManager = new AISimulationManager();

  // AI Control Functions
  window.simulateAllAI = function() {
    aiManager.simulateAllAI();
  };

  window.simulateSingleAI = function(characterId) {
    aiManager.simulateSingleAI(characterId);
  };

  window.showIndividualAIControls = function() {
    const controls = document.getElementById('individualAIControls');
    const list = document.getElementById('aiCharacterList');
    
    if (controls.style.display === 'none') {
      controls.style.display = 'block';
      populateAICharacterList();
    } else {
      controls.style.display = 'none';
    }
  };

  function populateAICharacterList() {
    const list = document.getElementById('aiCharacterList');
    list.innerHTML = '';

    aiManager.aiCharacters.forEach((aiChar, charId) => {
      const button = document.createElement('button');
      button.className = 'pill';
      button.style.cssText = 'background: #10b981; font-size: 11px; margin: 2px; padding: 4px 8px;';
      button.textContent = `${aiChar.name} (${aiChar.personality})`;
      button.onclick = () => simulateSingleAI(charId);
      button.title = `Click to simulate ${aiChar.name}'s move`;
      list.appendChild(button);
    });

    if (aiManager.aiCharacters.size === 0) {
      list.innerHTML = '<div style="color: var(--muted); font-size: 12px; padding: 8px;">No AI characters available</div>';
    }
  }

  function showAIControls() {
    const aiControls = document.getElementById('aiControls');
    if (aiManager.aiCharacters.size > 0) {
      aiControls.style.display = 'block';
    } else {
      aiControls.style.display = 'none';
    }
  }

  function showEducationalControls() {
    const educationalControls = document.getElementById('educationalControls');
    if (state.currentScenario && state.currentScenario.scenarioData) {
      educationalControls.style.display = 'block';
    } else {
      educationalControls.style.display = 'none';
    }
  }

  window.showEducationalHelp = function() {
    const helpContent = {
      title: 'Educational Features Help',
      description: 'Tornado War includes educational content to enhance learning:',
      context: '‚Ä¢ Click "Random Fact" to learn historical information\n‚Ä¢ Character profiles show historical context\n‚Ä¢ Territory information explains strategic importance\n‚Ä¢ AI characters use authentic quotes and personalities\n‚Ä¢ All content is age-appropriate for classroom use'
    };
    
    educationalManager.showEducationalPopup('help', helpContent);
  };

  // Initialize AI when scenario is loaded
  function initializeAIForScenario() {
    if (state.currentScenario && state.currentScenario.scenarioData) {
      aiManager.initializeAI(state.currentScenario.scenarioData, state.currentRoster);
      showAIControls();
      showEducationalControls();
    } else {
      // Hide AI and educational controls if no scenario
      const aiControls = document.getElementById('aiControls');
      const educationalControls = document.getElementById('educationalControls');
      if (aiControls) aiControls.style.display = 'none';
      if (educationalControls) educationalControls.style.display = 'none';
    }
  }

  // Add AI initialization to existing functions
  const originalLoadRoster = loadRoster;
  loadRoster = function(rosterId) {
    originalLoadRoster(rosterId);
    // Initialize AI after roster is loaded
    setTimeout(initializeAIForScenario, 100);
  };
  // === EDUCATIONAL CONTENT SYSTEM ===
  
  // Educational Content Manager
  class EducationalContentManager {
    constructor() {
      this.historicalFacts = new Map();
      this.characterProfiles = new Map();
      this.territoryInfo = new Map();
      this.currentScenario = null;
    }

    // Initialize educational content for scenario
    initializeEducationalContent(scenarioData) {
      this.currentScenario = scenarioData;
      this.historicalFacts.clear();
      this.characterProfiles.clear();
      this.territoryInfo.clear();

      if (!scenarioData) return;

      // Load historical facts
      this.loadHistoricalFacts(scenarioData);
      
      // Load character profiles
      this.loadCharacterProfiles(scenarioData);
      
      // Load territory information
      this.loadTerritoryInfo(scenarioData);
    }

    // Load historical facts for the scenario
    loadHistoricalFacts(scenarioData) {
      const facts = this.getScenarioHistoricalFacts(scenarioData.id);
      facts.forEach(fact => {
        this.historicalFacts.set(fact.id, fact);
      });
    }

    // Load character profiles
    loadCharacterProfiles(scenarioData) {
      if (!scenarioData.factions) return;

      Object.values(scenarioData.factions).forEach(faction => {
        if (faction.characters) {
          faction.characters.forEach(character => {
            this.characterProfiles.set(character.name, {
              name: character.name,
              role: character.role,
              description: character.description,
              faction: faction.name,
              historicalContext: this.getCharacterHistoricalContext(character.name, scenarioData.id)
            });
          });
        }
      });
    }

    // Load territory information
    loadTerritoryInfo(scenarioData) {
      if (!scenarioData.factions) return;

      Object.values(scenarioData.factions).forEach(faction => {
        if (faction.territories) {
          faction.territories.forEach(territory => {
            this.territoryInfo.set(territory.name, {
              name: territory.name,
              description: territory.description,
              cost: territory.cost,
              historicalContext: this.getTerritoryHistoricalContext(territory.name, scenarioData.id)
            });
          });
        }
      });

      // Add neutral territories
      if (scenarioData.neutralTerritories) {
        scenarioData.neutralTerritories.forEach(territory => {
          this.territoryInfo.set(territory.name, {
            name: territory.name,
            description: territory.description,
            cost: territory.cost,
            historicalContext: this.getTerritoryHistoricalContext(territory.name, scenarioData.id)
          });
        });
      }
    }

    // Get historical facts for specific scenario
    getScenarioHistoricalFacts(scenarioId) {
      const facts = {
        americanRevolution: [
          {
            id: 'declaration',
            title: 'Declaration of Independence',
            fact: 'The Declaration of Independence was signed on July 4, 1776, declaring the 13 American colonies independent from British rule.',
            context: 'This document marked the formal beginning of the American Revolutionary War.'
          },
          {
            id: 'boston_tea_party',
            title: 'Boston Tea Party',
            fact: 'On December 16, 1773, colonists dumped 342 chests of British tea into Boston Harbor to protest taxation without representation.',
            context: 'This event escalated tensions between the colonies and Britain.'
          },
          {
            id: 'valley_forge',
            title: 'Valley Forge',
            fact: 'During the winter of 1777-1778, Washington\'s army endured harsh conditions at Valley Forge, emerging stronger and more disciplined.',
            context: 'This period was crucial for training and preparing the Continental Army.'
          }
        ],
        civilWar: [
          {
            id: 'emancipation',
            title: 'Emancipation Proclamation',
            fact: 'On January 1, 1863, Lincoln issued the Emancipation Proclamation, declaring all slaves in Confederate states free.',
            context: 'This transformed the war from a conflict over secession to a fight for freedom.'
          },
          {
            id: 'gettysburg',
            title: 'Battle of Gettysburg',
            fact: 'The Battle of Gettysburg (July 1-3, 1863) was the bloodiest battle of the Civil War, with over 50,000 casualties.',
            context: 'This Union victory marked a turning point in the war.'
          },
          {
            id: 'underground_railroad',
            title: 'Underground Railroad',
            fact: 'The Underground Railroad was a network of secret routes and safe houses used by enslaved people to escape to freedom.',
            context: 'This network helped thousands of people reach freedom in the North.'
          }
        ],
        harryPotter: [
          {
            id: 'horcruxes',
            title: 'Horcruxes',
            fact: 'Horcruxes are objects in which a wizard has hidden a fragment of their soul to achieve immortality.',
            context: 'Voldemort created seven horcruxes to make himself nearly immortal.'
          },
          {
            id: 'deathly_hallows',
            title: 'Deathly Hallows',
            fact: 'The Deathly Hallows are three magical objects: the Elder Wand, the Resurrection Stone, and the Invisibility Cloak.',
            context: 'According to legend, possessing all three makes one the Master of Death.'
          },
          {
            id: 'house_system',
            title: 'Hogwarts Houses',
            fact: 'Hogwarts students are sorted into four houses: Gryffindor (bravery), Hufflepuff (loyalty), Ravenclaw (wisdom), and Slytherin (ambition).',
            context: 'Each house has its own values and characteristics.'
          }
        ]
      };

      return facts[scenarioId] || [];
    }

    // Get character historical context
    getCharacterHistoricalContext(characterName, scenarioId) {
      const contexts = {
        americanRevolution: {
          'George Washington': 'First President of the United States and Commander-in-Chief of the Continental Army during the Revolutionary War.',
          'Thomas Jefferson': 'Primary author of the Declaration of Independence and third President of the United States.',
          'Benjamin Franklin': 'Founding Father, inventor, and diplomat who helped secure French support for the American cause.'
        },
        civilWar: {
          'Abraham Lincoln': '16th President who led the Union during the Civil War and issued the Emancipation Proclamation.',
          'Robert E. Lee': 'Confederate general who commanded the Army of Northern Virginia.',
          'Ulysses S. Grant': 'Union general who later became the 18th President of the United States.'
        },
        harryPotter: {
          'Harry Potter': 'The Boy Who Lived, destined to defeat Voldemort and save the wizarding world.',
          'Hermione Granger': 'Brilliant witch known for her intelligence and loyalty to her friends.',
          'Ron Weasley': 'Harry\'s best friend, known for his bravery and loyalty despite his insecurities.'
        }
      };

      return contexts[scenarioId]?.[characterName] || 'Historical character from this period.';
    }

    // Get territory historical context
    getTerritoryHistoricalContext(territoryName, scenarioId) {
      const contexts = {
        americanRevolution: {
          'Boston': 'Site of the Boston Tea Party and early revolutionary activity.',
          'Philadelphia': 'Where the Declaration of Independence was signed and the Continental Congress met.',
          'Yorktown': 'Where the final major battle of the Revolutionary War took place.'
        },
        civilWar: {
          'Gettysburg': 'Site of the bloodiest battle of the Civil War.',
          'Antietam': 'Site of the bloodiest single-day battle in American history.',
          'Vicksburg': 'Strategic Confederate stronghold on the Mississippi River.'
        },
        harryPotter: {
          'Hogwarts': 'School of Witchcraft and Wizardry, the main setting of the Harry Potter series.',
          'Diagon Alley': 'Magical shopping district hidden in London.',
          'Hogsmeade': 'The only all-wizarding village in Britain.'
        }
      };

      return contexts[scenarioId]?.[territoryName] || 'Important location in this historical period.';
    }

    // Show educational popup
    showEducationalPopup(type, content) {
      const popup = document.createElement('div');
      popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 12px;
        padding: 20px;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        z-index: 1002;
        box-shadow: 0 10px 25px rgba(0,0,0,0.3);
      `;

      popup.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="margin: 0; color: var(--accent);">${content.title}</h3>
          <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: var(--muted); font-size: 20px; cursor: pointer;">&times;</button>
        </div>
        <div style="color: var(--text); line-height: 1.6;">
          <p style="margin: 0 0 15px 0; font-size: 16px;">${content.fact || content.description}</p>
          ${content.context ? `<p style="margin: 0; font-size: 14px; color: var(--muted); font-style: italic;">${content.context}</p>` : ''}
        </div>
        <div style="margin-top: 15px; text-align: center;">
          <button onclick="this.parentElement.parentElement.remove()" style="background: var(--accent); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">Close</button>
        </div>
      `;

      document.body.appendChild(popup);

      // Auto-close after 10 seconds
      setTimeout(() => {
        if (popup.parentNode) {
          popup.remove();
        }
      }, 10000);
    }

    // Show random historical fact
    showRandomHistoricalFact() {
      if (this.historicalFacts.size === 0) return;

      const facts = Array.from(this.historicalFacts.values());
      const randomFact = facts[Math.floor(Math.random() * facts.length)];
      this.showEducationalPopup('fact', randomFact);
    }

    // Show character profile
    showCharacterProfile(characterName) {
      const profile = this.characterProfiles.get(characterName);
      if (!profile) return;

      this.showEducationalPopup('character', {
        title: `${profile.name} (${profile.role})`,
        description: profile.description,
        context: profile.historicalContext
      });
    }

    // Show territory information
    showTerritoryInfo(territoryName) {
      const info = this.territoryInfo.get(territoryName);
      if (!info) return;

      this.showEducationalPopup('territory', {
        title: territoryName,
        description: info.description,
        context: info.historicalContext
      });
    }
  }

  // Global educational content manager
  const educationalManager = new EducationalContentManager();

  // Educational control functions
  window.showRandomHistoricalFact = function() {
    educationalManager.showRandomHistoricalFact();
  };

  window.showCharacterProfile = function(characterName) {
    educationalManager.showCharacterProfile(characterName);
  };

  window.showTerritoryInfo = function(territoryName) {
    educationalManager.showTerritoryInfo(territoryName);
  };

  // Initialize educational content when scenario is loaded
  function initializeEducationalContent() {
    if (state.currentScenario && state.currentScenario.scenarioData) {
      educationalManager.initializeEducationalContent(state.currentScenario.scenarioData);
    }
  }

  // Add educational content initialization
  const originalLoadRosterWithEducation = loadRoster;
  loadRoster = function(rosterId) {
    originalLoadRosterWithEducation(rosterId);
    // Initialize AI and educational content after roster is loaded
    setTimeout(() => {
      initializeAIForScenario();
      initializeEducationalContent();
    }, 100);
  };

  // AI Turn Management
  let aiTurnQueue = [];
  let currentAIActionIndex = 0;
  let isAITurnSequenceActive = false;
  
  // Take individual AI turn
  async function takeAITurn(aiStudentId) {
    // Look in both roster (legacy) and aiPlayers array
    let aiStudent = state.roster.find(s => s.gsId === aiStudentId && s.isAI);
    if (!aiStudent && state.aiPlayers) {
      aiStudent = state.aiPlayers.find(s => s.gsId === aiStudentId);
    }
    
    if (!aiStudent) {
      console.error('AI student not found:', aiStudentId);
      return;
    }
    
    // Check if AI has enough money to do anything
    if (aiStudent.balance < 10) {
      showAIAction(`${aiStudent.name} (${aiStudent.characterName || 'AI'}) skips their turn - not enough money! üí∞`, 'skip');
      return;
    }
    
    // Get AI character data
    const characterData = getAICharacterData(aiStudent);
    if (!characterData) {
      showAIAction(`${aiStudent.name} takes a turn but has no character data!`, 'error');
      return;
    }
    
    // Make AI decision
    const action = makeAIDecision(aiStudent, characterData);
    await executeAIAction(aiStudent, action);
  }
  
  // Take all AI turns in sequence
  async function takeAllAITurns() {
    // Get AI players from both roster (legacy) and aiPlayers array
    const rosterAIStudents = state.roster.filter(s => s.isAI);
    const aiPlayers = state.aiPlayers || [];
    const allAIStudents = [...rosterAIStudents, ...aiPlayers];
    
    if (allAIStudents.length === 0) {
      alert('No AI players found!');
      return;
    }
    
    // Initialize turn sequence
    aiTurnQueue = allAIStudents.slice();
    currentAIActionIndex = 0;
    isAITurnSequenceActive = true;
    
    // Show modal
    showAIActionModal();
    
    // Start first AI turn
    await nextAIAction();
  }
  
  // Get AI character data from scenario
  function getAICharacterData(aiStudent) {
    if (!state.scenario || !state.scenario.scenarioId) return null;
    
    const scenarioData = SCENARIOS[state.scenario.scenarioId];
    if (!scenarioData || !scenarioData.factions) return null;
    
    // Find character in factions
    for (const [factionId, faction] of Object.entries(scenarioData.factions)) {
      if (faction.characters) {
        const character = faction.characters.find(char => 
          char.name === aiStudent.characterName || 
          char.role === aiStudent.characterName
        );
        if (character) {
          return { ...character, factionId, factionName: faction.name };
        }
      }
    }
    
    return null;
  }
  
  // Make AI decision based on personality and game state
  function makeAIDecision(aiStudent, characterData) {
    const personality = characterData.personality || 'strategic';
    const availableActions = getAvailableAIActions(aiStudent);
    
    if (availableActions.length === 0) {
      return { type: 'skip', reason: 'No available actions' };
    }
    
    // Decision making based on personality
    switch (personality) {
      case 'aggressive':
        return makeAggressiveDecision(availableActions);
      case 'defensive':
        return makeDefensiveDecision(availableActions);
      case 'strategic':
        return makeStrategicDecision(availableActions);
      case 'economic':
        return makeEconomicDecision(availableActions);
      default:
        return makeRandomDecision(availableActions);
    }
  }
  
  // Get available actions for AI
  function getAvailableAIActions(aiStudent) {
    const actions = [];
    
    // Check if can buy mercenaries
    if (aiStudent.balance >= 10) {
      actions.push({ type: 'buy_mercenaries', cost: 10, description: 'Buy mercenaries' });
    }
    
    // Check if can attack (has mercenaries and targets)
    if (aiStudent.mercenaries > 0) {
      const attackableTiles = getAIAttackableTiles(aiStudent);
      if (attackableTiles.length > 0) {
        actions.push({ type: 'attack', targets: attackableTiles, description: 'Attack enemy territory' });
      }
    }
    
    // Check if can expand (has money for new territories)
    if (aiStudent.balance >= 5) {
      const expandableTiles = getExpandableTiles(aiStudent);
      if (expandableTiles.length > 0) {
        actions.push({ type: 'expand', targets: expandableTiles, description: 'Expand to new territory' });
      }
    }
    
    return actions;
  }
  
  // Execute AI action
  async function executeAIAction(aiStudent, action) {
    const characterData = getAICharacterData(aiStudent);
    const characterName = characterData?.name || aiStudent.characterName || 'AI';
    const quote = characterData?.quotes?.[Math.floor(Math.random() * characterData.quotes.length)] || `${characterName} acts!`;
    
    switch (action.type) {
      case 'buy_mercenaries':
        aiStudent.balance -= action.cost;
        aiStudent.mercenaries += 1;
        showAIAction(`${characterName}: "${quote}" - Buys mercenaries! ‚öîÔ∏è`, 'buy');
        break;
        
      case 'attack':
        if (action.targets && action.targets.length > 0) {
          const target = action.targets[Math.floor(Math.random() * action.targets.length)];
          showAIAction(`${characterName}: "${quote}" - Attacks ${target.name}! ‚öîÔ∏è`, 'attack');
          
          // Real attack - trigger the actual battle system
          await executeRealAIAttack(aiStudent, target);
        }
        break;
        
      case 'expand':
        if (action.targets && action.targets.length > 0) {
          const target = action.targets[Math.floor(Math.random() * action.targets.length)];
          
          // Real expansion - actually buy the tile
          if (aiStudent.balance >= target.cost) {
            aiStudent.balance -= target.cost;
            aiStudent.tilesOwned += 1;
            
            // Update the actual tile on the board
            const tile = state.board.tiles[target.y][target.x];
            if (tile) {
              tile.owner = aiStudent.gsId;
              tile.color = aiStudent.teamColor || '#8b5cf6';
            }
            
            showAIAction(`${characterName}: "${quote}" - Expands to ${target.name}! üó∫Ô∏è`, 'expand');
            
            // Update the display
            updateGridDisplay();
            renderRoster();
          } else {
            showAIAction(`${characterName}: "${quote}" - Cannot afford ${target.name} (cost: ${target.cost})! üí∞`, 'skip');
          }
        }
        break;
        
      case 'skip':
        showAIAction(`${characterName}: "${quote}" - Skips turn (${action.reason})`, 'skip');
        break;
        
      default:
        showAIAction(`${characterName}: "${quote}" - Takes a mysterious action!`, 'mystery');
    }
    
    // Update UI
    renderRoster();
    updateTeamScoreboards();
  }
  
  // Show AI action in modal
  function showAIAction(message, type) {
    const log = document.getElementById('aiActionLog');
    if (!log) return;
    
    const actionDiv = document.createElement('div');
    actionDiv.style.cssText = `
      padding: 12px;
      margin-bottom: 8px;
      border-radius: 8px;
      border-left: 4px solid ${getActionColor(type)};
      background: white;
      animation: slideIn 0.3s ease-out;
    `;
    
    actionDiv.innerHTML = `
      <div style="font-weight: 600; color: #1e293b; margin-bottom: 4px;">
        ${getActionIcon(type)} ${type.charAt(0).toUpperCase() + type.slice(1)} Action
      </div>
      <div style="color: #64748b; font-size: 14px;">${message}</div>
    `;
    
    log.appendChild(actionDiv);
    log.scrollTop = log.scrollHeight;
  }
  
  // Get action color based on type
  function getActionColor(type) {
    const colors = {
      'buy': '#10b981',
      'attack': '#ef4444',
      'expand': '#3b82f6',
      'skip': '#6b7280',
      'error': '#f59e0b',
      'mystery': '#8b5cf6'
    };
    return colors[type] || '#6b7280';
  }
  
  // Get action icon based on type
  function getActionIcon(type) {
    const icons = {
      'buy': 'üí∞',
      'attack': '‚öîÔ∏è',
      'expand': 'üó∫Ô∏è',
      'skip': '‚è≠Ô∏è',
      'error': '‚ö†Ô∏è',
      'mystery': '‚ùì'
    };
    return icons[type] || '‚ùì';
  }
  
  // Show AI action modal
  function showAIActionModal() {
    const modal = document.getElementById('aiActionModal');
    if (modal) {
      modal.style.display = 'flex';
      document.getElementById('aiActionLog').innerHTML = '';
    }
  }
  
  // Close AI action modal
  function closeAIActionModal() {
    const modal = document.getElementById('aiActionModal');
    if (modal) {
      modal.style.display = 'none';
    }
    isAITurnSequenceActive = false;
    aiTurnQueue = [];
    currentAIActionIndex = 0;
  }

  // Make functions globally accessible
  window.closeAIActionModal = closeAIActionModal;

  // Add escape key handler for AI modal
  document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
      const modal = document.getElementById('aiActionModal');
      if (modal && modal.style.display !== 'none') {
        closeAIActionModal();
      }
    }
  });

  // Add click-outside-to-close handler for AI modal
  document.addEventListener('click', function(event) {
    const modal = document.getElementById('aiActionModal');
    if (modal && modal.style.display !== 'none') {
      // Check if click is outside the modal content
      if (event.target === modal) {
        closeAIActionModal();
      }
    }
  });
  
  // Next AI action in sequence
  async function nextAIAction() {
    if (!isAITurnSequenceActive || currentAIActionIndex >= aiTurnQueue.length) {
      showAIAction('üéâ All AI turns completed!', 'complete');
      document.getElementById('nextAIActionBtn').style.display = 'none';
      return;
    }
    
    const aiStudent = aiTurnQueue[currentAIActionIndex];
    currentAIActionIndex++;
    
    await takeAITurn(aiStudent.gsId);
    
    // Auto-advance after a short delay
    setTimeout(() => {
      if (isAITurnSequenceActive) {
        nextAIAction();
      }
    }, 1500);
  }

  // Make nextAIAction globally accessible
  window.nextAIAction = nextAIAction;
  
  // Simplified decision making functions
  function makeAggressiveDecision(actions) {
    const attackActions = actions.filter(a => a.type === 'attack');
    if (attackActions.length > 0) return attackActions[0];
    return actions[Math.floor(Math.random() * actions.length)];
  }
  
  function makeDefensiveDecision(actions) {
    const buyActions = actions.filter(a => a.type === 'buy_mercenaries');
    if (buyActions.length > 0) return buyActions[0];
    return actions[Math.floor(Math.random() * actions.length)];
  }
  function makeStrategicDecision(actions) {
    // Prefer buying mercenaries if low on troops, otherwise attack
    const buyActions = actions.filter(a => a.type === 'buy_mercenaries');
    const attackActions = actions.filter(a => a.type === 'attack');
    
    if (buyActions.length > 0 && Math.random() < 0.6) return buyActions[0];
    if (attackActions.length > 0) return attackActions[0];
    return actions[Math.floor(Math.random() * actions.length)];
  }
  
  function makeEconomicDecision(actions) {
    const expandActions = actions.filter(a => a.type === 'expand');
    if (expandActions.length > 0) return expandActions[0];
    return actions[Math.floor(Math.random() * actions.length)];
  }
  
  function makeRandomDecision(actions) {
    return actions[Math.floor(Math.random() * actions.length)];
  }
  
  // Helper functions for AI actions
  function getAIAttackableTiles(aiStudent) {
    const attackableTiles = [];
    
    // Get all tiles on the board
    for (let y = 0; y < state.board.h; y++) {
      for (let x = 0; x < state.board.w; x++) {
        const tile = state.board.tiles[y][x];
        if (!tile) continue;
        
        // Check if tile is owned by enemy (not AI, not neutral)
        const isOwnedByEnemy = tile.owner && tile.owner !== aiStudent.gsId && 
          !state.aiPlayers?.some(ai => ai.gsId === tile.owner);
        
        if (isOwnedByEnemy) {
          attackableTiles.push({
            x: x,
            y: y,
            name: tile.name || `Tile ${x},${y}`,
            cost: tile.cost || 10,
            owner: tile.owner,
            value: tile.value || 10
          });
        }
      }
    }
    
    console.log(`AI ${aiStudent.name} found ${attackableTiles.length} attackable tiles`);
    return attackableTiles;
  }
  
  function getExpandableTiles(aiStudent) {
    const expandableTiles = [];
    
    // Get all tiles on the board
    for (let y = 0; y < state.board.h; y++) {
      for (let x = 0; x < state.board.w; x++) {
        const tile = state.board.tiles[y][x];
        if (!tile) continue;
        
        // Check if tile is neutral (not owned by anyone)
        const isNeutral = !tile.owner;
        
        if (isNeutral) {
          expandableTiles.push({
            x: x,
            y: y,
            name: tile.name || `Tile ${x},${y}`,
            cost: tile.cost || 5,
            value: tile.value || 5
          });
        }
      }
    }
    
    console.log(`AI ${aiStudent.name} found ${expandableTiles.length} expandable tiles`);
    return expandableTiles;
  }
  
  // Execute real AI attack that triggers battle system
  async function executeRealAIAttack(aiStudent, target) {
    try {
      // Set the AI as the selected attacker
      state.selectedGsId = aiStudent.gsId;
      
      // Get the target tile
      const targetTile = state.board.tiles[target.y][target.x];
      if (!targetTile) {
        showAIAction(`‚ùå Attack failed: Target tile not found!`, 'failure');
        return;
      }
      
      // Check if AI has enough mercenaries
      if (aiStudent.mercenaries <= 0) {
        showAIAction(`‚ùå Attack failed: No mercenaries available!`, 'failure');
        return;
      }
      
      // Trigger the real battle system
      showAIAction(`‚öîÔ∏è Initiating battle against ${target.name}...`, 'battle');
      
      // Pause AI sequence to show battle
      isAITurnSequenceActive = false;
      
      // Trigger battle modal
      await triggerBattleModal(aiStudent, targetTile, target.x, target.y);
      
      // Resume AI sequence after battle
      setTimeout(() => {
        isAITurnSequenceActive = true;
        nextAIAction();
      }, 1000);
      
    } catch (error) {
      console.error('AI attack error:', error);
      showAIAction(`‚ùå Attack failed: ${error.message}`, 'failure');
    }
  }
  
  // Trigger battle modal for AI attacks
  async function triggerBattleModal(attacker, targetTile, targetX, targetY) {
    // Set up battle state
    state.battle = {
      attacker: attacker.gsId,
      defender: targetTile.owner,
      targetTile: { x: targetX, y: targetY },
      attackerData: attacker,
      defenderData: state.roster.find(s => s.gsId === targetTile.owner) || 
                   state.aiPlayers?.find(s => s.gsId === targetTile.owner)
    };
    
    // Show battle modal
    showBattleModal();
  }
  
  async function simulateAttack(aiStudent, target) {
    // Simplified attack simulation (fallback)
    const success = Math.random() < 0.7; // 70% success rate
    if (success) {
      aiStudent.tilesOwned += 1;
      showAIAction(`üéâ Attack successful! ${aiStudent.name} conquers ${target.name}!`, 'success');
    } else {
      aiStudent.mercenaries = Math.max(0, aiStudent.mercenaries - 1);
      showAIAction(`üí• Attack failed! ${aiStudent.name} loses a mercenary.`, 'failure');
    }
  }

</script>
<script src="scenarios.js"></script>
</body>
</html>