<!DOCTYPE html>
<html>
<head>
  <title>Tornado Game</title>
  <style>
    /* ... existing styles ... */
  </style>
</head>
<body>
  <!-- ... existing HTML ... -->
  <script>
    let quizLibrary = [];
    fetch('quiz_library.json')
      .then(response => {
        if (!response.ok) throw new Error('Quiz library not found');
        return response.json();
      })
      .then(data => {
        quizLibrary = data;
        // If you have a function to populate the quiz dropdown, call it here
        if (typeof populateQuizDropdown === 'function') populateQuizDropdown();
      })
      .catch(err => {
        alert('Failed to load quiz library: ' + err.message);
        quizLibrary = [];
      });

    // Modify Start Game logic to use selected quiz if chosen
    startBtnTop.onclick = startBtnBottom.onclick = () => {
      names.A = document.getElementById('teamANameInput').value.trim()||'Team A';
      names.B = document.getElementById('teamBNameInput').value.trim()||'Team B';
      total = +document.getElementById('gridSizeInput').value;

      // Get special item counts from selectors
      let tornadoCount = parseInt(document.getElementById('tornadoCount').value);
      let doubleCount = parseInt(document.getElementById('doubleCount').value);
      let loseCount = parseInt(document.getElementById('loseCount').value);
      let swapCount = parseInt(document.getElementById('swapCount').value);

      // Adjust defaults for small grids
      if (total <= 10) {
        tornadoCount = 2;
        doubleCount = 1;
        loseCount = 1;
        swapCount = 1;
        document.getElementById('tornadoCount').value = 2;
        document.getElementById('doubleCount').value = 1;
        document.getElementById('loseCount').value = 1;
        document.getElementById('swapCount').value = 1;
      }

      // Use quiz if selected, otherwise use textarea
      if (selectedQuizIndex !== null && quizLibrary[selectedQuizIndex]) {
        const quiz = quizLibrary[selectedQuizIndex];
        // Support both {question, answer} and [questions, answers] formats
        if (quiz.questions && Array.isArray(quiz.questions) && quiz.answers && Array.isArray(quiz.answers) && quiz.questions.length === quiz.answers.length) {
          // Deduplicate questions while preserving order
          const uniqueQuestions = new Map();
          quiz.questions.forEach((q, i) => {
            if (!uniqueQuestions.has(q)) {
              uniqueQuestions.set(q, { question: q, answer: quiz.answers[i] });
            }
          });
          questions = Array.from(uniqueQuestions.values());
        } else if (quiz.questions && Array.isArray(quiz.questions) && typeof quiz.questions[0] === 'object') {
          // Deduplicate questions while preserving order
          const uniqueQuestions = new Map();
          quiz.questions.forEach(q => {
            if (!uniqueQuestions.has(q.question)) {
              uniqueQuestions.set(q.question, { question: q.question, answer: q.answer || null });
            }
          });
          questions = Array.from(uniqueQuestions.values());
        } else {
          // Deduplicate questions while preserving order
          const uniqueQuestions = new Map();
          quiz.questions.forEach(q => {
            if (!uniqueQuestions.has(q)) {
              uniqueQuestions.set(q, { question: q, answer: null });
            }
          });
          questions = Array.from(uniqueQuestions.values());
        }
      } else {
        const raw = questionsInput.value;
        // split blocks on blank line
        const blocks = raw.split(/\n\s*\n/).map(b=>b.trim()).filter(b=>b);
        // detect Q&A blocks
        if(blocks.some(b => b.split('\n').length>1)){
          questions = blocks.map(b=>{
            const [q,a] = b.split('\n');
            return { question:q.trim(), answer:a?.trim()||null };
          });
        } else {
          questions = raw
            .split('\n').map(l=>l.trim()).filter(l=>l)
            .map(q=>({ question:q.replace(/^\d+\.\s*/,''), answer:null }));
        }
      }
      // Prepare usedQuestionIndices for unique rotation
      usedQuestionIndices = [];
      let order = document.querySelector('input[name="order"]:checked').value;
      if (order === 'random') {
        // Shuffle indices
        usedQuestionIndices = Array.from({length: questions.length}, (_, i) => i);
        for (let i = usedQuestionIndices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [usedQuestionIndices[i], usedQuestionIndices[j]] = [usedQuestionIndices[j], usedQuestionIndices[i]];
        }
      } else {
        usedQuestionIndices = Array.from({length: questions.length}, (_, i) => i);
      }
      qIndex = 0;
      setupScreen.classList.add('hidden');
      gameScreen.classList.remove('hidden');
      initGame(tornadoCount, doubleCount, loseCount, swapCount); buildGrid(total); showQuestion();
    };

    // ... rest of existing code ...
  </script>
</body>
</html> 